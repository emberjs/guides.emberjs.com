{"documents": [{"external_id":"bbea5c36469fadcdc12630c03724b79f","fields":[{"name":"title","value":"Composing Components","type":"string"},{"name":"url","value":"/components/composing-components/","type":"enum"},{"name":"body","value":"Components really shine when you use them to their full potential, that is, by composing them with one another.\nTake for example the \u003cul\u003e element, and the fact that only \u003cli\u003e elements are appropriate as children.\nIf we want the same type of behavior, then we have to compose our components.\n\nJust like we compose regular HTML elements, we can do the same with components.\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#user-list users=activeUsers sortBy='name' as |user|}}\n  {{user-card user=user}}\n{{/user-list}}\n\n\nComponent Blocks\nComponents can be used in two forms, just like regular HTML elements.\n\nInline Form\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n\n  {{user-list users=activeUsers}}\n\n\n\nThis is the basic blockless form of a component, which doesn't give the\nconsumer the ability to insert their own content into the given component.\nIt's even possible that a component can only be used in this form.\nMake sure to consult a component's documentation for its available uses\nand forms.\n\nBlock Form\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#user-list users=activeUsers}}\n  {{!-- custom template here --}}\n{{/user-list}}\n\n\n\nTo compose components, we must use the block form, but we must also\nbe able to distinguish from within our component which form is being used.\nThis can be done with the hasBlock property from within our component.\n\n  \n    \n      app/templates/components/user-list.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  {{#if hasBlock}}\n  {{yield}}\n{{else}}\n  \u003cp\u003eNo Block Specified\u003c/p\u003e\n{{/if}}\n\n\n\nOnce we know that the component is being used in block form, we can yield\nwhatever the user has placed inside the block wherever we want via the {{yield}} helper.\n\nThis {{yield}} helper can be used in the component's template definition multiple times,\nallowing us to create a component that works like a list, where we output a headline and yielded body for each post.\n\n  \n    \n      app/templates/components/post-list.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  {{#each posts as |post|}}\n  \u003ch3\u003e{{post.title}}\u003c/h3\u003e\n  \u003cp\u003e{{yield}}\u003c/p\u003e\n{{/each}}\n\n\n\nWhich can be used like so:\n\n  \n    \n      app/templates/posts.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#post-list posts=headlinePosts}}\n  Greatest post ever!\n{{/post-list}}\n\n\n\nAnd will result in the following HTML:\n\n  1\n2\n3\n4\n5\n6\n\n  \u003cdiv id=\"ember123\" class=\"ember-view\"\u003e\n  \u003ch3\u003eTomster goes to town\u003c/h3\u003e\n  \u003cp\u003eGreatest post ever!\u003c/p\u003e\n  \u003ch3\u003eTomster on vacation\u003c/h3\u003e\n  \u003cp\u003eGreatest post ever!\u003c/p\u003e\n\u003c/div\u003e\n\n\n\nBut what use is it to just output the same thing over and over? Don't we want to customize our posts,\nand display the right content? Sure we do. Lets explore the {{yield}} helper a bit.\nData Down\nTo accomplish composability beyond simple templates, we need to pass data to those templates. This can be done with the {{yield}} helper that was introduced above.\n\nThe {{yield}} defines where the content we defined inside our component block will yield in the component's layout,\nas we saw in the previous section. Apart from that, the yield helper also allows us to send data down by yielding params back to the scope the component was invoked in.\n\n  1\n2\n3\n4\n\n  {{yield}}\n{{yield \"post\"}}\n{{yield item}}\n{{yield this \"footer\"}}\n\n\n\nBy default yield does not send any data, but you can provide an arbitrary number of parameters. Also, the yielded values are ordered sequentially by how they are defined, so you access them in the same order as the component exposes them.\nSending data down allows the consumer of our component to utilize that data.\nFor the consumer to get access to the data, she needs to know what data a component exposes,\nthis is where documentation is so crucial, and from there the yielded data can be accessed\nwith the as operator. Let's take the following template as an example:\n\n  \n    \n      app/components/user-list/template.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#each users as |user|}}\n  {{yield user}}\n{{/each}}\n\n\n\nThis {{user-list}} component will yield as many times as there are users.\nWe can consume it in the following way:\n\n  \n    \n      app/users/template.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#user-list users=users as |user|}}\n  {{user-card user=user}}\n{{/user-list}}\n\n\n\nNow {{user-card}} has access to the current user, which changes as the {{user-list}} iterates over each user\nsince the {{yield user}} is inside the {{each}} block. Although this is nice, what if we used our component\nwithout a block, i.e. {{user-list users=users}}? This would make the component pretty useless since nothing is yielding,\nbut the users are still being iterated. Let's mix in the hasBlock attribute and see if we can make it more useful.\n\n  \n    \n      app/components/user-list/template.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  {{#if hasBlock}}\n  {{#each users as |user|}}\n    {{yield user}}\n  {{/each}}\n{{else}}\n  {{#each users as |user|}}\n    \u003csection class=\"user-info\"\u003e\n      \u003ch3\u003e{{user.name}}\u003c/h3\u003e\n      \u003cp\u003e{{user.bio}}\u003c/p\u003e\n    \u003c/section\u003e\n  {{/each}}\n{{/if}}\n\n\n\nThis makes our component more useful due too it having sane defaults, but it also allows us to override those defaults. By using the {{yield}} helper we can pass\ndown our params for the consumer to utilize. This makes the concept of passing\ndata down very useful.\n{{component}} Helper\nTo understand the {{component}} helper, we will add the following new features to the {{user-list}} component:\n\n\nFor each type of user, we want to use different layout.\nThe list can also be toggled between basic and detailed mode.\n\n\nLet's add a new type of user, a superuser, which will have different behavior in our application. How would the consumer use this new data to show a different\nUI for each type of user? This is where the {{component}} helper comes into play. This helper allows us to render a component chosen at runtime.\n\nSince we have two user types, 'public' and 'superuser', and we want to render\na component for each type plus for the simple and detailed modes. We want to have the following component names:\n\n\nbasic-card-public\nbasic-card-superuser\ndetailed-card-public\ndetailed-card-superuser\n\n\nWe can create these names by using the {{concat}} helper in nested form.\n\n  1\n\n  {{component (concat 'basic-card-' user.type)}}\n\n\n\nNow that our component names are valid due to the use of dashed, we can put together the full template with the two modes.\n\n  \n    \n      app/users/template.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  {{#user-list users=users as |user basicMode|}}\n  {{#if basicMode}}\n    {{component (concat 'basic-card-' user.type) user=user}}\n  {{else}}\n    {{component (concat 'detailed-card-' user.type) user=user}}\n  {{/if}}\n{{/user-list}}\n\n\n\nNow we have {{basic-card-superuser}} and {{detailed-card-public}} rendering in their respective places\nbased on the user.type equaling 'superuser' and 'public' respectively. The use of the 'concat' helper in nested form allowed us to accomplish that. Nested helpers are evaluated before the parent helper\nand then that helper can use the value returned by the nested helper. In this case it's just a concatenation of two values. You can\nalso experiment with other helpers in nested form, like the if helper.\n\nApart from the use of {{component}}, we also have the second yielded value for our basic/detailed mode feature,\nwhich we've added to our yield, i.e. {{yield user basic}}.\n\nThe consumer can decide how to name the yielded values. We could have named our yields like so:\n\n  \n    \n      app/users/template.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#user-list users=users as |userModel isBasic|}}\n  {{! something creative here }}\n{{/user-list}}\n\n\nActions Up\nNow that we know how to send data down, we probably want to manipulate that data via some user interaction,\nlike changing a user's avatar. We can accomplish this by using actions.\n\nWe'll be looking at a {{user-profile}} component that implements a save action. By yielding the action as a parameter, we allow the consumer to use this component without having to know how to save, but still be able to trigger a save.\n\nHere's our component's definition:\n\n  \n    \n      app/components/user-profile/component.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  actions: {\n    saveUser() {\n      var user = this.get('user');\n\n      user.save()\n        .then(() =\u003e {\n          this.set('saved', true);\n        })\n        .catch(error =\u003e {\n          this.set('saveError', error);\n        });\n    }\n  }\n});\n\n\n\n  \n    \n      app/components/user-profile/template.hbs\n    \n  \n\n  1\n2\n\n  {{! most likely we have some markup here }}\n{{yield profile (action \"saveUser\")}}\n\n\n\nSo now the consumer will have access to our data and the\naction that we have defined. Lets see how this component could be consumed\nin block form.\n\n  \n    \n      app/templates/user/profile.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#user-profile user=user as |profile saveUser|}}\n  {{user-avatar url=profile.imageUrl onchange=saveUser}}\n{{/user-profile}}\n\n\n\nAs you can see from this example, the consumer was able to hook into the\n{{user-profile}} component's saveUser action, which we passed down\nwith the (action \"saveUser\") nested helper.  This helper reads a property off the actions hash of the current context, then creates a closure over that function and any arguments you pass.\n\nWe could also leverage this format to place actions on native HTML elements\nlike an input button:\n\n  1\n2\n3\n\n  {{#user-profile user=user as |profile saveUser|}}\n  \u003cbutton type=\"button\" onclick={{action saveUser}}\u003eSave\u003c/button\u003e\n{{/user-profile}}\n\n\n\nThis is very useful since we are reusing the existing event hooks that\nare provided on these elements. This makes components much more reusable due to how we can compose\nsmall components that do one thing well.\nWrapping Up\nComposing components is all about isolating functionality into reusable\nchunks that are easy to reason about and easy to combine together so that they work well together.\nThis also has the added benefit of easier testing since we try to stay away from\nmonolithic components that do everything, and can isolate small parts of functionality.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"47913aec12ee9dbd0749f8ee0c891428","fields":[{"name":"title","value":"Customizing a Component's Element","type":"string"},{"name":"url","value":"/components/customizing-a-components-element/","type":"enum"},{"name":"body","value":"By default, each component is backed by a \u003cdiv\u003e element. If you were\nto look at a rendered component in your developer tools, you would see\na DOM representation that looked something like:\n\n  1\n2\n3\n\n  \u003cdiv id=\"ember180\" class=\"ember-view\"\u003e\n  \u003ch1\u003eMy Component\u003c/h1\u003e\n\u003c/div\u003e\n\n\n\nYou can customize what type of element Ember generates for your\ncomponent, including its attributes and class names, by creating a\nsubclass of Ember.Component in your JavaScript.\nCustomizing the Element\nTo use a tag other than div, subclass Ember.Component and assign it\na tagName property. This property can be any valid HTML5 tag name as a\nstring.\n\n  \n    \n      app/components/navigation-bar.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  tagName: 'nav'\n});\n\n\n\n  \n    \n      app/templates/components/navigation-bar.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003cul\u003e\n  \u003cli\u003e{{#link-to 'home'}}Home{{/link-to}}\u003c/li\u003e\n  \u003cli\u003e{{#link-to 'about'}}About{{/link-to}}\u003c/li\u003e\n\u003c/ul\u003e\n\n\nCustomizing Class Names\nYou can also specify which class names are applied to the component's\nelement by setting its classNames property to an array of strings:\n\n  \n    \n      app/components/navigation-bar.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  classNames: ['primary']\n});\n\n\n\nIf you want class names to be determined by properties of the component,\nyou can use class name bindings. If you bind to a Boolean property, the\nclass name will be added or removed depending on the value:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isUrgent'],\n  isUrgent: true\n});\n\n\n\nThis component would render the following:\n\n  1\n\n  \u003cdiv class=\"ember-view is-urgent\"\u003e\u003c/div\u003e\n\n\n\nIf isUrgent is changed to false, then the is-urgent class name will be removed.\n\nBy default, the name of the Boolean property is dasherized. You can customize the class name\napplied by delimiting it with a colon:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isUrgent:urgent'],\n  isUrgent: true\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view urgent\"\u003e\n\n\n\nBesides the custom class name for the value being true, you can also specify a class name which is used when the value is false:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isEnabled:enabled:disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nYou can also specify a class which should only be added when the property is\nfalse by declaring classNameBindings like this:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isEnabled::disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nIf the isEnabled property is set to true, no class name is added:\n\n  1\n\n  \u003cdiv class=\"ember-view\"\u003e\n\n\n\nIf the bound property's value is a string, that value will be added as a class name without\nmodification:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['priority'],\n  priority: 'highestPriority'\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view highestPriority\"\u003e\n\n\nCustomizing Attributes\nYou can bind attributes to the DOM element that represents a component\nby using attributeBindings:\n\n  \n    \n      app/components/link-item.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  tagName: 'a',\n  attributeBindings: ['href'],\n  href: \"http://emberjs.com\"\n});\n\n\n\nYou can also bind these attributes to differently named properties:\n\n  \n    \n      app/components/link-item.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  tagName: 'a',\n  attributeBindings: ['customHref:href'],\n  customHref: \"http://emberjs.com\"\n});\n\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6faa3aaa66dd8ba5f798d307f0136e3c","fields":[{"name":"title","value":"Defining a Component","type":"string"},{"name":"url","value":"/components/defining-a-component/","type":"enum"},{"name":"body","value":"To define a component, create a template whose name starts with\ncomponents/. To define a new component, {{blog-post}} for example,\ncreate a components/blog-post template.\n\nNote: Components must have at least one dash in their name. So blog-post is an acceptable name, so is audio-player-controls, but post is not. This prevents clashes with current or future HTML element names, and\nensures Ember detects the components automatically.\n\nA sample component template would look like this:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003eBlog Post\u003c/h1\u003e\n\u003cp\u003eLorem ipsum dolor sit amet.\u003c/p\u003e\n\n\n\nHaving a template whose name starts with components/ creates a\ncomponent of the same name. Given the above template, you can now use the\n{{blog-post}} custom element:\n\n\n\n\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  {{#each model as |post|}}\n  {{#blog-post title=post.title}}\n    {{post.body}}\n  {{/blog-post}}\n{{/each}}\n\n\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003carticle class=\"blog-post\"\u003e\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n  \u003cp\u003e{{yield}}\u003c/p\u003e\n  \u003cp\u003eEdit title: {{input type=\"text\" value=title}}\u003c/p\u003e\n\u003c/article\u003e\n\n\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  var posts = [{\n    title: \"Rails is omakase\",\n    body: \"There are lots of à la carte software environments in this world.\"\n  }, {\n    title: \"Broken Promises\",\n    body: \"James Coglan wrote a lengthy article about Promises in node.js.\"\n}];\n\nexport default Ember.Route.extend({\n  model() {\n    return posts;\n  }\n});\n\n\n\n  \n    \n      app/components/blog-post.js\n    \n  \n\n  1\n2\n\n  export default Ember.Component.extend({\n});\n\n\n\nEach component, under the hood, is backed by an element. By default\nEmber will use a \u003cdiv\u003e element to contain your component's template.\nTo learn how to change the element Ember uses for your component, see\nCustomizing a Component's\nElement.\nDefining a Component Subclass\nOften times, your components will just encapsulate certain snippets of\nHandlebars templates that you find yourself using over and over. In\nthose cases, you do not need to write any JavaScript at all. Just define\nthe Handlebars template as described above and use the component that is\ncreated.\n\nIf you need to customize the behavior of the component you'll\nneed to define a subclass of Ember.Component. For example, you would\nneed a custom subclass if you wanted to change a component's element,\nrespond to actions from the component's template, or manually make\nchanges to the component's element using JavaScript.\n\nEmber knows which subclass powers a component based on its filename. For\nexample, if you have a component called blog-post, you would create a\nfile at app/components/blog-post.js. If your component was called\naudio-player-controls, the file name would be at\napp/components/audio-player-controls.js.\nDynamically rendering a component\nThe {{component}} helper can be used to defer the selection of a component to\nrun time. The {{my-component}} syntax would always render the same component,\nwhereas using the {{component}} helper allows swapping the component rendered\non the fly. This is useful in cases where, for example, you want to interact\nwith different external libraries depending on the data. Using the {{component}}\nhelper would allow you to keep those different logic well-separated.\n\nThe first parameter of the helper is the name of a component to render, as a string. So if you have {{component 'blog-post'}}, that is just the same as just {{blog-post}}.\n\nThe real value of {{component}} comes from being able to dynamically pick\nthe component being rendered. Below is an example of using the helper as a\nmean to dispatch to different components for displaying different kinds of posts:\n\n  \n    \n      app/templates/components/foo-component.hbs\n    \n  \n\n  1\n2\n\n  \u003ch3\u003eHello from foo!\u003c/h3\u003e\n\u003cp\u003e{{post.body}}\u003c/p\u003e\n\n\n\n  \n    \n      app/templates/components/bar-component.hbs\n    \n  \n\n  1\n2\n\n  \u003ch3\u003eHello from bar!\u003c/h3\u003e\n\u003cdiv\u003e{{post.author}}\u003c/div\u003e\n\n\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  var posts = [{\n    componentName: 'foo-component',  // key used to determine the rendered component\n    body: \"There are lots of à la carte software environments in this world.\"\n  }, {\n    componentName: 'bar-component',\n    author: \"Drew Crawford\"\n}];\n\nexport default Ember.Route.extend({\n  model() {\n    return posts;\n  }\n});\n\n\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  {{#each model as |post|}}\n  {{!-- either foo-component or bar-component --}}\n  {{component post.componentName post=post}}\n{{/each}}\n\n\n\nFor brevity, componentName is hardcoded inside each post, but it can very\nwell be a computed property that deduces the target component based on the data.\n\nWhen the parameter passed to {{component}} evaluates to null or undefined,\nthe helper renders nothing. When the parameter changes, the currently rendered\ncomponent is destroyed and the new component is created and brought in.\n\nPicking different components to render in response to the data allows you to\nhave different template and behavior for each case. The {{component}} helper\nis a powerful tool for improving code modularity.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"89cbe21cbd7181ade5de9485d9bd1da7","fields":[{"name":"title","value":"Handling User Interaction with Actions","type":"string"},{"name":"url","value":"/components/handling-user-interaction-with-actions/","type":"enum"},{"name":"body","value":"Components allow you to define controls that you can reuse throughout\nyour application. If they're generic enough, they can also be shared\nwith others and used in multiple applications.\n\nTo make a reusable control useful, however, you first need to allow\nusers of your application to interact with it.\n\nYou can make elements in your component interactive by using the\n{{action}} helper. This is the same {{action}} helper you use in\napplication templates, but it has an\nimportant difference when used inside a component.\n\nInstead of sending an action to the template's controller, then bubbling\nup the route hierarchy, actions sent from inside a component are sent\ndirectly to the component's Ember.Component instance, and do not\nbubble.\n\nFor example, imagine the following component that shows a post's title.\nWhen the title is clicked, the entire post body is shown:\n\n  \n    \n      app/templates/components/post-summary.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003ch3 {{action \"toggleBody\"}}\u003e{{title}}\u003c/h3\u003e\n{{#if isShowingBody}}\n  \u003cp\u003e{{{body}}}\u003c/p\u003e\n{{/if}}\n\n\n\n  \n    \n      app/components/post-summary.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  actions: {\n    toggleBody() {\n      this.toggleProperty('isShowingBody');\n    }\n  }\n});\n\n\n\n\n\nThe {{action}} helper can accept arguments, listen for different event\ntypes, control how action bubbling occurs, and more.\n\nFor details about using the {{action}} helper, see the Actions\nsection of the Templates chapter.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a7fac78db6b283e0bea80138768d18ef","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/components/","type":"enum"},{"name":"body","value":"HTML was designed in a time when the browser was a simple document\nviewer. Developers building great web apps need something more.\n\nInstead of trying to replace HTML, however, Ember.js embraces it, then adds\npowerful new features that modernize it for building web apps.\n\nCurrently, you are limited to the tags that are created for you by the\nW3C. Wouldn't it be great if you could define your own,\napplication-specific HTML tags, then implement their behavior using\nJavaScript?\n\nThat's exactly what components let you do. In fact, it's such a good\nidea that the W3C is currently working on the Custom\nElements\nspec.\n\nEmber's implementation of components hews as closely to the Web\nComponents specification as possible.\nOnce Custom Elements are widely available in browsers, you should be able to\neasily migrate your Ember components to the W3C standard and have them be\nusable by other frameworks.\n\nThis is so important to us that we are working closely with the\nstandards bodies to ensure our implementation of components matches the\nroadmap of the web platform.\n\nTo highlight the power of components, here is a short example of turning a blog post into a reusable\nblog-post custom element that you could use again and again in your\napplication. Keep reading this section for more details on building\ncomponents.\n\n\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  {{#each model as |post|}}\n   {{#blog-post title=post.title}}\n     {{post.body}}\n   {{/blog-post}}\n{{/each}}\n\n\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003carticle class=\"blog-post\"\u003e\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n  \u003cp\u003e{{yield}}\u003c/p\u003e\n  \u003cp\u003eEdit title: {{input type=\"text\" value=title}}\u003c/p\u003e\n\u003c/article\u003e\n\n\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  var posts = [{\n    title: \"Rails is omakase\",\n    body: \"There are lots of à la carte software environments in this world.\"\n  }, {\n    title: \"Broken Promises\",\n    body: \"James Coglan wrote a lengthy article about Promises in node.js.\"\n}];\n\nexport default Ember.Route.extend({\n  model() {\n    return posts;\n  }\n});\n\n\n\n  \n    \n      app/components/blog-post.js\n    \n  \n\n  1\n2\n\n  export default Ember.Component.extend({\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8d2797c18261ac73c76de693da7cae13","fields":[{"name":"title","value":"Passing Properties to a Component","type":"string"},{"name":"url","value":"/components/passing-properties-to-a-component/","type":"enum"},{"name":"body","value":"By default a component does not have access to properties in the\ntemplate scope in which it is used.\n\nFor example, imagine you have a blog-post component that is used to\ndisplay a blog post:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003eComponent: {{title}}\u003c/h1\u003e\n\u003cp\u003eLorem ipsum dolor sit amet.\u003c/p\u003e\n\n\n\nYou can see that it has a {{title}} Handlebars expression to print the\nvalue of the title property inside the \u003ch1\u003e.\n\nNow imagine we have the following template and route:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  model() {\n    return {\n      title: \"Rails is omakase\"\n    };\n  }\n});\n\n\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n\n  \n\u003ch1\u003eTemplate: {{title}}\u003c/h1\u003e\n{{blog-post}}\n\n\n\nRunning this code, you will see that the first \u003ch1\u003e (from the outer\ntemplate) displays the title property, but the second \u003ch1\u003e (from\ninside the component) is empty.\n\n\n\nWe can fix this by making the title property available to the\ncomponent:\n\n  1\n\n  {{blog-post title=title}}\n\n\n\nThis will make the title property in the outer template scope\navailable inside the component's template using the same name, title.\n\n\n\nIf, in the above example, the model's title property was instead\ncalled name, we would change the component usage to:\n\n  1\n\n  {{blog-post title=name}}\n\n\n\n\n\nIn other words, you are binding a named property from the outer scope to\na named property in the component scope, with the syntax\ncomponentProperty=outerProperty.\n\nIt is important to note that the value of these properties is bound.\nWhether you change the value on the model or inside the component, the\nvalues stay in sync. In the following example, type some text in the\ntext field either in the outer template or inside the component and note\nhow they stay in sync.\n\n\n\nYou can also bind properties from inside an {{#each}} loop. This will\ncreate a component for each item and bind it to each model in the loop.\n\n  1\n2\n3\n\n  {{#each model as |post|}}\n  {{blog-post title=post.title}}\n{{/each}}\n\n\n\n\n\nIf you are using the {{component}} helper to render your component, you can\npass properties to the chosen component the same manner:\n\n  1\n\n  {{component componentName title=title name=name}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a770b7ecc3a463d75a45227c9b80486","fields":[{"name":"title","value":"Sending Actions from Components to Your Application","type":"string"},{"name":"url","value":"/components/sending-actions-from-components-to-your-application/","type":"enum"},{"name":"body","value":"When a component is used inside a template, it has the ability to send\nactions to that template's controller and routes. These allow the\ncomponent to inform the application when important events, such as the\nuser clicking a particular element in a component, occur.\n\nLike the {{action}} Handlebars helper, actions sent from components\nfirst go to the template's controller. If the controller does not\nimplement a handler for that action, it will bubble to the template's\nroute, and then up the route hierarchy. For more information about this\nbubbling behavior, see Action\nBubbling.\n\nComponents are designed to be reusable across different parts of your\napplication. In order to achieve this reusability, it's important that\nthe actions that your components send can be specified when the component\nis used in a template.\n\nIn other words, if you were writing a button component, you would not\nwant to send a click action, because it is ambiguous and likely to\nconflict with other components on the page. Instead, you would want to\nallow the person using the component to specify which action to send\nwhen the button was clicked.\n\nLuckily, components have a sendAction() method that allows them to\nsend actions specified when the component is used in a template.\nSending a Primary Action\nMany components only send one kind of action. For example, a button\ncomponent might send an action when it is clicked on; this is the\nprimary action.\n\nTo set a component's primary action, set its action attribute in\nHandlebars:\n\n  1\n\n  {{my-button action=\"showUser\"}}\n\n\n\nThis tells the my-button component that it should send the showUser\naction when it triggers its primary action.\n\nSo how do you trigger sending a component's primary action? After\nthe relevant event occurs, you can call the sendAction() method\nwithout arguments:\n\n  \n    \n      app/components/my-button.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  click() {\n    this.sendAction();\n  }\n});\n\n\n\nIn the above example, the my-button component will send the showUser\naction when the component is clicked.\nSending Parameters with an Action\nYou may want to provide additional context to the route or controller\nhandling an action. For example, a button component may want to tell a\ncontroller not only that an item was deleted, but also which item.\n\nTo send parameters with the primary action, call sendAction() with the\nstring 'action' as the first argument and any additional parameters\nfollowing it:\n\n  1\n\n  this.sendAction('action', param1, param2);\n\n\n\nFor example, imagine we're building a todo list that allows the user to\ndelete a todo:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  export default Ember.Route.extend({\n  model() {\n    return {\n      todos: [{\n        title: \"Learn Ember.js\"\n      }, {\n        title: \"Walk the dog\"\n      }]\n    };\n  },\n\n  actions: {\n    deleteTodo(todo) {\n      var todos = this.modelFor('index').todos;\n      todos.removeObject(todo);\n    }\n  }\n});\n\n\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#each model.todos as |todo|}}\n  \u003cp\u003e{{todo.title}} \u003cbutton {{action \"deleteTodo\" todo}}\u003eDelete\u003c/button\u003e\u003c/p\u003e\n{{/each}}\n\n\n\nWe want to update this app so that, before actually deleting a todo, the\nuser must confirm that this is what they intended. We'll implement a\ncomponent that first double-checks with the user before completing the\naction.\n\nIn the component, when triggering the primary action, we'll pass an\nadditional argument that the component user can specify:\n\n  \n    \n      app/components/confirm-button.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Component.extend({\n  actions: {\n    showConfirmation() {\n      this.toggleProperty('isShowingConfirmation');\n    },\n\n    confirm() {\n      this.toggleProperty('isShowingConfirmation');\n      this.sendAction('action', this.get('param'));\n    }\n  }\n});\n\n\n\n  \n    \n      app/templates/components/confirm-button.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  {{#if isShowingConfirmation}}\n  \u003cbutton {{action \"confirm\"}}\u003eClick again to confirm\u003c/button\u003e\n{{else}}\n  \u003cbutton {{action \"showConfirmation\"}}\u003e{{title}}\u003c/button\u003e\n{{/if}}\n\n\n\nNow we can update our initial template and replace the {{action}}\nhelper with our new component:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#each model.todos as |todo|}}\n  \u003cp\u003e{{todo.title}} {{confirm-button title=\"Delete\" action=\"deleteTodo\" param=todo}}\u003c/p\u003e\n{{/each}}\n\n\n\nNote that we've specified the action to send by setting the component's\naction attribute, and we've specified which argument should be sent as\na parameter by setting the component's param attribute.\n\n\nSending Multiple Actions\nDepending on the complexity of your component, you may need to let users\nspecify multiple different actions for different events that your\ncomponent can generate.\n\nFor example, imagine that you're writing a form component that the user\ncan either submit or cancel. Depending on which button the user clicks,\nyou want to send a different action to your controller or route.\n\nYou can specify which action to send by passing the name of the event\nas the first argument to sendAction(). For example, you can specify two\nactions when using the form component:\n\n  1\n\n  {{user-form submit=\"createUser\" cancel=\"cancelUserCreation\"}}\n\n\n\nIn this case, you can send the createUser action by calling\nthis.sendAction('submit'), or send the cancelUserCreation action by\ncalling this.sendAction('cancel').\n\n\nActions That Aren't Specified\nIf someone using your component does not specify an action for a\nparticular event, calling sendAction() has no effect.\n\nFor example, if you define a component that triggers the primary action\non click:\n\n  \n    \n      app/components/my-button.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  click() {\n    this.sendAction();\n  }\n});\n\n\n\nUsing this component without assigning a primary action will have no\neffect if the user clicks it:\n\n  1\n\n  {{my-button}}\n\n\nThinking About Component Actions\nIn general, you should think of component actions as translating a\nprimitive event (like a mouse click or an \u003caudio\u003e element's pause\nevent) into actions that have meaning within your application.\n\nThis allows your routes and controllers to implement action handlers\nwith names like deleteTodo or songDidPause instead of vague names\nlike click or pause that may be ambiguous to other developers when\nread out of context.\n\nAnother way to think of component actions is as the public API of your\ncomponent. Thinking about which events in your component can trigger\nactions in their application is the primary way other developers will\nuse your component. In general, keeping these events as generic as\npossible will lead to components that are more flexible and reusable.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e9763ebaa18b58c8fafed5531d19eb14","fields":[{"name":"title","value":"Wrapping Content in a Component","type":"string"},{"name":"url","value":"/components/wrapping-content-in-a-component/","type":"enum"},{"name":"body","value":"Sometimes, you may want to define a component that wraps content\nprovided by other templates.\n\nFor example, imagine we are building a blog-post component that we can\nuse in our application to display a blog post:\n\n  \n    \n      app/components/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003cdiv class=\"body\"\u003e{{body}}\u003c/div\u003e\n\n\n\nNow, we can use the {{blog-post}} component and pass it properties\nin another template:\n\n  1\n\n  {{blog-post title=title body=body}}\n\n\n\n\n\n(See Passing Properties to a\nComponent for\nmore.)\n\nIn this case, the content we wanted to display came from the model. But\nwhat if we want the developer using our component to be able to provide custom\nHTML content?\n\nIn addition to the simple form you've learned so far, components also\nsupport being used in block form. In block form, components can be\npassed a Handlebars template that is rendered inside the component's\ntemplate wherever the {{yield}} expression appears.\n\nTo use the block form, add a # character to the\nbeginning of the component name, then make sure to add a closing tag.\n(See the Handlebars documentation on block expressions for more.)\n\nIn that case, we can use the {{blog-post}} component in block form\nand tell Ember where the block content should be rendered using the\n{{yield}} helper. To update the example above, we'll first change the component's\ntemplate:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003cdiv class=\"body\"\u003e{{yield}}\u003c/div\u003e\n\n\n\nYou can see that we've replaced {{body}} with {{yield}}. This tells\nEmber that this content will be provided when the component is used.\n\nNext, we'll update the template using the component to use the block\nform:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  {{#blog-post title=title}}\n  \u003cp class=\"author\"\u003eby {{author}}\u003c/p\u003e\n  {{body}}\n{{/blog-post}}\n\n\n\n\n\nIt's important to note that the template scope inside the component\nblock is the same as outside. If a property is available in the template\noutside the component, it is also available inside the component block.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"62986c9e6cbee2077f1bd848372a19dc","fields":[{"name":"title","value":"Disabling Prototype Extensions","type":"string"},{"name":"url","value":"/configuring-ember/disabling-prototype-extensions/","type":"enum"},{"name":"body","value":"By default, Ember.js will extend the prototypes of native JavaScript\nobjects in the following ways:\n\n\nArray is extended to implement the Ember.Enumerable,\nEmber.MutableEnumerable, Ember.MutableArray and Ember.Array\ninterfaces. This polyfills ECMAScript 5 array methods in browsers that\ndo not implement them, adds convenience methods and properties to\nbuilt-in arrays, and makes array mutations observable.\nString is extended to add convenience methods, such as\ncamelize() and fmt().\nFunction is extended with methods to annotate functions as\ncomputed properties, via the property() method, and as observers,\nvia the observes() or observesBefore() methods.\n\n\nThis is the extent to which Ember.js enhances native prototypes. We have\ncarefully weighed the tradeoffs involved with changing these prototypes,\nand recommend that most Ember.js developers use them. These extensions\nsignificantly reduce the amount of boilerplate code that must be typed.\n\nHowever, we understand that there are cases where your Ember.js\napplication may be embedded in an environment beyond your control. The\nmost common scenarios are when authoring third-party JavaScript that is\nembedded directly in other pages, or when transitioning an application\npiecemeal to a more modern Ember.js architecture.\n\nIn those cases, where you can't or don't want to modify native\nprototypes, Ember.js allows you to completely disable the extensions\ndescribed above.\n\nTo do so, simply set the EmberENV.EXTEND_PROTOTYPES flag to false:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  ENV = {\n  EmberENV: {\n    EXTEND_PROTOTYPES: false\n  }\n}\n\n\n\nOr you can choose class which you want to disable prototype extension\nby added a property to your application's configuration:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  ENV = {\n  EmberENV: {\n    EXTEND_PROTOTYPES: {\n      String: false,\n      Array: true\n    }\n  }\n}\n\n\nLife Without Prototype Extension\nIn order for your application to behave correctly, you will need to\nmanually extend or create the objects that the native objects were\ncreating before.\nArrays\nNative arrays will no longer implement the functionality needed to\nobserve them. If you disable prototype extension and attempt to use\nnative arrays with things like a template's {{#each}} helper, Ember.js\nwill have no way to detect changes to the array and the template will\nnot update as the underlying array changes.\n\nAdditionally, if you try to set the model of an\nEmber.ArrayController to a plain native array, it will raise an\nexception since it no longer implements the Ember.Array interface.\n\nYou can manually coerce a native array into an array that implements the\nrequired interfaces using the convenience method Ember.A:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var islands = ['Oahu', 'Kauai'];\nislands.contains('Oahu');\n//=\u003e TypeError: Object Oahu,Kauai has no method 'contains'\n\n// Convert `islands` to an array that implements the\n// Ember enumerable and array interfaces\nEmber.A(islands);\n\nislands.contains('Oahu');\n//=\u003e true\n\n\nStrings\nStrings will no longer have the convenience methods described in the\nEmber.String API reference.. Instead,\nyou can use the similarly-named methods of the Ember.String object and\npass the string to use as the first parameter:\n\n  1\n2\n3\n4\n5\n\n  \"my_cool_class\".camelize();\n//=\u003e TypeError: Object my_cool_class has no method 'camelize'\n\nEmber.String.camelize(\"my_cool_class\");\n//=\u003e \"myCoolClass\"\n\n\nFunctions\nTo annotate computed properties, use the Ember.computed() method to\nwrap the function:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  // This won't work:\nfullName: function() {\n  return this.get('firstName') + ' ' + this.get('lastName');\n}.property('firstName', 'lastName')\n\n\n// Instead, do this:\nfullName: Ember.computed('firstName', 'lastName', function() {\n  return this.get('firstName') + ' ' + this.get('lastName');\n})\n\n\n\nObservers are annotated using Ember.observer():\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  // This won't work:\nfullNameDidChange: function() {\n  console.log(\"Full name changed\");\n}.observes('fullName')\n\n\n// Instead, do this:\nfullNameDidChange: Ember.observer('fullName', function() {\n  console.log(\"Full name changed\");\n})\n\n\n\nEvented functions are annotated using Ember.on():\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  // This won't work:\ndoStuffWhenInserted: function() {\n  /* awesome sauce */\n}.on('didInsertElement');\n\n// Instead, do this:\ndoStuffWhenInserted: Ember.on('didInsertElement', function() {\n  /* awesome sauce */\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"479923146262192b72f2b6cd4e92d83b","fields":[{"name":"title","value":"Embedding Applications","type":"string"},{"name":"url","value":"/configuring-ember/embedding-applications/","type":"enum"},{"name":"body","value":"In most cases, your application's entire UI will be created by templates\nthat are managed by the router.\n\nBut what if you have an Ember.js app that you need to embed into an\nexisting page, or run alongside other JavaScript frameworks?\nChanging the Root Element\nBy default, your application will render the application template\nand attach it to the document's body element.\n\nYou can tell the application to append the application template to a\ndifferent element by specifying its rootElement property:\n\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Application.extend({\n  rootElement: '#app'\n});\n\n\n\nThis property can be specified as either an element or a\njQuery-compatible selector\nstring.\nDisabling URL Management\nYou can prevent Ember from making changes to the URL by changing the\nrouter's location to\nnone:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n\n  var ENV = {\n  locationType: 'none'\n};\nexport default ENV;\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"32ec1a30c836c88e234758571f01a21e","fields":[{"name":"title","value":"Feature Flags","type":"string"},{"name":"url","value":"/configuring-ember/feature-flags/","type":"enum"},{"name":"body","value":"New features are added to Ember.js within conditional statements.\n\nCode behind these flags can be conditionally enabled\n(or completely removed) based on your project's configuration. This\nallows newly developed features to be selectively released when the\nEmber.js community considers them ready for production use.\nFeature Life-Cycle\nA newly-flagged feature is only available in canary builds and can be enabled\nat runtime through your project's configuration file.\n\nAt the start of a beta cycle the Ember core team evaluates each new feature.\nFeatures deemed stable are made available in the next beta and enabled by default.\n\nBeta features that receive negative feedback from the community are disabled in the next beta point\nrelease, and are not included in the next stable release. They may still be included\nin the next beta cycle if the issues/concerns are resolved.\n\nOnce the beta cycle has completed the next stable release will include any features that\nwere enabled during the beta cycle. At this point the feature flags will be removed from\nthe canary and future beta branches and the feature becomes of the framework.\nFlagging Details\nThe flag status in the generated build is controlled by the features.json\nfile in the root of the Ember.js project. This file lists all new features and their current status.\n\nA feature can have one of a three flags:\n\n\ntrue - The feature is present and enabled: the code behind the flag is always enabled in\nthe generated build.\nnull - The feature is present but disabled in the build output. It must be enabled at\nruntime.\nfalse - The feature is entirely disabled: the code behind the flag is not present in\nthe generated build.\n\n\nThe process of removing the feature flags from the resulting build output is\nhandled by defeatureify.\nFeature Listing (FEATURES.md)\nWhen a developer adds a new feature canary channel (i.e. the master branch on github), they\nalso add an entry to FEATURES.md\nexplaining what the feature does and linking to their originating pull request.\nThis list is kept current, and reflects what is available in each channel\n(stable, beta, and master).\nEnabling At Runtime\nWhen using the Ember.js canary or beta builds you can enable any \"present but disabled\"\nby setting its flag value to true before your application boots:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var ENV = {\n  EmberENV: {\n    FEATURES: {\n      'link-to': true\n    }\n  }\n};\n\nexport default ENV;\n\n\n\nFor the truly ambitious developer, setting ENV.EmberENV.ENABLE_ALL_FEATURES to true will enable all\nexperimental features.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3cddcc7a01c23b72f74ea3eceaaada93","fields":[{"name":"title","value":"Adding New Features","type":"string"},{"name":"url","value":"/contributing/adding-new-features/","type":"enum"},{"name":"body","value":"In general, new feature development should be done on master.\n\nBugfixes should not introduce new APIs or break existing APIs, and do\nnot need feature flags.\n\nFeatures can introduce new APIs, and need feature flags. They should not\nbe applied to the release or beta branches, since SemVer requires\nbumping the minor version to introduce new features.\n\nSecurity fixes should not introduce new APIs, but may, if strictly\nnecessary, break existing APIs. Such breakages should be as limited as\npossible.\nBug FixesUrgent Bug Fixes\nUrgent bugfixes are bugfixes that need to be applied to the existing\nrelease branch. If possible, they should be made on master and prefixed\nwith [BUGFIX release].\nBeta Bug Fixes\nBeta bugfixes are bugfixes that need to be applied to the beta branch.\nIf possible, they should be made on master and tagged with [BUGFIX\nbeta].\nSecurity Fixes\nSecurity fixes need to be applied to the beta branch, the current\nrelease branch, and the previous tag. If possible, they should be made\non master and tagged with [SECURITY].\nFeatures\nFeatures must always be wrapped in a feature flag. Tests for the feature\nmust also be wrapped in a feature flag.\n\nBecause the build-tools will process feature-flags, flags must use\nprecisely this format. We are choosing conditionals rather than a block\nform because functions change the surrounding scope and may introduce\nproblems with early return.\n\n  1\n2\n3\n\n  if (Ember.FEATURES.isEnabled(\"feature\")) {\n  // implementation\n}\n\n\n\nTests will always run with all features on, so make sure that any tests\nfor the feature are passing against the current state of the feature.\nCommits\nCommits related to a specific feature should include  a prefix like\n[FEATURE htmlbars]. This will allow us to quickly identify all commits\nfor a specific feature in the future. Features will never be applied to\nbeta or release branches. Once a beta or release branch has been cut, it\ncontains all of the new features it will ever have.\n\nIf a feature has made it into beta or release, and you make a commit to\nmaster that fixes a bug in the feature, treat it like a bugfix as\ndescribed above.\nFeature Naming Conventions\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n\n  Ember.FEATURES[\"\u003cpackageName\u003e-\u003cfeature\u003e\"] // if package specific\nEmber.FEATURES[\"container-factory-injections\"]\nEmber.FEATURES[\"htmlbars\"]\n\n\nBuilds\nThe Canary build, which is based off master, will include all features,\nguarded by the conditionals in the original source. This means that\nusers of the canary build can enable whatever features they want by\nenabling them before creating their Ember.Application.\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  module.exports = function(environment) {\n  var ENV = {\n    EmberENV: {\n      FEATURES: {\n        htmlbars: true\n      }\n    },\n  }\n}\n\n\nfeatures.json\nThe root of the repository will contain a features.json file, which will\ncontain a list of features that should be enabled for beta or release\nbuilds.\n\nThis file is populated when branching, and may not gain additional\nfeatures after the original branch. It may remove features.\n\n  1\n2\n3\n\n  {\n  \"htmlbars\": true\n}\n\n\n\nThe build process will remove any features not included in the list, and\nremove the conditionals for features in the list.\nTravis Testing\nFor a new PR:\n\n\nTravis will test against master with all feature flags on.\nIf a commit is tagged with [BUGFIX beta], Travis will also\ncherry-pick the commit into beta, and run the tests on that\nbranch. If the commit doesn't apply cleanly or the tests fail, the\ntests will fail.\nIf a commit is tagged with [BUGFIX release], Travis will also cherry-pick\nthe commit into release, and run the test on that branch. If the commit\ndoesn't apply cleanly or the tests fail, the tests will fail.\n\n\nFor a new commit to master:\n\n\nTravis will run the tests as described above.\nIf the build passes, Travis will cherry-pick the commits into the\nappropriate branches.\n\n\nThe idea is that new commits should be submitted as PRs to ensure they\napply cleanly, and once the merge button is pressed, Travis will apply\nthem to the right branches.\nGo/No-Go Process\nEvery six weeks, the core team goes through the following process.\nBeta Branch\nAll remaining features on the beta branch are vetted for readiness. If\nany feature isn't ready, it is removed from features.json.\n\nOnce this is done, the beta branch is tagged and merged into release.\nMaster Branch\nAll features on the master branch are vetted for readiness. In order for\na feature to be considered \"ready\" at this stage, it must be ready as-is\nwith no blockers. Features are a no-go even if they are close and\nadditional work on the beta branch would make it ready.\n\nBecause this process happens every six weeks, there will be another\nopportunity for a feature to make it soon enough.\n\nOnce this is done, the master branch is merged into beta. A\nfeatures.json file is added with the features that are ready.\nBeta Releases\nEvery week, we repeat the Go/No-Go process for the features that remain\non the beta branch. Any feature that has become unready is removed from\nthe features.json.\n\nOnce this is done, a Beta release is tagged and pushed.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"26d81f9d1949f3951aa7d9505e7280dd","fields":[{"name":"title","value":"Repositories","type":"string"},{"name":"url","value":"/contributing/repositories/","type":"enum"},{"name":"body","value":"Ember is made up of several libraries. If you wish to add a feature or fix a bug please file a pull request against the appropriate repository. Be sure to check the libraries listed below before making changes in the Ember.js repository.\nMain Repositories\nEmber.js - The main repository for Ember.\n\n\nhttps://github.com/emberjs/ember.js\n\n\nEmber Data - A data persistence library for Ember.js.\n\n\nhttps://github.com/emberjs/data\n\n\nEmber Website - Source for http://emberjs.com\n\n\nhttps://github.com/emberjs/website\n\n\nEmber Guides - Source for http://guides.emberjs.com which you are currently reading.\n\n\nhttps://github.com/emberjs/guides\n\nLibraries Used By Ember\nThese libraries are part of the Ember.js source, but development of them takes place in a separate repository.\npackages/ember-metal/lib/vendor/backburner.js\n\nbackburner.js - Implements the Ember run loop.\nhttps://github.com/ebryn/backburner.js\n\npackages/ember-routing/lib/vendor/route-recognizer.js\n\nroute-recognizer.js - A lightweight JavaScript library that matches paths against registered routes.\nhttps://github.com/tildeio/route-recognizer\n\npackages/ember-routing/lib/vendor/router.js\n\nrouter.js - A lightweight JavaScript library that builds on route-recognizer and rsvp to provide an API for handling routes.\nhttps://github.com/tildeio/router.js\n\npackages/metamorph\n\nMetamorph.js - Used by Ember for databinding handlebars templates\nhttps://github.com/tomhuda/metamorph.js\n\npackages/rsvp\n\nRSVP.js - Implementation of the of Promises/A+ spec used by Ember.\nhttps://github.com/tildeio/rsvp.js\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c34d88bfea40594c8c5d1478666d47a7","fields":[{"name":"title","value":"Managing Dependencies Between Controllers","type":"string"},{"name":"url","value":"/controllers/dependencies-between-controllers/","type":"enum"},{"name":"body","value":"Sometimes, especially when nesting resources, we find ourselves needing\nto have some kind of connection between two controllers. Let's take this\nrouter as an example:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var Router = Ember.Router.extend({});\n\nRouter.map(function() {\n  this.route(\"post\", { path: \"/posts/:post_id\" }, function() {\n    this.route(\"comments\", { path: \"/comments\" });\n  });\n});\n\nexport default Router;\n\n\n\nIf we visit a /posts/1/comments URL, our Post model will get\nloaded into a PostController's model, which means it is not directly\naccessible in the CommentsController. We might however want to display\nsome information about it in the comments template.\n\nTo be able to do this we inject the PostController into the\nCommentsController (which has the desired Post model).\n\n  \n    \n      app/controllers/comments.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Controller.extend({\n  postController: Ember.inject.controller('post')\n});\n\n\n\nOnce comments has access to the PostController, a read-only alias can be\nused to read the model from that controller. In order to get the\nPost model, we refer to postController.model:\n\n  \n    \n      app/controllers/comments.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  postController: Ember.inject.controller('post'),\n  post: Ember.computed.reads('postController.model')\n});\n\n\n\n  \n    \n      app/templates/comments.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003ch1\u003eComments for {{post.title}}\u003c/h1\u003e\n\n\u003cul\u003e\n  {{#each model as |comment|}}\n    \u003cli\u003e{{comment.text}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nFor more information about dependency injection in Ember.js,\nsee the dependency injection guide.\nFor more information about aliases, see the API docs for\naliased properties.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f72002399f11df302a9dac49684ae8dc","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/controllers/","type":"enum"},{"name":"body","value":"Controllers\nIn Ember.js, controllers allow you to decorate your models with\ndisplay logic. In general, your models will have properties that\nare saved to the server, while controllers will have properties\nthat your app does not need to save to the server.\n\nFor example, if you were building a blog, you would have a\nBlogPost model that you would present in a blog_post template.\n\nYour BlogPost model would have properties like:\n\n\ntitle\nintro\nbody\nauthor\n\n\nYour template would bind to these properties in the blog-post \ntemplate:\n\n  \n    \n      app/templates/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  \u003ch1\u003e{{model.title}}\u003c/h1\u003e\n\u003ch2\u003eby {{model.author}}\u003c/h2\u003e\n\n\u003cdiv class='intro'\u003e\n  {{model.intro}}\n\u003c/div\u003e\n\u003chr\u003e\n\u003cdiv class='body'\u003e\n  {{model.body}}\n\u003c/div\u003e\n\n\n\nIn this simple example, we don't have any display-specific properties\nor actions just yet. For now, our controller's model property just acts as a\npass-through (or \"proxy\") for the model properties. (Remember that\na controller gets the model it represents from its route handler.)\n\nLet's say we wanted to add a feature that would allow the user to\ntoggle the display of the body section. To implement this, we would\nfirst modify our template to show the body only if the value of a\nnew isExpanded property is true.\n\n  \n    \n      app/templates/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  \u003ch1\u003e{{model.title}}\u003c/h1\u003e\n\u003ch2\u003eby {{model.author}}\u003c/h2\u003e\n\n\u003cdiv class='intro'\u003e\n  {{model.intro}}\n\u003c/div\u003e\n\u003chr\u003e\n\n{{#if isExpanded}}\n  \u003cbutton {{action 'toggleProperty' 'isExpanded'}}\u003eHide Body\u003c/button\u003e\n  \u003cdiv class='body'\u003e\n    {{model.body}}\n  \u003c/div\u003e\n{{else}}\n  \u003cbutton {{action 'toggleProperty' 'isExpanded'}}\u003eShow Body\u003c/button\u003e\n{{/if}}\n\n\n\nYou might think you should put this property on the model, but\nwhether the  body is expanded or not is strictly a display concern.\n\nPutting this property on the controller cleanly separates logic\nrelated to your data model from logic related to what you display\non the screen. This makes it easy to unit-test your model without\nhaving to worry about logic related to your display creeping into\nyour test setup.\nA Note on Coupling\nIn Ember.js, templates get their properties from controllers, which\ndecorate a model.\n\nThis means that templates know about controllers and controllers\nknow about models, but the reverse is not true. A model knows\nnothing about which (if any) controllers are decorating it, and a\ncontroller does not know which templates are presenting its properties.\n\n\n\n\n\nThis also means that as far as a template is concerned, all of its\nproperties come from its controller, and it doesn't need to know\nabout the model directly.\n\nIn practice, Ember.js will create a template's controller once for\nthe entire application, but the controller's model may change\nthroughout the lifetime of the application without requiring that\nthe template know anything about those mechanics.\n\nFor example, if the user navigates from /posts/1 to /posts/2, the\nPostController's model will change from store.findRecord('post', 1) to\nstore.findRecord('post', 2). The template will update its representations of\nany properties on the model, as well as any computed properties on the\ncontroller that depend on the model.\n\nThis makes it easy to test a template in isolation by rendering it\nwith a controller object that contains the properties the template\nexpects. From the template's perspective, a controller is simply\nan object that provides its data.\nRepresenting Models\nTemplates are always provided context by a controller or component,\nnever a model. This\nmakes it easy to separate display-specific properties from model\nspecific properties, and to swap out a controller's model as the\nuser navigates around the page.\nStoring Application Properties\nNot all properties in your application need to be saved to the\nserver. Any time you need to store information only for the lifetime\nof this application run, you can store it on a controller.\n\nFor example, imagine your application has a search field that\nis always present. You could store a search property on your\nApplicationController, and bind the search field in the \napplication template to that property, like this:\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cheader\u003e\n  {{input type=\"text\" value=search action=\"query\"}}\n\u003c/header\u003e\n\n{{outlet}}\n\n\n\n  \n    \n      app/controllers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Controller.extend({\n  // the initial value of the `search` property\n  search: '',\n\n  actions: {\n    query() {\n      // the current value of the text field\n      var query = this.get('search');\n      this.transitionToRoute('search', { query });\n    }\n  }\n});\n\n\n\nThe application template stores its properties and sends its\nactions to the ApplicationController. In this case, when the user\nhits enter, the application will transition to the search route,\npassing the query as a parameter.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8f27b0f8776a553f80db00813b176d9a","fields":[{"name":"title","value":"Representing Multiple Models","type":"string"},{"name":"url","value":"/controllers/representing-multiple-models/","type":"enum"},{"name":"body","value":"The model of a controller can represent several records as well as a single\none. Here, our route's model hook returns an array of songs:\n\n  \n    \n      app/routes/songs.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.findAll('song');\n  }\n});\n\n\n\nIn the songs template, we can use the {{#each}} helper to display\neach song:\n\n  \n    \n      app/templates/songs.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003ch1\u003ePlaylist\u003c/h1\u003e\n\n\u003cul\u003e\n  {{#each model as |song|}}\n    \u003cli\u003e{{song.name}} by {{song.artist}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nYou can use the controller to collect aggregate information about\nthe model it hosts. For example, imagine we want to display the\nnumber of songs that are over 30 seconds long. We can add a new computed\nproperty called longSongCount to the controller:\n\n  \n    \n      app/controllers/songs.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Controller.extend({\n  longSongCount: Ember.computed('model.@each.duration', function() {\n    let songs = this.get('model');\n    let longSongs = songs.filter((song) =\u003e {\n      return song.get('duration') \u003e 30;\n    });\n    return longSongs.get('length');\n  })\n});\n\n\n\nNow we can use this property in our template:\n\n  \n    \n      app/templates/songs.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003cul\u003e\n  {{#each model as |song|}}\n    \u003cli\u003e{{song.name}} by {{song.artist}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n{{longSongCount}} songs over 30 seconds.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a54077923b8a93308baa1922a604275","fields":[{"name":"title","value":"Inspecting the Container","type":"string"},{"name":"url","value":"/ember-inspector/container/","type":"enum"},{"name":"body","value":"Ember.js implements dependency injection by using a container.  Every Ember\napplication has a container that creates instances for you. You can\ninspect these instances using the inspector's container tab.\n\n\n\nYou will see a list of object types the container has cached. Click on\none type to see the list of all instances created by the container.\n\nIn our case, we are looking at the instantiated controllers.\nInspecting Instances\nClick on one row to inspect an instance using the object inspector.\n\n\n\nTo send an instance to the console, click to open the\nobject inspector, and then click on $E at the top right of the object inspector.\nFilter and Reload\nYou can reload the container tab by clicking on the reload icon.\n\nTo search for instances, type a query in the search box.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e43dd675078ff4ac486b57fa13d5c944","fields":[{"name":"title","value":"Data Tab","type":"string"},{"name":"url","value":"/ember-inspector/data/","type":"enum"},{"name":"body","value":"If you are using a data library that supports the Ember Inspector such\nas Ember Data, you can inspect your models by clicking on the Data menu.\n\nWhen you open the Data tab, you will see a list of model types defined\nin your application. Each model type has the number loaded records next\nto it. You can click on one type to view all of its loaded records.\n\n\nInspecting Records\nEach row in the list represents a record, with the first four attributes\nas columns (just enough attributes to identify the record). To view all\nof the attributes and more properties, click on the record and it will\nopen in the object inspector.\n\n\nRecord States and Filtering\nThe data tab is a real time representation of your application's store.\nAny changes such as added records, modifications, or deleted records will\nimmediately be reflected in the data tab. Record attributes are also\nbound.\n\nNew unsaved records are green.\n\n\n\nModified unsaved records are blue.\n\n\n\nYou can filter records based on state by clicking on one of the pills\nbelow:\n\n\n\nYou can also filter records by entering a query in the search box.\nBuilding a Data Custom Adapter\nIf you have built your own data persistence library (as opposed to using Ember Data\nfor example), you can build a data adapter so you can inspect your models\nusing the data tab.\n\nYou can see the documentation for the data adapter\nhere.\n\nYou can also use Ember Data's data adapter as an example.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f1bedd99c57f624399a149361ed1ea21","fields":[{"name":"title","value":"Tackling Deprecations","type":"string"},{"name":"url","value":"/ember-inspector/deprecations/","type":"enum"},{"name":"body","value":"As part of making your app upgrades as smooth as possible, the\nEmber Inspector gathers deprecations, groups them, and displays them in a\nway that helps in tackling them.\n\nTo view the list of deprecations, click on the Deprecations menu.\n\n\n\nYou can see the total number of deprecations next to the Deprecations menu.\nYou can also see the number of occurrences for each deprecation.\nEmber Cli Deprecation Sources\nIf you are using Ember Cli and have source maps enabled, you can see a\nlist of sources for each deprecation. In Chrome and Firefox devtools,\nclicking on that source file will open the sources panel and take you to\nthe code that caused the deprecation message.\n\n\n\n\n\nYou can send the entire stack trace of the deprecation message to the\nconsole by clicking on Trace in the console.\nTransition Plans\nFor information on how to remove the deprecation warning,\nclick on the \"Transition Plan\" link to go to a helpful guide on how to\nupgrade on the Ember.js website.\n\n\nFiltering and Clearing\nYou can filter the deprecations by typing a query in the search box.\nYou can also clear the current deprecations by clicking on the clear icon\nat the top.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4d3cec3ae6d2506e5e756dc6182d88bb","fields":[{"name":"title","value":"Library Info","type":"string"},{"name":"url","value":"/ember-inspector/info/","type":"enum"},{"name":"body","value":"To see a list of libraries you are using along with their versions,\nclick on the Info menu.\n\n\nRegistering a Library\nIf you would like to add your own application to the list, or\nare a library author yourself, you can register it using:\n\n  1\n\n  Ember.libraries.register(libraryName, libraryVersion);\n\n\nEmber Cli\nEmber CLI automatically adds your application's name and version to the list\nthanks to the ember-cli-app-version addon.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6ffdaf430e1066949e727f7e18a926c0","fields":[{"name":"title","value":"Installing the Inspector","type":"string"},{"name":"url","value":"/ember-inspector/installation/","type":"enum"},{"name":"body","value":"The Ember Inspector extends browsers' developer tools to make understanding and debugging your Ember.js applications easier.\n\nSteps to install the inspector for Google Chrome, Firefox, other\nbrowsers (Bookmarklet), and apps running on mobile devices are explained\nbelow.\nGoogle Chrome\nYou can install the Ember Inspector on Google Chrome as a new developer\ntool panel.\n\nVisit the extension page on the Chrome Web Store.\n\nClick on \"Add To Chrome\":\n\n\n\nOnce installed, go to an Ember.js application, open the developer tools,\nand click on the Ember tab next to the rest of the devtools panels.\n\n\nFile:// protocol\nIf you need to use the inspector with the file:// protocol.\n\nVisit the URL: chrome://extensions and check the \"Allow access to file URLs\" checkbox:\n\n\nEnable Tomster\nYou can configure a tomster icon to show up in Chrome's url bar whenever you are visiting a site that uses Ember.js.\n\nVisit chrome://extensions.\n\nClick on Options.\n\n\n\nMake sure the \"Display the Tomster\" checkbox is checked.\n\n\nFirefox\nVisit the addon page on the Mozilla Addons\nsite.\n\nClick on \"Add to Firefox\".\n\n\n\nOnce installed, go to an Ember.js application, open the developer tools,\nand click on the Ember tab.\n\n\nEnable Tomster\nTo enable the tomster to show up in the url bar whenever you are\nvisiting a site that uses Ember.js Ember.js visit about:addons.\n\nClick on Extensions -\u003e Preferences.\n\n\n\nMake sure the \"Display the Tomster icon when a site runs Ember.js\" checkbox is checked.\n\n\nBookmarklet\nIf you are using any browser other than Chrome or Firefox, you can use the\nbookmarklet option to use the inspector.\n\nAdd the following bookmark:\n\nBookmark Me\n\nTo open the inspector, just click on the bookmark.\n\nInternet Explorer will open an iframe instead of a popup due to the lack of support for cross-origin messaging.\n\nSafari blocks popups by default, so you'll need to enable popups before\nusing this option.\nMobile Development\nIf you want to run the inspector with apps running on mobile devices,\nyou can use the Ember Cli Remote Inspector addon.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9893b6fad8e586504102380a81fea52b","fields":[{"name":"title","value":"Object Inspector","type":"string"},{"name":"url","value":"/ember-inspector/object-inspector/","type":"enum"},{"name":"body","value":"The inspector comes with its own object inspector that allows you to view and interact with your Ember objects.\nWhile using the inspector, click on any Ember object to open the object inspector and inspect its\nproperties.\nViewing Objects\nHere's what you see when you click on the posts controller.\n\n\n\nYou will see a list of parent objects and mixins that make up the object. The properties are organized by which parent object or\nmixin they were inherited from.\n\nComputed properties are preceded by a calculator icon. If a computed\nproperty hasn't been computed, you can click on the calculator to\ncompute it.\n\nAll properties are bound to your app, so property updates in your app will be reflected live in the inspector.\nSending Objects from and to the ConsoleObject Inspector to the Console\nYou can send objects and properties to the console by clicking on the $E button.\nThis will set the value to the global $E variable.\n\n\n\nWhen you hover over the object's properties, a $E button will appear\nnext to every property. Click on it to send the property's value to the\nconsole.\n\n\nConsole to the Object Inspector\nYou can send Ember objects and arrays to the object inspector by using\nEmberInspector.inspect.\n\n  1\n2\n\n  var object = Ember.Object.create();\nEmberInspector.inspect(object);\n\n\n\nMake sure the Ember Inspector is active when you call this method.\nEditing Properties\nYou can edit String, Number, and Boolean properties in the inspector.\nChanges will be reflected immediately in your app. Templates bound to\nthese properties will auto-update.\n\nClick on a property's value to start editing.\n\n\n\nDate values will open a date picker while editing.\n\n\n\nEdit the property and press the ENTER key to commit the change, or ESC to cancel.\nNavigating the Object Inspector\nProperties that are themselves Ember objects or arrays can be inspected\ntoo. Click on the property's value to inspect it.\n\n\n\nYou can keep\nnavigating through the inspector as long as properties are either an\nEmber object or an array.\nIn the image below, we clicked on the model property first, then clicked\non the store property.\n\n\n\nYou can see the current path of the inspected object at the top of the\ninspector. You can go back to the previous object by clicking on the\nleft-facing arrow at the top left.\nCustom Property Grouping\nSome objects' properties are not only grouped by inheritance, but also\nby framework level semantics. For example, if you inspect an Ember Data\nmodel, you can see Attributes, Belongs To, Has Many, and Flags\ngroups.\n\n\n\nYou can customize how any object shows up in the object inspector, and\nEmber Data models are just an example. If you are a library author, you\ncan define a _debugInfo method on your objects to customize how the inspector\ndisplays your properties. For an example on how to customize an\nobject's properties, see Ember Data's\ncustomization.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"586a911ed3096cd96da506f68a4f75ac","fields":[{"name":"title","value":"Debugging Promises","type":"string"},{"name":"url","value":"/ember-inspector/promises/","type":"enum"},{"name":"body","value":"The inspector provides a way to look at all the promises being created\nin your application. Click on the Promises menu to start inspecting\nyour promises.\n\n\n\nYou can see a hierarchical list of promises with labels describing each\npromise, its state, settled value, and the time it took to\nsettle.\nPromise States and Filtering\nPromises will have different colors based on their state.\n\n\n\n\n\n\n\nYou can filter promises by state by clicking on one of the following\npills: Rejected, Pending, Fulfilled.\n\n\n\nYou can also search for promises by typing a query in the search box.\n\nTo clear the currently logged promises, click on the clear icon on the\ntop left of the tab.\nInspecting Settled Values\nIf the fulfillment value is an Ember object or an array, you can click\non that object to open it in the object inspector.\n\n\n\nIf the rejection value is an Error object, you can send its stack trace to\nthe console.\n\n\n\nYou can also click on the $E button to send the value to the console.\nTracing\nThe inspector provides a way to view a promise's stack trace.\nTracing promises is disabled by default for performance reasons. To\nenable tracing, check the Trace promise checkbox. You may want to\nreload to trace existing promises.\n\n\n\nTo trace a promise, click on the Trace button next to the label,\nwhich will send the promise stack trace to the console.\n\n\nLabeling Promises\nPromises generated by Ember.js are all labeled by default.\nYou can also label your own RSVP promises to find them in the inspector's Promises tab.\nAll RSVP methods can take a label as the final argument.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  \nvar label = 'Find Posts'\n\nnew RSVP.Promise(method, label);\n\nRSVP.Promise.resolve(value, label);\n\nRSVP.Promise.reject(reason, label);\n\nRSVP.Promise.all(array, label);\n\nRSVP.Promise.hash(hash, label);\n\npromise.then(success, failure, label);\n\npromise.catch(callback, label);\n\npromise.finally(callback, label);\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ed658525bc79f3040009b9bb48c2b542","fields":[{"name":"title","value":"Rendering Performance","type":"string"},{"name":"url","value":"/ember-inspector/render-performance/","type":"enum"},{"name":"body","value":"You can use the inspector to measure the time it takes for your views to\nbe created. Click on Render Performance to start inspecting render times.\n\n\nAccuracy\nThe inspector itself adds a delay to your rendering, so the render durations you see\nare not an accurate representation of your production apps. Use these\nnumbers to compare durations and debug rendering bottlenecks, but not as\na way to accurately measure rendering times.\nToolbar\nClick on the \"clear\" icon to remove existing render logs.\n\nTo measure views that are rendered on initial application boot, you will\nneed to click on the \"Reload\" button at the top. This button ensures\nthat the inspector starts measuring render times immediately when your app boots.\n\nTo filter the render logs, type a query in the search box.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"055448419ab0ef77beac250a0a5d84ee","fields":[{"name":"title","value":"Inspecting Routes","type":"string"},{"name":"url","value":"/ember-inspector/routes/","type":"enum"},{"name":"body","value":"The inspector's Routes tab displays a list of all your application's\nroutes. To view your routes, click on the \"Routes\" menu.\n\nFor the following code:\n\n  1\n2\n3\n\n  this.route('posts', function() {\n  this.route('new');\n});\n\n\n\nThe Route Tree will display these routes:\n\n\n\nAs you can see, it shows you the routes you defined, and the routes that\nare automatically generated for you by Ember.js.\n\nWe can use this list to figure out what Ember.js expects us to name\nour objects. For example, if we want to create a controller for the\nposts.new route, the Routes tab tells us that the controller\nshould be called posts/new. If we want a to add a loading route for the\nposts resource, we can see that the route should be posts/loading.\n\nIt is also easy to see the generated URL for a specific route. In our\nexample, posts/index will have the url /posts.\n\nAs for objects that you have defined, you can click on them to send them to\nthe object inspector, or click on the $E button next to them to send them to the console.\nViewing the Current Route\nThe current route is highlighted in bold. However, as your routes grow in\nnumber, it can be quite crowded, and harder to find the current route just by looking at the\nfont weight. A better way is to click on the Current Route Only\ncheckbox to hide all routes except the currently active ones.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b95f5ae41d7e6c6611080f203e11268c","fields":[{"name":"title","value":"Troubleshooting","type":"string"},{"name":"url","value":"/ember-inspector/troubleshooting/","type":"enum"},{"name":"body","value":"Below are some common issues you may encounter, along with the necessary\nsteps to solve them. If your issue is not listed below, please submit an\nissue to the inspector's Github repo.\nEmber Application Not Detected\nIf the inspector cannot detect an Ember application, you will see\nthe following message:\n\n\n\nSome of the reasons this happens:\n\n\nThis is not an Ember application\nYou are using an old Ember version ( \u003c 1.0 ).\nYou are using a protocol other than http or https. For file:// protocol,\nfollow these steps.\nThe Ember application is inside a sandboxed iframe with no url (if you\nare using Jsbin, follow these steps.\n\nUsing the Inspector with Jsbin\nDue to the way Jsbin uses iframes, the inspector doesn't work with edit\nmode.\n\nTo use the inspector, switch to the \"live preview\" mode by clicking on the\narrow circled below.\n\n\nApplication is not Detected Without Reload\nIf you always have to reload the application after you open the\ninspector, that may mean your application's\nbooted state is corrupted. This happens if you are calling\nadvanceReadiness or deferReadiness after the application has\nalready booted.\nData Adapter Not Detected\nWhen you click on the Data tab, and see this message:\n\n\n\nIt means that you are either not using a data persistence library\n(such as Ember Data), or the library you're using does not support the\nEmber Inspector.\n\nIf you are the library's author, see this section on how to add Ember Inspector support.\nPromises Not Detected\nYou click on the Promises tab, and see this message:\n\n\n\nThis happens if you are using a version of Ember \u003c 1.3.\nMissing Promises\nIf the Promises tab is working, but there are promises you can't find,\nit's probably because these Promises were created before the\ninspector is activated.\n\nTo start detecting promises the moment the app boots, click on the Reload button below:\n\n\nInspector Version Old on Firefox\nFirefox addons need to go through a review process before every update.\nThis causes the Firefox Ember Inspector to usually be one version\nbehind.\n\nUnfortunately we don't have control over this process, so if you need\nthe latest inspector version, you will have to download and install the inspector\nmanually from Github.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a9ffd50c1c93761a22ac9b6feb6362a5","fields":[{"name":"title","value":"The View Tree","type":"string"},{"name":"url","value":"/ember-inspector/view-tree/","type":"enum"},{"name":"body","value":"You can inspect the current views and components rendered in your\napplication. The View Tree shows you a tree of what is currently rendered,\nalong with templates, controllers, and models backing each view.\n\nClick on the View Tree menu on the left to see your views.\n\n\nInspecting Objects\nYou can click on any model, controller, view, or component\nto send them to the object inspector.\n\n\n\nYou can also click on the $E button next to them to send them to the console and\nassign them to the global $E variable.\nInspecting Templates\nIf you are using Chrome or Firefox and click on a template that has a DOM element,\nyou will be sent to the Elements panel with that DOM element selected.\n\n\n\n\nComponents and Inline Views\nThe View Tree ignores components and inline views by default. To\nsee them, check the Components and All Views checkboxes.\n\n\nHighlighting TemplatesHovering over the view tree\nWhen you hover over the views in the list, the templates will be\nhighlighted in your app. For every highlighted view, you can see the\ntemplate name, controller, view, and model.\n\n\nHovering over the app\nIf you want to highlight a template directly from your app, you can\nclick on the magnifying glass and hover your mouse over your app. Any\ntime your mouse passes over a template, that template will be\nhighlighted and will show its name and its model, controller, and view names.\n\nIf you want components to be highlighted, you will need to check the\nComponents checkbox first.\n\n\n\nIf you click on a highlighted template, you will select it and can then\nclick on the controller, view, component, or model to send them to the\nobject inspector.\n\n\n\nClick on the X button to unselect a template.\nRender Duration\nDuration displays the time it took for a specific DOM element to be\ncreated along with all its children.\n\n\n\nInstrumentation however adds its own delay to rendering, so the\nnumbers you see are not an exact representation of production apps.\nThese numbers should be used to compare rendering times, and not as a\nreplacement for performance benchmarking.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2921955846de516e46f41f11de521501","fields":[{"name":"title","value":"Core Concepts","type":"string"},{"name":"url","value":"/getting-started/core-concepts/","type":"enum"},{"name":"body","value":"To get started with Ember.js, there are a few core concepts you\nshould understand.\n\nEmber.js is designed to help developers build ambitiously large web\napplications that are competitive with native apps. Doing so requires\nboth new tools and a new vocabulary of concepts. We've spent a lot of\ntime borrowing ideas pioneered by native application frameworks like\nCocoa and Smalltalk.\n\nHowever, it's important to remember what makes the web special. Many\npeople think that something is a web application because it uses\ntechnologies like HTML, CSS and JavaScript. In reality, these are just\nimplementation details.\n\nInstead, the web derives its power from the ability to bookmark and\nshare URLs. URLs are the key feature that give web applications\nsuperior shareability and collaboration. Today, most JavaScript\nframeworks treat the URL as an afterthought, instead of the primary\nreason for the web's success.\n\nEmber.js, therefore, marries the tools and concepts of native\nGUI frameworks with support for the feature that makes the web so\npowerful: the URL.\nConceptsTemplates\nA template, written in the Handlebars templating language, describes\nthe user interface of your application. Each template is backed by a\nmodel, and the template automatically updates itself if the model changes.\n\nIn addition to plain HTML, templates can contain:\n\n\nExpressions, like {{firstName}}, which take information from\nthe template's model and put it into HTML.\nOutlets, which are placeholders for other templates. As users\nmove around your app, different templates can be plugged into the\noutlet by the router. You can put outlets into your template using the\n{{outlet}} helper.\nComponents, custom HTML elements that you can use to clean up\nrepetitive templates or create reusable controls.\n\nRouter\nThe router translates a URL into a series of nested templates, each\nbacked by a model. As the templates or models being shown to the user\nchange, Ember automatically keeps the URL in the browser's address bar\nup-to-date.\n\nThis means that, at any point, users are able to share the URL of your\napp. When someone clicks the link, they reliably see the same content as\nthe original user.\nComponents\nA component is a custom HTML tag whose behavior you implement using\nJavaScript and whose appearance you describe using Handlebars templates.\nThey allow you to create reusable controls that can simplify your\napplication's templates.\nModels\nA model is an object that stores persistent state. Templates are\nresponsible for displaying the model to the user by turning it into\nHTML. In many applications, models are loaded via an HTTP JSON API,\nalthough Ember is agnostic to the backend that you choose.\nRoutes\nA route is an object that tells the template which model it should\ndisplay.\n\nThese are the core concepts you'll need to understand as you develop\nyour Ember.js app. They are designed to scale up in complexity, so that\nadding new functionality doesn't force you to go back and refactor major\nparts of your app.\n\nNow that you understand the roles of these objects, you're equipped to\ndive deep into Ember.js and learn the details of how each of these\nindividual pieces work.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"59427847e14331e01de43a097e3ee4cb","fields":[{"name":"title","value":"Installing Ember","type":"string"},{"name":"url","value":"/getting-started/","type":"enum"},{"name":"body","value":"Getting started with Ember.js is easy. Ember.js projects are created and managed\nthrough our command line build tool ember-cli. The command line tool brings:\n\n\nModern application asset management (including combining, minifying, and versioning).\nBuilt-in generators to help you create components, routes, and more.\nA conventional project layout so approaching other developers' Ember.js applications is easy.\nOfficial JavaScript modules to keep your project organized.\nA complete testing framework.\nAccess to a growing ecosystem of Ember Addons.\n\nDependenciesNode.js and npm\nEmber CLI is installed using npm (the Node Package Manager), which is bundled\nwith Node.js. Ember requires Node.js 0.12 or higher and npm 2.7 or higher.\nIf you're not sure whether you have Node.js, try running from your\ncommand line:\n\n  1\n\n  node --version\n\n\n\nIf you get back something like 0.12.x, you're ready to go.\n\nIf you don't:\n\n\nWindows or Mac users can simply download and run the installer.\nMac users often prefer to install Node using Homebrew. After\ninstalling Homebrew, run brew install node to install Node.js.\nLinux users can check out this great guide by Joyent for install instructions.\n\n\nOnce you've got Node.js installed, re-run node --version to verify your install.\nGit\nEmber requires Git to manage many of its dependencies.\nGit comes with Mac OS X and most Linux distributions.\nWindows users can download and run the installer.\nWatchman (optional)\nOn Mac and Linux, you can improve file watching performance by installing Watchman.\nInstallation\nInstall Ember using npm:\n\n  1\n\n  npm install -g ember-cli\n\n\n\nWhile you're at it we recommend you also install PhantomJS to run tests from\nthe command line (without the need for a browser to be open):\n\n  1\n\n  npm install -g phantomjs\n\n\n\nTo verify that your installation was successful, run:\n\n  1\n\n  ember -v\n\n\n\nIf you get back something like version: 1.13.0, you're ready to go.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3a674beb318c77c3e394748b093cd641","fields":[{"name":"title","value":"Naming Conventions","type":"string"},{"name":"url","value":"/getting-started/naming-conventions/","type":"enum"},{"name":"body","value":"Ember.js uses a runtime resolver to wire up your objects without a\nlot of boilerplate. As a developer, this resolver will work automatically\nif you place code in conventional locations within your project.\n\nYou can usually guess the names and locations, but this guide outlines, in one place,\nall of the naming conventions.\nThe Application\nWhen your application boots,\nEmber.js will render the application template as the main template.\nIf controller:application is provided, Ember.js will set an\ninstance of controller:application as the controller for the\ntemplate. This means that the template will get its properties from\nthe controller.\n\nIf your app provides a route at app/routes/application.js Ember.js will invoke\nthe router's hooks first, before rendering the\napplication template. Hooks are implemented as methods and provide\nyou access points within an Ember object's lifecycle to intercept and\nexecute code to modify the default behavior at these points to meet\nyour needs. Ember provides several hooks for you to utilize for various\npurposes (e.g. model, setupController, etc). In the example below\nroute:application Route, which is an Ember.Route object, implements\nthe setupController hook.\n\nHere's a simple example that uses a route, controller, and template:\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return { title: \"Hello World\" };\n  }\n});\n\n\n\n  \n    \n      app/controllers/application.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Controller.extend({\n  appName: 'My First Example'\n});\n\n\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003e{{appName}}\u003c/h1\u003e\n\u003ch2\u003e{{model.title}}\u003c/h2\u003e\n\n\n\nIn Ember.js applications, you will always provide your objects\nas classes, and the framework is responsible for instantiating\nthem and providing them to your templates at runtime through the resolver.\nSimple Routes\nEach of your routes will have a controller and a template with the\nsame name as the route.\n\nLet's start with a simple router:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  var Router = Ember.Router.extend();\n\nRouter.map(function(){\n  this.route('favorites');\n});\n\nexport default Router;\n\n\n\nIf your user navigates to /favorites, Ember.js will look for these\nclasses in your project:\n\n\napp/routes/favorites.js\napp/controllers/favorites.js\napp/templates/favorites.hbs\n\n\nEmber.js will render the favorites template into the {{outlet}}\nin the application template. It will set an instance of the\ncontroller:favorites as the controller for the template.\n\nIf your app provides a route:favorites, the framework will\ninvoke it before rendering the template. Yes, this is a bit\nrepetitive.\n\nFor a route like route:favorites, you will probably implement\nthe model hook to specify what model your controller will present\nto the template.\n\nHere's an example:\n\n  \n    \n      app/routes/favorites.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  import ajax from 'ic-ajax';\n\nexport default Ember.Route.extend({\n  model() {\n    // the model is an Array of all of the posts\n    // fetched from this url\n    return ajax('/a/service/url/where/posts/live');\n  }\n});\n\n\n\nIn this example, we didn't provide a controller:favorites. Because\nthe model is an Array, Ember.js will automatically supply an instance\nof Ember.ArrayController, which will present the backing Array as\nits model.\n\nYou can treat the Ember.ArrayController as if it was the model itself.\nThe benefit of this is that you can replace the controller's model at\nany time without having to directly notify templates and components of\nthe change.\n\nThe template can iterate over the elements of the controller:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n{{#each controller as |item|}}\n  \u003cli\u003e{{item.title}}\u003c/li\u003e\n{{/each}}\n\u003c/ul\u003e\n\n\nDynamic Segments\nIf a route uses a dynamic segment (a URL that includes a parameter), the route's model will be based\non the value of that segment provided by the user.\n\nConsider this router definition:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  var Router = Ember.Router.extend();\n\nRouter.map(function(){\n  this.route('post', { path: '/posts/:post_id' });\n});\n\nexport default Router\n\n\n\nIn this case, the route's name is post, so Ember.js will look for\nthese objects:\n\n\napp/routes/post.js\napp/controllers/post.js\napp/templates/post.hbs\n\n\nYour route handler's model hook converts the dynamic :post_id\nparameter into a model. The serialize hook converts a model object\nback into the URL parameters for this route (for example, when\ngenerating a link for a model object).\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import ajax from 'ic-ajax';\n\nexport default Ember.Route.extend({\n  model(params) {\n    return ajax('/my-service/posts/' + params.post_id);\n  },\n\n  serialize(post) {\n    return { post_id: Ember.get(post, 'id') };\n  }\n});\n\n\n\nBecause this pattern is so common, it is the default for route\nhandlers.\n\n\nIf your dynamic segment ends in _id, the default model\nhook will convert the first part into a model class on the\napplication's namespace (post looks for app/models/post.js). It will\nthen call find on that class with the value of the dynamic\nsegment.\nThe default behaviour of the serialize hook is to replace\nthe route's dynamic segment with the value of the model\nobject's id property.\n\nRoute, Controller and Template Defaults\nIf you don't specify a route handler for the post route\n(app/routes/post.js), Ember.js  will still render the app/templates/post.hbs\ntemplate with the app's instance of app/controllers/post.js.\n\nIf you don't specify the controller (app/controllers/post.js),\nEmber will automatically make one for you based on the return value\nof the route's model hook. If the model is an Array, you get an\nArrayController. Otherwise, you get an ObjectController. As of 1.11,\nObjectControllers are deprecated and if you try to use its proxy feature you\nwill get a warning. Please, take a look at the deprecations guide for more\ndetailed information.\n\nIf you don't specify a post template, Ember.js won't render\nanything!\nNesting\nYou can nest routes:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var Router = Ember.Router.extend();\n\nRouter.map(function(){\n  this.route('posts', function() {    // the `posts` route\n    this.route('favorites');          // the `posts.favorites` route\n    this.route('post');               // the `posts.post` route\n  });\n});\n\nexport default Router\n\n\n\nHere are the naming conventions for each of the routes defined in\nthis router:\n\n\n    \n      \n          Route Name\n          Convention\n      \n    \n    \n        posts\n        \n            \napp\n ├── controllers/\n │   └── posts.js  \n ├── routes/\n │   └── posts.js  \n └── templates/\n     └── posts.hbs\n            \n        \n    \n    \n        posts.favorites\n        \n            \napp\n ├── controllers/\n │   └── posts/  \n │       └── favorites.js  \n ├── routes/\n │   └── posts/\n │       └── favorites.js  \n └── templates/\n     └── posts/\n         └── favorites.hbs\n          \n        \n    \n    \n        posts.post\n        \n            \napp\n ├── controllers/\n │   └── posts/  \n │       └── post.js  \n ├── routes/\n │   └── posts/\n │       └── post.js  \n └── templates/\n     └── posts/\n         └── post.hbs\n            \n        \n    \n\nThe Index Route\nAt every level of nesting (including the top level), Ember.js\nautomatically provides a route for the / path named index.\n\nFor example, if you write a simple router like this:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  var Router = Ember.Router.extend();\n\nRouter.map(function(){\n  this.route('favorites');\n});\n\nexport default Router;\n\n\n\nIt is the equivalent of:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  var Router = Ember.Router.extend();\n\nRouter.map(function(){\n  this.route('index', { path: '/' });\n  this.route('favorites');\n});\n\nexport default Router;\n\n\n\nIf the user visits /, Ember.js will look for these objects:\n\n\napp/routes/index.js\napp/controllers/index.js\napp/templates/index.hbs\n\n\nThe index template will be rendered into the {{outlet}} in the\napplication template. If the user navigates to /favorites,\nEmber.js will replace the index template with the favorites\ntemplate.\n\nA nested router like this:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var Router = Ember.Router.extend();\n\nRouter.map(function(){\n  this.route('posts', function() {\n    this.route('favorites');\n  });\n});\n\nexport default Router;\n\n\n\nIs the equivalent of:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  var Router = Ember.Router.extend();\n\nRouter.map(function(){\n  this.route('index', { path: '/' });\n  this.route('posts', function() {\n    this.route('index', { path: '/' });\n    this.route('favorites');\n  });\n});\n\nexport default Router;\n\n\n\nIf the user navigates to /posts, the current route will be\nposts.index. Ember.js will look for objects named:\n\n\napp/routes/posts/index.js\napp/controllers/posts/index.js\napp/templates/posts/index.hbs\n\n\nFirst, the posts template will be rendered into the {{outlet}}\nin the application template. Then, the posts/index template\nwill be rendered into the {{outlet}} in the posts template.\n\nIf the user then navigates to /posts/favorites, Ember.js will\nreplace the {{outlet}} in the posts template with the\nposts/favorites template.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6666cd76f96956469e7be39d750cc7d9","fields":[{"name":"title","value":"Ember.js Guides","type":"string"},{"name":"url","value":"/","type":"enum"},{"name":"body","value":"Welcome to the Ember.js guides! This documentation will take you from\ntotal beginner to Ember expert. It is designed to start from the basics,\nand slowly increase to more sophisticated concepts until you know\neverything there is to know about building awesome web applications.\n\nThese guides are written in Markdown and are\navailable on GitHub.\nIf there is something missing, or you find a typo or\nmistake, please help us by filing an issue or submitting a pull\nrequest. Thanks!\n\nWe're excited for all of the great apps you're going to build with\nEmber.js. To get started, select a topic from the left. They are\npresented in the order that we think will be most useful to you as\nyou're learning Ember.js, but you can also jump to whatever seems\nmost interesting.\n\nGood luck!\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"298653c42879aa9157122be8d7fcad36","fields":[{"name":"title","value":"Connecting to an HTTP Server","type":"string"},{"name":"url","value":"/models/connecting-to-an-http-server/","type":"enum"},{"name":"body","value":"If your Ember application needs to load JSON data from an HTTP\nserver, this guide will walk you through the process of configuring\nEmber Data to load records in whatever format your server returns.\n\nThe store uses an object called an adapter to know how to\ncommunicate over the network. By default, the store will use\nDS.RESTAdapter, an adapter that communicates with an HTTP server by\ntransmitting JSON via XHR.\n\nThis guide is divided into two sections. The first section covers what\nthe default behavior of the adapter is, including what URLs it will\nrequest records from and what format it expects the JSON to be in.\n\nThe second section covers how to override these default settings to\ncustomize things like which URLs data is requested from and how the JSON\ndata is structured.\nURL Conventions\nThe REST adapter uses the name of the model to determine what URL to\nsend JSON to.\n\nFor example, if you ask for a photo record by ID:\n\n  \n    \n      app/routes/photo.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model: function(params) {\n    return this.store.findRecord('photo', params.photo_id);\n  }\n});\n\n\n\nThe REST adapter will automatically send a GET request to /photos/1.\n\nThe actions you can take on a record map onto the following URLs in the\nREST adapter:\n\n\n  \n    ActionHTTP VerbURL\n  \n  \n    FindGET/photos/123\n    Find AllGET/photos\n    UpdatePUT/photos/123\n    CreatePOST/photos\n    DeleteDELETE/photos/123\n  \n\nJSON Conventions\nGiven the following models:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import DS from 'ember-data';\n\nexport default DS.Model.extend({\n  title:    DS.attr(),\n  comments: DS.hasMany('comment'),\n  user:     DS.belongsTo('user')\n});\n\n\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  import DS from 'ember-data';\n\nexport default DS.Model.extend({\n  body: DS.attr()\n});\n\n\n\nEmber Data expects that a GET request to /posts/1 would\nreturn the JSON in the following format:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  {\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Rails is omakase\",\n    \"comments\": [\"1\", \"2\"],\n    \"user\" : \"dhh\"\n  },\n\n  \"comments\": [{\n    \"id\": \"1\",\n    \"body\": \"Rails is unagi\"\n  }, {\n    \"id\": \"2\",\n    \"body\": \"Omakase O_o\"\n  }]\n}\n\n\n\nTo quickly prototype a model and see the expected JSON, try using the Ember Data Model Maker by Andy Crum.\nCustomizing the Adapter\nTo customize the REST adapter, create a app/adapters/application.js file\nand export a subclass of DS.RESTAdapter. You can then override its properties\nand methods to customize how records are retrieved and saved.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  ...\n});\n\n\nCustomizing a Specific Model\nIt's entirely possible that you need to define options for just one model instead of an application-wide customization. In that case, you can create an adapter named after the model you are specifying:\n\n  \n    \n      app/adapters/post.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default DS.RESTAdapter.extend({\n  namespace: 'api/v2',\n  host: 'https://api.example2.com'\n});\n\n\n\n  \n    \n      app/adapters/photo.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default DS.RESTAdapter.extend({\n  namespace: 'api/v1',\n  host: 'https://api.example.com'\n});\n\n\n\nThis allows you to easily connect to multiple API versions simultaneously or interact with different domains on a per model basis.\nCustomizing URLsURL Prefix\nIf your JSON API lives somewhere other than on the host root,\nyou can set a prefix that will be added to all requests.\n\nFor example, if you are using a versioned JSON API, a request for a\nparticular person might go to /api/v1/people/1.\n\nIn that case, set namespace property to api/v1.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  namespace: 'api/v1'\n});\n\n\n\nRequests for a person with ID 1  would now go to /api/v1/people/1.\nURL Host\nIf your JSON API runs on a different domain than the one serving your\nEmber app, you can change the host used to make HTTP requests.\n\nNote that in order for this to work, you will need to be using a browser\nthat supports CORS, and\nyour server will need to be configured to send the correct CORS headers.\n\nTo change the host that requests are sent to, set the host property:\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  host: 'https://api.example.com'\n});\n\n\n\nRequests for a person with ID 1 would now target https://api.example.com/people/1.\nCustom HTTP Headers\nSome APIs require HTTP headers, e.g. to provide an API key. Arbitrary\nheaders can be set as key/value pairs on the RESTAdapter's headers\nproperty and Ember Data will send them along with each ajax request.\n\nFor Example\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default DS.RESTAdapter.extend({\n  headers: {\n    'API_KEY': 'secret key',\n    'ANOTHER_HEADER': 'Some header value'\n  }\n});\n\n\n\nRequests for any resource will include the following HTTP headers.\n\n  1\n2\n\n  ANOTHER_HEADER: Some header value\nAPI_KEY: secret key\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9fca6476286a0f29bd93adca72f72c4d","fields":[{"name":"title","value":"Creating and Deleting Records","type":"string"},{"name":"url","value":"/models/creating-and-deleting-records/","type":"enum"},{"name":"body","value":"You can create records by calling the createRecord method on the store.\n\n  1\n2\n3\n4\n\n  store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\n\n\nThe store object is available in controllers and routes using this.store.\n\nAlthough createRecord is fairly straightforward, the only thing to watch out for\nis that you cannot assign a promise as a relationship, currently.\n\nFor example, if you want to set the author property of a post, this would not work\nif the user with id isn't already loaded into the store:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var store = this.store;\n\nstore.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum',\n  author: store.findRecord('user', 1)\n});\n\n\n\nHowever, you can easily set the relationship after the promise has fulfilled:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var store = this.store;\n\nvar post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nstore.findRecord('user', 1).then(function(user) {\n  post.set('author', user);\n});\n\n\nDeleting Records\nDeleting records is just as straightforward as creating records. Just call deleteRecord()\non any instance of DS.Model. This flags the record as isDeleted and thus removes\nit from all() queries on the store. The deletion can then be persisted using save().\nAlternatively, you can use the destroyRecord method to delete and persist at the same time.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  store.findRecord('post', 1).then(function(post) {\n  post.deleteRecord();\n  post.get('isDeleted'); // =\u003e true\n  post.save(); // =\u003e DELETE to /posts/1\n});\n\n// OR\nstore.findRecord('post', 2).then(function(post) {\n  post.destroyRecord(); // =\u003e DELETE to /posts/2\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c789ddb5644abcf443cde5398de5f989","fields":[{"name":"title","value":"Customizing Adapters","type":"string"},{"name":"url","value":"/models/customizing-adapters/","type":"enum"},{"name":"body","value":"In Ember Data, the logic for communicating with a backend data store\nlives in the Adapter. Ember Data's Adapter has some built-in\nassumptions of how a REST API should look. If\nyour backend conventions differ from these assumptions Ember Data\nmakes it easy to change its functionality by swapping out or extending\nthe default Adapter.\n\nSome reasons for customizing an Adapter include using\nunderscores_case in your urls, using a medium other than REST to\ncommunicate with your backend API or even using a\nlocal backend.\n\nExtending Adapters is a natural process in Ember Data. Ember takes the\nposition that you should extend an adapter to add different\nfunctionality instead of adding a flag. This results in code that is\nmore testable, easier to understand and reduces bloat for people who\nmay want to subclass your adapter.\n\nIf your backend has some consistent rules you can define an\nadapter:application. The adapter:application will get priority over\nthe default Adapter, however it will still be superseded by model\nspecific Adapters.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  // Application specific overrides go here\n});\n\n\n\nIf you have one model that has exceptional rules for communicating\nwith its backend than the others you can create a Model specific\nAdapter by running the command ember generate adapter adapter-name\".\nFor example, running ember generate adapter post will create the\nfollowing file:\n\n  \n    \n      app/adapters/post.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  namespace: 'api/v1'\n});\n\n\n\nBy default Ember Data comes with several builtin adapters. Feel free\nto use these adapters as a starting point for creating your own custom\nadapter.\n\n\nDS.Adapter is the basic adapter\nwith no functionality. It is generally a good starting point if you\nwant to create an adapter that is radically different from the other\nEmber adapters.\nDS.RESTAdapter is the most\ncommonly extended adapter. The RESTAdapter allows your store to\ncommunicate with an HTTP server by transmitting JSON via XHR. Most\nEmber.js apps that consume a JSON API should use the REST adapter.\nDS.ActiveModelAdapter\nis a specialized version of the RESTAdapter that is set up to work\nout of the box with Rails-style REST APIs.\n\nCustomizing the RESTAdapter\nThe DS.RESTAdapter is the\nmost commonly extended adapter that ships with Ember Data. It has a\nhandful of hooks that are commonly used to extend it to work with\nnon-standard backends.\nEndpoint Path Customization\nThe namespace property can be used to prefix requests with a\nspecific url namespace.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  namespace: 'api/1'\n});\n\n\n\nRequests for person would now target http://emberjs.com/api/1/people/1.\nHost Customization\nBy default the adapter will target the current domain. If you would\nlike to specify a new domain you can do so by setting the host\nproperty on the adapter.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  host: 'https://api.example.com'\n});\n\n\n\nRequests for person would now target https://api.example.com/people/1.\nPath Customization\nBy default the RESTAdapter will attempt to pluralize and camelCase\nthe model name to generate the path name. If this convention does not\nconform to your backend you can override the pathForType method.\n\nFor example, if you did not want to pluralize model names and needed\nunderscore_case instead of camelCase you could override the\npathForType method like this:\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.RESTAdapter.extend({\n  pathForType: function(type) {\n    return Ember.String.underscore(type);\n  }\n});\n\n\n\nRequests for person would now target /person/1.\nRequests for userProfile would now target /user_profile/1.\nAuthoring Adapters\nThe defaultSerializer property can be used to specify the serializer\nthat will be used by this adapter. This is only used when a model\nspecific serializer or ApplicationSerializer are not defined.\n\nIn an application, it is often easier to specify an\nApplicationSerializer. However, if you are the author of a community\nadapter it is important to remember to set this property to ensure\nEmber does the right thing in the case a user of your adapter\ndoes not specify an ApplicationSerializer.\n\n  \n    \n      app/adapters/my-custom-adapter.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  defaultSerializer: '-default'\n});\n\n\nCommunity Adapters\nIf none of the builtin Ember Data Adapters work for your backend,\nbe sure to check out some of the community maintained Ember Data\nAdapters. Some good places to look for Ember Data Adapters include:\n\n\nGitHub\nBower\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"03e86bc5333f6f64b9e95b540f952f9d","fields":[{"name":"title","value":"Defining Models","type":"string"},{"name":"url","value":"/models/defining-models/","type":"enum"},{"name":"body","value":"A model is a class that defines the properties and behavior of the\ndata that you present to the user. Anything that the user expects to see\nif they leave your app and come back later (or if they refresh the page)\nshould be represented by a model.\n\nMake sure to include ember-data.js after ember.js\n\n  1\n2\n\n  \u003cscript type=\"text/javascript\" src=\"ember.js\"\u003e\u003c/script\u003e\n\u003cscript type=\"text/javascript\" src=\"ember-data.js\"\u003e\u003c/script\u003e\n\n\n\nFor every model in your application, create a subclass of DS.Model:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n\n  export default DS.Model.extend();\n\n\n\nAfter you have defined a model class, you can start finding and creating\nrecords of that type. When interacting with the store, you will need to\nspecify a record's type using the model name. For example, the store's\nfind() method expects a string as the first argument to tell it what\ntype of record to find:\n\n  1\n\n  store.findRecord('person', 1);\n\n\n\nThe table below shows how model names map to model file paths.\n\n\n  \n  \n    Model Name\n    Model Class\n  \n  \n  \n    photo\n    app/models/photo.js\n  \n  \n    admin-user-profile\n    app/models/admin-user-profile.js\n  \n\nDefining Attributes\nYou can specify which attributes a model has by using DS.attr.\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.Model.extend({\n  firstName: DS.attr(),\n  lastName: DS.attr(),\n  birthday: DS.attr()\n});\n\n\n\nAttributes are used when turning the JSON payload returned from your\nserver into a record, and when serializing a record to save back to the\nserver after it has been modified.\n\nYou can use attributes just like any other property, including as part of a\ncomputed property. Frequently, you will want to define computed\nproperties that combine or transform primitive attributes.\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default DS.Model.extend({\n  firstName: DS.attr(),\n  lastName: DS.attr(),\n\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  })\n});\n\n\n\nFor more about adding computed properties to your classes, see Computed\nProperties.\n\nIf you don't specify the type of the attribute, it will be whatever was\nprovided by the server. You can make sure that an attribute is always\ncoerced into a particular type by passing a type to attr:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  birthday: DS.attr('date')\n});\n\n\n\nThe default adapter supports attribute types of string,\nnumber, boolean, and date. Custom adapters may offer additional\nattribute types, and new types can be registered as transforms. See the\ndocumentation section on the REST Adapter.\n\nPlease note: Ember Data serializes and deserializes dates according to\n                 ISO 8601. For example: 2014-05-27T12:54:01\nOptions\nDS.attr takes an optional hash as a second parameter:\n\n\ndefaultValue: Pass a string or a function to be called to set the\n              attribute to a default value if none is supplied.\n\n\nExample\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n    export default DS.Model.extend({\n      username: DS.attr('string'),\n      email: DS.attr('string'),\n      verified: DS.attr('boolean', {defaultValue: false}),\n      createdAt: DS.attr('string', {\n          defaultValue() { return new Date(); }\n      })\n  });\n\n\nDefining Relationships\nEmber Data includes several built-in relationship types to help you\ndefine how your models relate to each other.\nOne-to-One\nTo declare a one-to-one relationship between two models, use\nDS.belongsTo:\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  profile: DS.belongsTo('profile')\n});\n\n\n\n  \n    \n      app/models/profile.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  user: DS.belongsTo('user')\n});\n\n\nOne-to-Many\nTo declare a one-to-many relationship between two models, use\nDS.belongsTo in combination with DS.hasMany, like this:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  comments: DS.hasMany('comment')\n});\n\n\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  post: DS.belongsTo('post')\n});\n\n\nMany-to-Many\nTo declare a many-to-many relationship between two models, use\nDS.hasMany:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  tags: DS.hasMany('tag')\n});\n\n\n\n  \n    \n      app/models/tag.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  posts: DS.hasMany('post')\n});\n\n\nExplicit Inverses\nEmber Data will do its best to discover which relationships map to one\nanother. In the one-to-many code above, for example, Ember Data can figure out that\nchanging the comments relationship should update the post\nrelationship on the inverse because post is the only relationship to\nthat model.\n\nHowever, sometimes you may have multiple belongsTo/hasManys for the\nsame type. You can specify which property on the related model is the\ninverse using DS.hasMany's inverse option:\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default DS.Model.extend({\n  onePost: DS.belongsTo('post'),\n  twoPost: DS.belongsTo('post'),\n  redPost: DS.belongsTo('post'),\n  bluePost: DS.belongsTo('post')\n});\n\n\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.Model.extend({\n  comments: DS.hasMany('comment', {\n    inverse: 'redPost'\n  })\n});\n\n\n\nYou can also specify an inverse on a belongsTo, which works how you'd expect.\nReflexive relation\nWhen you want to define a reflexive relation, you must either explicitly define\nthe other side, and set the explicit inverse accordingly, and if you don't need the\nother side, set the inverse to null.\n\n  \n    \n      app/models/folder.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default DS.Model.extend({\n  children: DS.hasMany('folder', { inverse: 'parent' }),\n  parent: DS.belongsTo('folder', { inverse: 'children' })\n});\n\n\n\nor\n\n  \n    \n      app/models/folder.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  parent: DS.belongsTo('folder', { inverse: null })\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"54352571d5fd6e786972f119be9dcf80","fields":[{"name":"title","value":"Finding Records","type":"string"},{"name":"url","value":"/models/finding-records/","type":"enum"},{"name":"body","value":"The Ember Data store provides an interface for retrieving records of a single\ntype.\nRetrieving a Single Record\nUse store.findRecord() to retrieve a record by its type and ID. This will\nreturn a promise that fulfills with the requested record:\n\n  1\n\n  var post = this.store.findRecord('post', 1); // =\u003e GET /posts/1\n\n\n\nUse store.peekRecord() to retrieve a record by its type and ID, without making\na network request. This will return the record only if it is already present in\nthe store:\n\n  1\n\n  var post = this.store.peekRecord('post', 1); // =\u003e no network request\n\n\nRetrieving Multiple Records\nUse store.findAll() to retrieve all of the records for a given type:\n\n  1\n\n  var posts = this.store.findAll('post'); // =\u003e GET /posts\n\n\n\nUse store.peekAll() to retrieve all of the records for a given type that are\nalready loaded into the store, without making a network request:\n\n  1\n\n  var posts = this.store.peekAll('post'); // =\u003e no network request\n\n\n\nstore.findAll() returns a DS.PromiseArray that fulfills to a\nDS.RecordArray and store.peekAll directly returns a DS.RecordArray.\n\nIt's important to note that DS.RecordArray is not a JavaScript array.  It is\nan object that implements Ember.Enumerable. This is important because,\nfor example, if you want to retrieve records by index, the [] notation will\nnot work--you'll have to use objectAt(index) instead.\nQuerying for Multiple Records\nEmber Data provides the ability to query for records that meet certain criteria. Calling store.query()\nwill make a GET request with the passed object serialized as query params. This method returns\nDS.PromiseArray in the same way as find.\n\nFor example, we could search for all person models who have the name of\nPeter:\n\n  1\n\n  var peters = this.store.query('person', { name: 'Peter' }); // =\u003e GET to /persons?name=Peter\n\n\nIntegrating with the Route's Model Hook\nAs discussed in Specifying a Route's Model, routes are\nresponsible for telling their template which model to render.\n\nEmber.Route's model hook supports asynchronous values\nout-of-the-box. If you return a promise from the model hook, the\nrouter will wait until the promise has fulfilled to render the\ntemplate.\n\nThis makes it easy to write apps with asynchronous data using Ember\nData. Just return the requested record from the model hook, and let\nEmber deal with figuring out whether a network request is needed or not.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  var Router = Ember.Router.extend({});\n\nRouter.map(function() {\n  this.route('posts');\n  this.route('post', { path: ':post_id' });\n});\n\nexport default Router;\n\n\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.findAll('post');\n  }\n});\n\n\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model(params) {\n    return this.store.findRecord('post', params.post_id);\n  }\n})\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6bd56e65140b54329f607d71ebd61f85","fields":[{"name":"title","value":"Frequently Asked Questions","type":"string"},{"name":"url","value":"/models/frequently-asked-questions/","type":"enum"},{"name":"body","value":"Should I use a query or a filter to search records?\nIt depends on how many records you want to search and whether they have\nbeen loaded into the store.\n\nQueries are useful for doing searches of hundreds, thousands, or even\nmillions of records. You just hand the search options to your server,\nand it is responsible for handing you back the list of records that\nmatch. Because the response from the server includes the ID of all of\nthe records that matched, it doesn't matter if the store hadn't loaded\nthem previously; it sees that they are not in the cache and can request\nthe records by ID if necessary.\n\nThe downside of queries is that they do not live update, they are\nslower, and they require that your server support the kind of queries\nthat you wish to perform.\n\nBecause the server decides which records match the query, not the store,\nqueries do not live update. If you want to update them, you must\nmanually call reload() and wait for the server to respond. If you\ncreate a new record on the client, it will not show up in the results\nuntil you both save the new record to the server and reload the query\nresults.\n\nBecause the store must confer with your server to determine the results\nof a query, it necessitates a network request. This can feel slow to\nusers, especially if they are on a slow connection or your server is\nslow to respond. The typical speed of JavaScript web applications can\nheighten the perceived slowness when the server must be consulted.\n\nLastly, performing queries requires collaboration between the store and\nyour server. By default, Ember Data will send the search options that\nyou pass as the body of an HTTP request to your server. If your server\ndoes not support requests in this format, you will need to either change\nyour server to do so, or customize how queries are sent by creating a\ncustom adapter.\n\nFilters, on the other hand, perform a live search of all of the records\nin the store's cache. As soon as a new record is loaded into the store,\nthe filter will check to see if the record matches, and if so, add it to\nthe array of search results. If that array is displayed in a template,\nit will update automatically.\n\nFilters also take into account newly created records that have not been\nsaved, and records that have been modified but not yet saved. If you\nwant records to show up in search results as soon as they are created or\nmodified on the client, you should use a filter.\n\nKeep in mind that records will not show up in a filter if the store\ndoesn't know about them. You can ensure that a record is in the store by\nusing the store's push() method.\n\nThere is also a limit to how many records you can reasonably keep in\nmemory and search before you start hitting performance issues.\n\nFinally, keep in mind that you can combine queries and filters to take\nadvantage of their respective strengths and weaknesses. Remember that\nrecords returned by a query to the server are cached in the store. You\ncan use this fact to perform a filter, passing it a query that starts\nmatching records into the store, and a filter function that matches the\nsame records.\n\nThis will offload searching all of the possible records to the server,\nwhile still creating a live updating list that includes records created\nand modified on the client.\n\n  \n    \n      app/routes/posts/favourited.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Route.extend({\n  model() {\n    var store = this.store;\n\n    // Create a filter for all favorited posts that will be displayed in\n    // the template. Any favorited posts that are already in the store\n    // will be displayed immediately;\n    // Kick off a query to the server for all posts that\n    // the user has favorited. As results from the query are\n    // returned from the server, they will also begin to appear.\n    return store.filter('post', { favorited: true }, function(post) {\n      return post.get('isFavorited');\n    });\n  }\n});\n\n\nHow do I inform Ember Data about new records created on the backend?\nWhen you request a record using Ember Data's store.findRecord method, Ember\nwill automatically load the data into the store. This allows Ember to\navoid the latency of making a round trip to the backend next time\nthat record is requested. Additionally, loading a record into the\nstore will update any RecordArrays (e.g. the result of\nstore.filter or store.findAll) that should include that record. This\nmeans any data bindings or computed properties that depend on the\nRecordArray will automatically be synced to include the new or\nupdated record values.\n\nSome applications may want to add or update records in the store\nwithout requesting the record via store.findRecord. To accomplish this you\ncan use the DS.Store's push or pushPayload\nmethods. This is useful for web applications that have a channel\n(such as SSE or\nWeb Sockets) to\nnotify it of new or updated records on the backend.\n\npush\nis the simplest way to load or update records in Ember Data's store.\nWhen using push it is important to\nnormalize\nthe JSON object before pushing it into the store.\n\npush only accepts one record at a time. If you would like to load an\narray of records to the store you can call\npushMany.\n\n  1\n2\n3\n4\n\n  socket.on('message', function (message) {\n  var modelName = message.model;\n  store.push(modelName, store.normalize(modelName, message.data));\n});\n\n\n\nAs of v1.0.0-beta.14 the push method accepts partial attributes for\nupdating existing records. The update method is therefore deprecated.\nUpdating partial attributes is useful if your web application only\nreceives notifications of the changed attributes on a model.\n\npushPayload\nis a convenience wrapper for store#push that will deserialize\npayloads if the model's Serializer implements a pushPayload\nmethod. It is important to note this method will not work with the\nJSONSerializer because it does not implement a pushPayload\nmethod.\n\n  1\n2\n3\n\n  socket.on('message', function (message) {\n  store.pushPayload(message.model, message.data);\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"aaa673b0a07a7fad8549b3be79862344","fields":[{"name":"title","value":"Handling Metadata","type":"string"},{"name":"url","value":"/models/handling-metadata/","type":"enum"},{"name":"body","value":"Along with the records returned from your store, you'll likely need to handle some kind of metadata. Metadata is data that goes along with a specific model or type instead of a record.\n\nPagination is a common example of using metadata. Imagine a blog with far more posts than you can display at once. You might query it like so:\n\n  1\n2\n3\n4\n\n  let result = this.store.query(\"post\", {\n  limit: 10,\n  offset: 0\n});\n\n\n\nTo get different pages of data, you'd simply change your offset in increments of 10. So far, so good. But how do you know how many pages of data you have? Your server would need to return the total number of records as a piece of metadata.\n\nEach serializer will expect the metadata to be returned differently. For example, Ember Data's JSON deserializer looks for a meta key:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  {\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Progressive Enhancement is Dead\",\n    \"comments\": [\"1\", \"2\"],\n    \"links\": {\n      \"user\": \"/people/tomdale\"\n    },\n    // ...\n  },\n\n  \"meta\": {\n    \"total\": 100\n  }\n}\n\n\n\nRegardless of the serializer used, this metadata is extracted from the response. You can then read it with .get('meta').\n\nThis can be done on the result of a store.query() call:\n\n  1\n2\n3\n\n  store.query('post').then((result) =\u003e {\n  let meta = result.get('meta');\n})\n\n\n\nOn a belongsTo relationship:\n\n  1\n2\n3\n4\n5\n\n  let post = store.peekRecord('post', 1);\n\npost.get('author').then((author) =\u003e {\n  let meta = author.get('meta');\n});\n\n\n\nOr on a hasMany relationship:\n\n  1\n2\n3\n4\n5\n\n  let post = store.peekRecord('post', 1);\n\npost.get('comments').then((comments) =\u003e {\n  let meta = comments.get('meta');\n});\n\n\n\nAfter reading it, meta.total can be used to calculate how many pages of posts you'll have.\n\nTo customize metadata extraction, check out the documentation for your serializer.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f6824ed2e6c9f37fc0a6d7f987afee17","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/models/","type":"enum"},{"name":"body","value":"Models\nModels are objects that represent the underlying data that your\napplication presents to the user. Different apps will have very\ndifferent models, depending on what problems they're trying to solve.\n\nFor example, a photo sharing application might have a Photo\nmodel to represent a particular photo, and a PhotoAlbum that\nrepresents a group of photos. In contrast, an online shopping app would\nprobably have different models, like ShoppingCart, Invoice, or\nLineItem.\n\nModels tend to be persistent. That means the user does not expect\nmodel data to be lost when they close their browser window. To make sure\nno data is lost, if the user makes changes to a model, you need to store\nthe model data somewhere that it will not be lost.\n\nTypically, most models are loaded from and saved to a server that uses a\ndatabase to store data. Usually you will send JSON representations of\nmodels back and forth to an HTTP server that you have written. However,\nEmber makes it easy to use other durable storage, such as saving to the\nuser's hard disk with IndexedDB, or hosted storage solutions that let you\navoid writing and hosting your own servers.\n\nOnce you've loaded your models from storage, components know how to\ntranslate model data into a UI that your user can interact with.  For\nmore information about how components get model data, see the\nSpecifying a Route's Model\nguide.\n\nEmber Data, included by default when you create a new application, is a\nlibrary that integrates tightly with Ember to make it easy to retrieve\nmodels from your server as JSON, save updates back to the server, and\ncreate new models in the browser.\n\nThanks to its use of the adapter pattern, Ember Data can be configured\nto work with many different kinds of backends. There is an entire\necosystem of adapters that allow your Ember app to talk to different\ntypes of servers without you writing any networking code.\n\nIf you need to integrate your Ember.js app with a server that does not\nhave an adapter available (for example, you handrolled an API server\nthat does not adhere to any JSON specification), Ember Data is designed\nto be configurable to work with whatever data your server returns.\n\nEmber Data is also designed to work with streaming servers, like those\npowered by WebSockets. You can open a socket to your server and push\nchanges into Ember Data whenever they occur, giving your app a real-time\nuser interface that is always up-to-date.\nThinking in Ember Data\nAt first, using Ember Data may feel different than the way you're used\nto writing JavaScript applications. Many developers are familiar with\nusing AJAX to fetch raw JSON data from an endpoint, which may appear\neasy at first. Over time, however, complexity leaks out into your\napplication code, making it hard to maintain.\n\nWith Ember Data, managing models as your application grows becomes both\nsimple and easy.\n\nOnce you have an understanding of Ember Data, you will have a much\nbetter way to manage the complexity of data loading in your application,\nallowing your code to evolve without becoming a mess.\nThe Store and a Single Source of Truth\nOne common way of building web applications is to tightly couple user\ninterface elements to data fetching. For example, imagine you are\nwriting the admin section of a blogging app, which has a feature that\nlists the drafts for the currently logged in user.\n\nYou might be tempted to make the component responsible for fetching that\ndata and storing it:\n\n  \n    \n      app/components/list-of-drafts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  import Component from \"ember-component\";\n\nexport default Component.extend({\n  willRender() {\n    $.getJSON('/drafts').then(data =\u003e {\n      this.set('drafts', data);\n    });\n  }\n});\n\n\n\nYou could then show the list of drafts in your component's template like\nthis:\n\n  \n    \n      app/templates/components/list-of-drafts.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each drafts key=\"id\" as |draft|}}\n    \u003cli\u003e{{draft.title}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nWhile this works, it is not ideal for several reasons.\n\nFirst, by tightly coupling data fetching to an isolated UI component,\nthe opportunity to share data is lost. As you build out the features of\nyour application, other components may want to access that same data.\n\nFor example, imagine that the next feature you add to the blog editor is\na widget in the app's toolbar that shows a count of unpublished drafts.\nThat component needs the list of drafts as well (so it can count them),\nbut because the two components are responsible for their own data\nfetching, your app will make two separate requests for the same information.\n\nNot only is the redundant data fetching costly in terms of wasted\nbandwidth and affecting the perceived speed of your app, it's easy for\nthe two values to get out-of-sync. You yourself have probably used a web\napplication where the list of items gets out of sync with the counter in\na toolbar, leading to a frustrating and inconsistent experience.\n\nThe second reason this is not ideal is that it creates a tight\ncoupling between your application's UI and the network code. If the\nformat of the JSON payload changes, it is likely to break all of your UI\ncomponents in ways that are hard to track down.\n\nThe SOLID principles of good design tell us that objects should have a\nsingle responsibility. The responsibility of a component should be\npresenting model data to the user, not fetching the model.\n\nGood Ember apps take a different approach. Ember Data gives you a single\nstore that is the central repository of models in your application.\nComponents and routes can ask the store for models, and the store is\nresponsible for knowing how to fetch them.\n\nIt also means that the store can detect that two different components\nare asking for the same model, allowing your app to only fetch the data\nfrom the server once. You can think of the store as a read-through cache\nfor your app's models. Both your components and routes have access to\nthis shared store; when they need to display or modify a model, they\nfirst ask the store for it.\n\nYou use the store to retrieve records (an instance of a model), as well\nto create new ones.  For example, we might want to find a person with\nthe ID of 1 from our route's model hook:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.findRecord('person', 1);\n  }\n});\n\n\nConvention Over Configuration with JSON API\nYou can significantly reduce the amount of code you need to write and\nmaintain by relying on Ember's conventions. By adopting these\nconventions, your don't just write less code; your code will be much\neasier to maintain and be understood by other developers on your team.\n\nRather than create an arbitrary set of conventions, Ember Data is\ndesigned to work out of the box with JSON API. JSON API is a\nformal specification for building conventional, robust, and performant\nAPIs that allow clients and servers to communicate model data.\n\nJSON API standardizes how JavaScript applications talk to servers, so\nyou decrease the coupling between your frontend and backend, and have\nmore freedom to change pieces of your stack.\n\nAs an analogy, JSON API is to JavaScript apps and API servers what SQL is\nto server-side frameworks and databases. Popular frameworks like Ruby on\nRails, Laravel, Django, Spring and more work out of the box with many\ndifferent databases, like MySQL, PostgreSQL, SQL Server, and more.\n\nFrameworks (or apps built on those frameworks) don't need to write\nlots of custom code to add support for a new database; as long as that\ndatabase supports SQL, adding support for it is relatively easy.\n\nSo too with JSON API. By using JSON API to interop between your Ember\napp and your server, you can entirely change your backend stack without\nbreaking your frontend. And as you add apps for other platforms, such as\niOS and Android, you will be able to leverage JSON API libraries for\nthose platforms to easily consume the same API your Ember app uses.\nModels\nIn Ember Data, each model is represented by a subclass of Model that\ndefines the attributes, relationships, and behavior of the data that you\npresent to the user.\n\nModels define the type of data that will be provided by your server. For\nexample, a Person model might have a firstName attribute that is a\nstring, and a birthday attribute that is a date:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Model, { attr } from \"ember-data/model\";\n\nexport default Model.extend({\n  firstName: attr('string'),\n  birthday:  attr('date')\n});\n\n\n\nA model also describes its relationships with other objects. For\nexample, an order may have many line-items, and a\nline-item may belong to a particular order.\n\n  \n    \n      app/models/order.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  import Model, { hasMany } from \"ember-data/model\";\n\nexport default Model.extend({\n  lineItems: hasMany('line-item')\n});\n\n\n\n  \n    \n      app/models/line-item.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  import Model, { belongsTo } from \"ember-data/model\";\n\nexport default Model.extend({\n  order: belongsTo('order')\n});\n\n\n\nModels don't have any data themselves; they just define the attributes,\nrelationships and behavior of specific instances, which are called\nrecords.\nRecords\nA record is an instance of a model that contains data loaded from a\nserver. Your application can also create new records and save them back\nto the server.\n\nA record is uniquely identified by its model type and ID.\n\nFor example, if you were writing a contact management app, you might\nhave a Person model. An individual record in your app might\nhave a type of person and an ID of 1 or steve-buscemi.\n\n  1\n\n  this.store.findRecord('person', 1); // =\u003e { id: 1, name: 'steve-buscemi' }\n\n\n\nAn ID is usually assigned to a record by the server when you save it for\nthe first time, but you can also generate IDs client-side.\nAdapter\nAn adapter is an object that translates requests from Ember (such as\n\"find the user with an ID of 123\") into a requests to a server.\n\nFor example, if your application asks for a Person with an ID of\n123, how should Ember load it? Over HTTP or a WebSocket?  If\nit's HTTP, is the URL /person/1 or /resources/people/1?\n\nThe adapter is responsible for answering all of these questions.\nWhenever your app asks the store for a record that it doesn't have\ncached, it will ask the adapter for it. If you change a record and save\nit, the store will hand the record to the adapter to send the\nappropriate data to your server and confirm that the save was\nsuccessful.\n\nAdapters let you completely change how your API is implemented without\nimpacting your Ember application code.\nAutomatic Caching\nThe store will automatically cache records for you. If a record had already\nbeen loaded, asking for it a second time will always return the same\nobject instance. This minimizes the number of round-trips to the\nserver, and allows your application to render its UI to the user as fast as\npossible.\n\nFor example, the first time your application asks the store for a\nperson record with an ID of 1, it will fetch that information from\nyour server.\n\nHowever, the next time your app asks for a person with ID 1, the\nstore will notice that it had already retrieved and cached that\ninformation from the server. Instead of sending another request for the\nsame information, it will give your application the same record it had\nprovided it the first time.  This feature—always returning the same\nrecord object, no matter how many times you look it up—is sometimes\ncalled an identity map.\n\nUsing an identity map is important because it ensures that changes you\nmake in one part of your UI are propagated to other parts of the UI. It\nalso means that you don't have to manually keep records in sync—you can\nask for a record by ID and not have to worry about whether other parts\nof your application have already asked for and loaded it.\nArchitecture Overview\nThe first time your application asks the store for a record, the store\nsees that it doesn't have a local copy and requests it from your\nadapter. Your adapter will go and retrieve the record from your\npersistence layer; typically, this will be a JSON representation of the\nrecord served from an HTTP server.\n\n\n\nAs illustrated in the diagram above, the adapter cannot always return the\nrequested record immediately. In this case, the adapter must make an\nasynchronous request to the server, and only when that request finishes\nloading can the record be created with its backing data.\n\nBecause of this asynchronicity, the store immediately returns a\npromise from the find() method. Similarly, any requests that the\nstore makes to the adapter also return promises.\n\nOnce the request to the server returns with a JSON payload for the\nrequested record, the adapter resolves the promise it returned to the\nstore with the JSON.\n\nThe store then takes that JSON, initializes the record with the\nJSON data, and resolves the promise returned to your application\nwith the newly-loaded record.\n\n\n\nLet's look at what happens if you request a record that the store\nalready has in its cache.\n\n\n\nIn this case, because the store already knew about the record, it\nreturns a promise that it resolves with the record immediately. It does\nnot need to ask the adapter (and, therefore, the server) for a copy\nsince it already has it saved locally.\n\n\n\nThese are the core concepts you should understand to get the most out of\nEmber Data. The following sections go into more depth about each of\nthese concepts, and how to use them together.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f5cbaf46432fb32d6be26a903d80a41c","fields":[{"name":"title","value":"Persisting Records","type":"string"},{"name":"url","value":"/models/persisting-records/","type":"enum"},{"name":"body","value":"Records in Ember Data are persisted on a per-instance basis.\nCall save() on any instance of DS.Model and it will make a network request.\n\nHere are a few examples:\n\n  1\n2\n3\n4\n5\n6\n\n  var post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\npost.save(); // =\u003e POST to '/posts'\n\n\n\n  1\n2\n3\n4\n5\n6\n7\n\n  store.findRecord('post', 1).then(function(post) {\n  post.get('title'); // =\u003e \"Rails is Omakase\"\n\n  post.set('title', 'A new post');\n\n  post.save(); // =\u003e PUT to '/posts/1'\n});\n\n\nPromises\nsave() returns a promise, so it is extremely easy to handle success and failure scenarios.\n Here's a common pattern:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  var post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nvar self = this;\n\nfunction transitionToPost(post) {\n  self.transitionToRoute('posts.show', post);\n}\n\nfunction failure(reason) {\n  // handle the error\n}\n\npost.save().then(transitionToPost).catch(failure);\n\n// =\u003e POST to '/posts'\n// =\u003e transitioning to posts.show route\n\n\n\nPromises even make it easy to work with failed network requests:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  var post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nvar self = this;\n\nvar onSuccess = function(post) {\n  self.transitionToRoute('posts.show', post);\n};\n\nvar onFail = function(post) {\n  // deal with the failure here\n};\n\npost.save().then(onSuccess, onFail);\n\n// =\u003e POST to '/posts'\n// =\u003e transitioning to posts.show route\n\n\n\nYou can read more about promises here, but here is another\nexample showing how to retry persisting:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  function retry(callback, nTimes) {\n  // if the promise fails\n  return callback().catch(function(reason) {\n    // if we haven't hit the retry limit\n    if (nTimes \u003e 0) {\n      // retry again with the result of calling the retry callback\n      // and the new retry limit\n      return retry(callback, nTimes - 1);\n    }\n\n    // otherwise, if we hit the retry limit, rethrow the error\n    throw reason;\n  });\n}\n\n// try to save the post up to 5 times\nretry(function() {\n  return post.save();\n}, 5);\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0638f122b19f3ca7e20eca12d526a2e6","fields":[{"name":"title","value":"Pushing Records into the Store","type":"string"},{"name":"url","value":"/models/pushing-records-into-the-store/","type":"enum"},{"name":"body","value":"One way to think about the store is as a cache of all of the records\nthat have been loaded by your application. If a route or a controller in\nyour app asks for a record, the store can return it immediately if it is\nin the cache. Otherwise, the store must ask the adapter to load it,\nwhich usually means a trip over the network to retrieve it from the\nserver.\n\nInstead of waiting for the app to request a record, however, you can\npush records into the store's cache ahead of time.\n\nThis is useful if you have a good sense of what records the user\nwill need next. When they click on a link, instead of waiting for a\nnetwork request to finish, Ember.js can render the new template\nimmediately. It feels instantaneous.\n\nAnother use case for pushing in records is if your application has a\nstreaming connection to a backend. If a record is created or modified,\nyou want to update the UI immediately.\nPushing Records\nTo push a record into the store, call the store's push() method.\n\nFor example, imagine we want to preload some data into the store when\nthe application boots for the first time.\n\nWe can use the route:application to do so. The route:application is\nthe top-most route in the route hierarchy, and its model hook gets\ncalled once when the app starts up.\n\n  \n    \n      app/models/album.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.Model.extend({\n  title: DS.attr(),\n  artist: DS.attr(),\n  songCount: DS.attr()\n});\n\n\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  export default Ember.Route.extend({\n  model() {\n    this.store.push('album', {\n      id: 1,\n      title: \"Fewer Moving Parts\",\n      artist: \"David Bazan\",\n      songCount: 10\n    });\n\n    this.store.push('album', {\n      id: 2,\n      title: \"Calgary b/w I Can't Make You Love Me/Nick Of Time\",\n      artist: \"Bon Iver\",\n      songCount: 2\n    });\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0e991ff9ce7021b901869280c0615261","fields":[{"name":"title","value":"The Rest Adapter","type":"string"},{"name":"url","value":"/models/the-rest-adapter/","type":"enum"},{"name":"body","value":"By default, your store will use\nDS.RESTAdapter to load and\nsave records. The RESTAdapter assumes that the URLs and JSON\nassociated with each model are conventional; this means that, if you\nfollow the rules, you will not need to configure the adapter or write\nany code in order to get started.\nURL Conventions\nThe REST adapter is smart enough to determine the URLs it communicates\nwith based on the name of the model. For example, if you ask for a\nPost by ID:\n\n  1\n2\n\n  store.findRecord('post', 1).then(function(post) {\n});\n\n\n\nThe REST adapter will automatically send a GET request to /posts/1.\n\nFor multiple word names, the REST adapter will use lower_snake_case.\n\nThe actions you can take on a record map onto the following URLs in the\nREST adapter:\n\n\n  \n    ActionHTTP VerbURL\n  \n  \n    Find RecordGET/posts/123\n    Find AllGET/posts\n    UpdatePUT/posts/123\n    CreatePOST/posts\n    DeleteDELETE/posts/123\n  \n\nPluralization Customization\nIrregular or uncountable pluralizations can be specified via Ember.Inflector.inflector:\n\n  1\n2\n3\n4\n\n  var inflector = Ember.Inflector.inflector;\n\ninflector.irregular('person', 'people');\ninflector.uncountable('advice');\n\n\n\nThis will tell the REST adapter that requests for person\nshould go to /people/1 instead of /persons/1.\nEndpoint Path Customization\nEndpoint paths can be prefixed with a namespace by setting the namespace\nproperty on the adapter:\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  namespace: 'api/1'\n});\n\n\n\nRequests for person would now target http://emberjs.com/api/1/people/1.\nHost Customization\nAn adapter can target other hosts by setting the host property.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  host: 'https://api.example.com'\n});\n\n\n\nRequests for person would now target https://api.example.com/people/1.\nJSON Conventions\nWhen requesting a record, the REST adapter expects your server to return\na JSON representation of the record that conforms to the following\nconventions.\nJSON Root\nThe primary record being returned should be in a named root. For\nexample, if you request a record from /people/123, the response should\nbe nested inside a property called person:\n\n  1\n2\n3\n4\n5\n6\n\n  {\n  \"person\": {\n    \"firstName\": \"Jeff\",\n    \"lastName\": \"Atwood\"\n  }\n}\n\n\n\nAfter destroyRecord or after deleteRecord and save, the adapter expects the server to return an empty object ({}).\n\nIf you don't have the option to change the data that the server responds with, you can override the\nDS.JSONSerializer#extractDeleteRecord, like so:\n\n  1\n2\n3\n4\n5\n\n  extractDeleteRecord: function(store, type, payload) {\n  // If the payload is {delete: true}, Ember Data will try to set\n  // the new properties. Return null so it doesn't try to do that.\n  return null;\n}\n\n\nAttribute Names\nAttribute names should be camelized.  For example, if you have a model like this:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default DS.Model.extend({\n  firstName: DS.attr('string'),\n  lastName:  DS.attr('string'),\n\n  isPersonOfTheYear: DS.attr('boolean')\n});\n\n\n\nThe JSON returned from your server should look like this:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  {\n  \"person\": {\n    \"firstName\": \"Barack\",\n    \"lastName\": \"Obama\",\n    \"isPersonOfTheYear\": true\n  }\n}\n\n\n\nIrregular keys can be mapped with a custom serializer. If the JSON for\nperson has a key of lastNameOfPerson, and the desired\nattribute name is simply lastName, then create a custom Serializer\nfor the model and override the normalizeHash property.\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  lastName: DS.attr('string')\n});\n\n\n\n  \n    \n      app/serializers/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default DS.RESTSerializer.extend({\n  normalizeHash: {\n    lastNameOfPerson: function(hash) {\n      hash.lastName = hash.lastNameOfPerson;\n      delete hash.lastNameOfPerson;\n\n      return hash;\n    }\n  }\n});\n\n\nRelationships\nReferences to other records should be done by ID. For example, if you\nhave a model with a hasMany relationship:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  comments: DS.hasMany('comment', { async: true })\n});\n\n\n\nThe JSON should encode the relationship as an array of IDs:\n\n  1\n2\n3\n4\n5\n\n  {\n  \"post\": {\n    \"comments\": [1, 2, 3]\n  }\n}\n\n\n\nComments for a post can be loaded by post.get('comments'). The REST\nadapter will send a GET request for each related comment.\n\n  1\n2\n3\n4\n5\n\n  post.get('comments');\n\n// GET /comments/1\n// GET /comments/2\n// GET /comments/3\n\n\n\nYou may prevent sending multiple requests by setting coalesceFindRequests\nto true in your adapter.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  coalesceFindRequests: true\n});\n\n\n\nThe REST adapter will now send a GET request to /comments?ids[]=1\u0026ids[]=2\u0026ids[]=3.\n\nAny belongsTo relationships in the JSON representation should be the\ncamelized version of the Ember Data model's name. For example, if you have\na model:\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  post: DS.belongsTo('post')\n});\n\n\n\nThe JSON should encode the relationship as an ID to another record:\n\n  1\n2\n3\n4\n5\n\n  {\n  \"comment\": {\n    \"post\": 1\n  }\n}\n\n\n\nIf needed these naming conventions can be overwritten by implementing\nthe keyForRelationship method.\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.RESTSerializer.extend({\n  keyForRelationship: function(key, relationship) {\n    return key + 'Ids';\n  }\n});\n\n\nSideloaded Relationships\nTo reduce the number of HTTP requests necessary, you can sideload\nadditional records in your JSON response. Sideloaded records live\noutside the JSON root, and are represented as an array of hashes:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  {\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Node is not omakase\",\n    \"comments\": [1, 2, 3]\n  },\n\n  \"comments\": [{\n    \"id\": 1,\n    \"body\": \"But is it _lightweight_ omakase?\"\n  },\n  {\n    \"id\": 2,\n    \"body\": \"I for one welcome our new omakase overlords\"\n  },\n  {\n    \"id\": 3,\n    \"body\": \"Put me on the fast track to a delicious dinner\"\n  }]\n}\n\n\nCreating Custom Transformations\nIn some circumstances, the built in attribute types of string,\nnumber, boolean, and date may be inadequate. For example, a\nserver may return a non-standard date format.\n\nEmber Data can have new JSON transforms\nregistered for use as attributes:\n\n  \n    \n      app/transforms/coordinate-point.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default DS.Transform.extend({\n  serialize: function(value) {\n    return [value.get('x'), value.get('y')];\n  },\n  deserialize: function(value) {\n    return Ember.create({ x: value[0], y: value[1] });\n  }\n});\n\n\n\n  \n    \n      app/models/cursor.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  position: DS.attr('coordinatePoint')\n});\n\n\n\nWhen coordinatePoint is received from the API, it is\nexpected to be an array:\n\n  1\n2\n3\n4\n5\n\n  {\n  cursor: {\n    position: [4,9]\n  }\n}\n\n\n\nBut once loaded on a model instance, it will behave as an object:\n\n  1\n2\n3\n\n  var cursor = this.store.findRecord('cursor', 1);\ncursor.get('position.x'); //=\u003e 4\ncursor.get('position.y'); //=\u003e 9\n\n\n\nIf position is modified and saved, it will pass through the\nserialize function in the transform and again be presented as\nan array in JSON.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3701fefea474dad678c5fecd87312b01","fields":[{"name":"title","value":"Working with Records","type":"string"},{"name":"url","value":"/models/working-with-records/","type":"enum"},{"name":"body","value":"Modifying Attributes\nOnce a record has been loaded, you can begin making changes to its\nattributes. Attributes behave just like normal properties in Ember.js\nobjects. Making changes is as simple as setting the attribute you\nwant to change:\n\n  1\n2\n3\n\n  var tyrion = this.store.findRecord('person', 1);\n// ...after the record has loaded\ntyrion.set('firstName', \"Yollo\");\n\n\n\nAll of the Ember.js conveniences are available for\nmodifying attributes. For example, you can use Ember.Object's\nincrementProperty helper:\n\n  1\n\n  person.incrementProperty('age'); // Happy birthday!\n\n\n\nYou can tell if a record has outstanding changes that have not yet been\nsaved by checking its isDirty property. You can also see what parts of\nthe record were changed and what the original value was using the\nchangedAttributes function.  changedAttributes returns an object,\nwhose keys are the changed properties and values are an array of values\n[oldValue, newValue].\n\n  1\n2\n3\n4\n5\n\n  person.get('isAdmin');      //=\u003e false\nperson.get('isDirty');      //=\u003e false\nperson.set('isAdmin', true);\nperson.get('isDirty');      //=\u003e true\nperson.changedAttributes(); //=\u003e { isAdmin: [false, true] }\n\n\n\nAt this point, you can either persist your changes via save() or you\ncan rollback your changes. Calling rollback() reverts all the\nchangedAttributes to their original value.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  person.get('isDirty');      //=\u003e true\nperson.changedAttributes(); //=\u003e { isAdmin: [false, true] }\n\nperson.rollback();\n\nperson.get('isDirty');      //=\u003e false\nperson.get('isAdmin');      //=\u003e false\nperson.changedAttributes(); //=\u003e {}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"7bdaf101518cf52ad2c7b8a7eb71a128","fields":[{"name":"title","value":"Bindings","type":"string"},{"name":"url","value":"/object-model/bindings/","type":"enum"},{"name":"body","value":"A binding creates a link between two properties such that when one changes, the\nother one is updated to the new value automatically. Bindings can connect\nproperties on the same object, or across two different objects. Unlike most other\nframeworks that include some sort of binding implementation, bindings in\nEmber.js can be used with any object, not just between views and models.\n\nThe easiest way to create a two-way binding is to use a computed alias, that\nspecifies the path to another object.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  wife = Ember.Object.create({\n  householdIncome: 80000\n});\n\nHusband = Ember.Object.extend({\n  householdIncome: Ember.computed.alias('wife.householdIncome')\n});\n\nhusband = Husband.create({\n  wife: wife\n});\n\nhusband.get('householdIncome'); // 80000\n\n// Someone gets raise.\nwife.set('householdIncome', 90000);\nhusband.get('householdIncome'); // 90000\n\n\n\nNote that bindings don't update immediately. Ember waits until all of your\napplication code has finished running before synchronizing changes, so you can\nchange a bound property as many times as you'd like without worrying about the\noverhead of syncing bindings when values are transient.\nOne-Way Bindings\nA one-way binding only propagates changes in one direction. Often, one-way\nbindings are just a performance optimization and you can safely use a two-way binding\n(as, of course, two-way bindings are de facto one-way bindings if you only ever change\none side). Sometimes one-way bindings are useful to achieve specific behaviour such\nas a default that is the same as another property but can be overridden (e.g. a\nshipping address that starts the same as a billing address but can later be changed)\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n  user = Ember.Object.create({\n  fullName: \"Kara Gates\"\n});\n\nUserView = Ember.View.extend({\n  userName: Ember.computed.oneWay('user.fullName')\n});\n\nuserView = UserView.create({\n  user: user\n});\n\n// Changing the name of the user object changes\n// the value on the view.\nuser.set('fullName', \"Krang Gates\");\n// userView.userName will become \"Krang Gates\"\n\n// ...but changes to the view don't make it back to\n// the object.\nuserView.set('userName', \"Truckasaurus Gates\");\nuser.get('fullName'); // \"Krang Gates\"\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4eb2fcd4e32d72e009d1c1d9fdceee41","fields":[{"name":"title","value":"Classes and Instances","type":"string"},{"name":"url","value":"/object-model/classes-and-instances/","type":"enum"},{"name":"body","value":"Defining Classes\nTo define a new Ember class, call the extend() method on\nEmber.Object:\n\n  1\n2\n3\n4\n5\n\n  Person = Ember.Object.extend({\n  say(thing) {\n    alert(thing);\n  }\n});\n\n\n\nThis defines a new Person class with a say() method.\n\nYou can also create a subclass from any existing class by calling\nits extend() method. For example, you might want to create a subclass\nof Ember's built-in Ember.Component class:\n\n  \n    \n      app/views/person.js\n    \n  \n\n  1\n2\n3\n4\n\n  PersonView = Ember.Component.extend({\n  tagName: 'li',\n  classNameBindings: ['isAdministrator']\n});\n\n\n\nWhen defining a subclass, you can override methods but still access the\nimplementation of your parent class by calling the special _super()\nmethod:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  Person = Ember.Object.extend({\n  say(thing) {\n    var name = this.get('name');\n    alert(name + \" says: \" + thing);\n  }\n});\n\nSoldier = Person.extend({\n  say(thing) {\n    // this will call the method in the parent class (Person#say), appending\n    // the string \", sir!\" to the variable `thing` passed in\n    this._super(thing + \", sir!\");\n  }\n});\n\nvar yehuda = Soldier.create({\n  name: \"Yehuda Katz\"\n});\n\nyehuda.say(\"Yes\"); // alerts \"Yehuda Katz says: Yes, sir!\"\n\n\nCreating Instances\nOnce you have defined a class, you can create new instances of that\nclass by calling its create() method. Any methods, properties and\ncomputed properties you defined on the class will be available to\ninstances:\n\n  1\n2\n\n  var person = Person.create();\nperson.say(\"Hello\"); // alerts \" says: Hello\"\n\n\n\nWhen creating an instance, you can initialize the values of its properties\nby passing an optional hash to the create() method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  Person = Ember.Object.extend({\n  helloWorld() {\n    alert(\"Hi, my name is \" + this.get('name'));\n  }\n});\n\nvar tom = Person.create({\n  name: \"Tom Dale\"\n});\n\ntom.helloWorld(); // alerts \"Hi, my name is Tom Dale\"\n\n\n\nFor performance reasons, note that you cannot redefine an instance's\ncomputed properties or methods when calling create(), nor can you\ndefine new ones. You should only set simple properties when calling\ncreate(). If you need to define or redefine methods or computed\nproperties, create a new subclass and instantiate that.\n\nBy convention, properties or variables that hold classes are\nPascalCased, while instances are not. So, for example, the variable\nPerson would point to a class, while person would point to an instance\n(usually of the Person class). You should stick to these naming\nconventions in your Ember applications.\nInitializing Instances\nWhen a new instance is created, its init method is invoked\nautomatically. This is the ideal place to do setup required on new\ninstances:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  Person = Ember.Object.extend({\n  init() {\n    var name = this.get('name');\n    alert(name + \", reporting for duty!\");\n  }\n});\n\nPerson.create({\n  name: \"Stefan Penner\"\n});\n\n// alerts \"Stefan Penner, reporting for duty!\"\n\n\n\nIf you are subclassing a framework class, like Ember.Component, and you\noverride the init method, make sure you call this._super()! If you don't,\nthe system may not have an opportunity to do important setup work, and you'll\nsee strange behavior in your application.\nAccessing Object Properties\nWhen accessing the properties of an object, use the get\nand set accessor methods:\n\n  1\n2\n3\n4\n\n  var person = Person.create();\n\nvar name = person.get('name');\nperson.set('name', \"Tobias Fünke\");\n\n\n\nMake sure to use these accessor methods; otherwise, computed properties won't\nrecalculate, observers won't fire, and templates won't update.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e959824557e508bda4cb824e0466f1ac","fields":[{"name":"title","value":"Computed Properties and Aggregate Data with @each","type":"string"},{"name":"url","value":"/object-model/computed-properties-and-aggregate-data/","type":"enum"},{"name":"body","value":"Often, you may have a computed property that relies on all of the items in an\narray to determine its value. For example, you may want to count all of the\ntodo items in a controller to determine how many of them are completed.\n\nHere's what that computed property might look like:\n\n  \n    \n      app/controllers/todos.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Controller.extend({\n  todos: [\n    Ember.Object.create({ isDone: true }),\n    Ember.Object.create({ isDone: false }),\n    Ember.Object.create({ isDone: true })\n  ],\n\n  remaining: Ember.computed('todos.@each.isDone', function() {\n    var todos = this.get('todos');\n    return todos.filterBy('isDone', false).get('length');\n  })\n});\n\n\n\nNote here that the dependent key (todos.@each.isDone) contains the special\nkey @each. This instructs Ember.js to update bindings and fire observers for\nthis computed property when one of the following four events occurs:\n\n\nThe isDone property of any of the objects in the todos array changes.\nAn item is added to the todos array.\nAn item is removed from the todos array.\nThe todos property of the controller is changed to a different array.\n\n\nIn the example above, the remaining count is 1:\n\n  1\n2\n3\n4\n\n  import TodosController from 'app/controllers/todos';\ntodosController = TodosController.create();\ntodosController.get('remaining');\n// 1\n\n\n\nIf we change the todo's isDone property, the remaining property is updated\nautomatically:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  var todos = todosController.get('todos');\nvar todo = todos.objectAt(1);\ntodo.set('isDone', true);\n\ntodosController.get('remaining');\n// 0\n\ntodo = Ember.Object.create({ isDone: false });\ntodos.pushObject(todo);\n\ntodosController.get('remaining');\n// 1\n\n\n\nNote that @each only works one level deep. You cannot use nested forms like\ntodos.@each.owner.name or todos.@each.owner.@each.name.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a26ec310640ced8b722a53a9ac4a703a","fields":[{"name":"title","value":"Computed Properties","type":"string"},{"name":"url","value":"/object-model/computed-properties/","type":"enum"},{"name":"body","value":"What are Computed Properties?\nIn a nutshell, computed properties let you declare functions as properties. You create one by defining a computed property as a function, which Ember will automatically call when you ask for the property. You can then use it the same way you would any normal, static property.\n\nIt's super handy for taking one or more normal properties and transforming or manipulating their data to create a new value.\nComputed properties in action\nWe'll start with a simple example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  Person = Ember.Object.extend({\n  // these will be supplied by `create`\n  firstName: null,\n  lastName: null,\n\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  })\n});\n\nvar ironMan = Person.create({\n  firstName: \"Tony\",\n  lastName:  \"Stark\"\n});\n\nironMan.get('fullName'); // \"Tony Stark\"\n\n\n\nThis declares the function to be a computed property, and the arguments tell Ember that it depends on the firstName and lastName attributes.\n\nWhenever you access the fullName property, this function gets called, and it returns the value of the function, which simply calls firstName + lastName.\nChaining computed properties\nYou can use computed properties as values to create new computed properties. Let's add a description computed property to the previous example, and use the existing fullName property and add in some other properties:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  Person = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n  age: null,\n  country: null,\n\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  }),\n\n  description: Ember.computed('fullName', 'age', 'country', function() {\n    return this.get('fullName') + '; Age: ' + this.get('age') + '; Country: ' + this.get('country');\n  })\n});\n\nvar captainAmerica = Person.create({\n  firstName: 'Steve',\n  lastName: 'Rogers',\n  age: 80,\n  country: 'USA'\n});\n\ncaptainAmerica.get('description'); // \"Steve Rogers; Age: 80; Country: USA\"\n\n\nDynamic updating\nComputed properties, by default, observe any changes made to the properties they depend on and are dynamically updated when they're called. Let's use computed properties to dynamically update.\n\n  1\n2\n3\n\n  captainAmerica.set('firstName', 'William');\n\ncaptainAmerica.get('description'); // \"William Rogers; Age: 80; Country: USA\"\n\n\n\nSo this change to firstName was observed by fullName computed property, which was itself observed by the description property.\n\nSetting any dependent property will propagate changes through any computed properties that depend on them, all the way down the chain of computed properties you've created.\nSetting Computed Properties\nYou can also define what Ember should do when setting a computed property. If you try to set a computed property, it will be invoked with the key (property name), the value you want to set it to, and the previous value.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n  Person = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n\n  fullName: Ember.computed('firstName', 'lastName', {\n    get(key) {\n      return this.get('firstName') + ' ' + this.get('lastName');\n    },\n    set(key, value) {\n      var [ firstName, lastName ] = value.split(/\\s+/);\n      this.set('firstName', firstName);\n      this.set('lastName',  lastName);\n    }\n  })\n});\n\n\nvar captainAmerica = Person.create();\ncaptainAmerica.set('fullName', \"William Burnside\");\ncaptainAmerica.get('firstName'); // William\ncaptainAmerica.get('lastName'); // Burnside\n\n\n\nEmber will call the computed property for both setters and getters, so if you want to use a computed property as a setter, you'll need to check the number of arguments to determine whether it is being called as a getter or a setter. Note that if a value is returned from the setter, it will be cached as the property's value.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"27baf1b906842ce32a37f5fd551f1e91","fields":[{"name":"title","value":"Enumerables","type":"string"},{"name":"url","value":"/object-model/enumerables/","type":"enum"},{"name":"body","value":"Enumerables\nIn Ember.js, an Enumerable is any object that contains a number of child\nobjects, and which allows you to work with those children using the\nEmber.Enumerable API. The most common\nEnumerable in the majority of apps is the native JavaScript array, which\nEmber.js extends to conform to the Enumerable interface.\n\nBy providing a standardized interface for dealing with enumerables,\nEmber.js allows you to completely change the way your underlying data is\nstored without having to modify the other parts of your application that\naccess it.\n\nThe Enumerable API follows ECMAScript specifications as much as\npossible. This minimizes incompatibility with other libraries, and\nallows Ember.js to use the native browser implementations in arrays\nwhere available.\n\nFor instance, all Enumerables support the standard forEach method:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  [1,2,3].forEach(function(item) {\n  console.log(item);\n});\n\n//=\u003e 1\n//=\u003e 2\n//=\u003e 3\n\n\n\nIn general, Enumerable methods, like forEach, take an optional second\nparameter, which will become the value of this in the callback\nfunction:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var array = [1,2,3];\n\narray.forEach(function(item) {\n  console.log(item, this.indexOf(item));\n}, array)\n\n//=\u003e 1 0\n//=\u003e 2 1\n//=\u003e 3 2\n\n\nEnumerables in Ember.js\nUsually, objects that represent lists implement the Enumerable interface. Some examples:\n\n\nArray - Ember extends the native JavaScript Array with the\nEnumerable interface (unless you disable prototype\nextensions.)\nEmber.Set - A data structure that can efficiently answer whether it\nincludes an object.\n\nAPI Overview\nIn this guide, we'll explore some of the most common Enumerable\nconveniences. For the full list, please see the Ember.Enumerable API\nreference documentation.\nIterating Over an Enumerable\nTo enumerate all the values of an enumerable object, use the forEach method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var food = [\"Poi\", \"Ono\", \"Adobo Chicken\"];\n\nfood.forEach(function(item, index) {\n  console.log('Menu Item %@: %@'.fmt(index+1, item));\n});\n\n// Menu Item 1: Poi\n// Menu Item 2: Ono\n// Menu Item 3: Adobo Chicken\n\n\nMaking an Array Copy\nYou can make a native array copy of any object that implements\nEmber.Enumerable by calling the toArray() method:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var states = Ember.Set.create();\n\nstates.add(\"Hawaii\");\nstates.add(\"California\")\n\nstates.toArray()\n//=\u003e [\"Hawaii\", \"California\"]\n\n\n\nNote that in many enumerables, such as the Ember.Set used in this\nexample, the order of the resulting array is not guaranteed.\nFirst and Last Objects\nAll Enumerables expose firstObject and lastObject properties\nthat you can bind to.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var animals = [\"rooster\", \"pig\"];\n\nanimals.get('lastObject');\n//=\u003e \"pig\"\n\nanimals.pushObject(\"peacock\");\n\nanimals.get('lastObject');\n//=\u003e \"peacock\"\n\n\nMap\nYou can easily transform each item in an enumerable using the\nmap() method, which creates a new array with results of calling a\nfunction on each item in the enumerable.\n\n  1\n2\n3\n4\n5\n6\n\n  var words = [\"goodbye\", \"cruel\", \"world\"];\n\nvar emphaticWords = words.map(function(item) {\n  return item + \"!\";\n});\n// [\"goodbye!\", \"cruel!\", \"world!\"]\n\n\n\nIf your enumerable is composed of objects, there is a mapBy()\nmethod that will extract the named property from each of those objects\nin turn and return a new array:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  var hawaii = Ember.Object.create({\n  capital: \"Honolulu\"\n});\n\nvar california = Ember.Object.create({\n  capital: \"Sacramento\"\n});\n\nvar states = [hawaii, california];\n\nstates.mapBy('capital');\n//=\u003e [\"Honolulu\", \"Sacramento\"]\n\n\nFiltering\nAnother common task to perform on an Enumerable is to take the\nEnumerable as input, and return an Array after filtering it based on\nsome criteria.\n\nFor arbitrary filtering, use the filter method.  The filter method\nexpects the callback to return true if Ember should include it in the\nfinal Array, and false or undefined if Ember should not.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var arr = [1,2,3,4,5];\n\narr.filter(function(item, index, self) {\n  if (item \u003c 4) { return true; }\n})\n\n// returns [1,2,3]\n\n\n\nWhen working with a collection of Ember objects, you will often want to filter a set of objects based upon the value of some property. The filterBy method provides a shortcut.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  Todo = Ember.Object.extend({\n  title: null,\n  isDone: false\n});\n\ntodos = [\n  Todo.create({ title: 'Write code', isDone: true }),\n  Todo.create({ title: 'Go to sleep' })\n];\n\ntodos.filterBy('isDone', true);\n\n// returns an Array containing only items with `isDone == true`\n\n\n\nIf you want to return just the first matched value, rather than an Array containing all of the matched values, you can use find and findBy, which work just like filter and filterBy, but return only one item.\nAggregate Information (All or Any)\nIf you want to find out whether every item in an Enumerable matches some condition, you can use the every method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  Person = Ember.Object.extend({\n  name: null,\n  isHappy: false\n});\n\nvar people = [\n  Person.create({ name: 'Yehuda', isHappy: true }),\n  Person.create({ name: 'Majd', isHappy: false })\n];\n\npeople.every(function(person, index, self) {\n  if(person.get('isHappy')) { return true; }\n});\n\n// returns false\n\n\n\nIf you want to find out whether at least one item in an Enumerable matches some conditions, you can use the some method:\n\n  1\n2\n3\n4\n5\n\n  people.some(function(person, index, self) {\n  if(person.get('isHappy')) { return true; }\n});\n\n// returns true\n\n\n\nJust like the filtering methods, the every and some methods have analogous isEvery and isAny methods.\n\n  1\n2\n\n  people.isEvery('isHappy', true) // false\npeople.isAny('isHappy', true)  // true\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2899adf50b491f36747129255557b93d","fields":[{"name":"title","value":"Observers","type":"string"},{"name":"url","value":"/object-model/observers/","type":"enum"},{"name":"body","value":"Ember supports observing any property, including computed properties.\nYou can set up an observer on an object by using Ember.observer:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  Person = Ember.Object.extend({\n  // these will be supplied by `create`\n  firstName: null,\n  lastName: null,\n\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    var firstName = this.get('firstName');\n    var lastName = this.get('lastName');\n\n    return firstName + ' ' + lastName;\n  }),\n\n  fullNameChanged: Ember.observer('fullName', function() {\n    // deal with the change\n  })\n});\n\nvar person = Person.create({\n  firstName: 'Yehuda',\n  lastName: 'Katz'\n});\n\nperson.set('firstName', 'Brohuda'); // observer will fire\n\n\n\nBecause the fullName computed property depends on firstName,\nupdating firstName will fire observers on fullName as well.\nObservers and asynchrony\nObservers in Ember are currently synchronous. This means that they will fire\nas soon as one of the properties they observe changes. Because of this, it\nis easy to introduce bugs where properties are not yet synchronized:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Person.reopen({\n  lastNameChanged: Ember.observer('lastName', function() {\n    // The observer depends on lastName and so does fullName. Because observers\n    // are synchronous, when this function is called the value of fullName is\n    // not updated yet so this will log the old value of fullName\n    console.log(this.get('fullName'));\n  })\n});\n\n\n\nThis synchronous behavior can also lead to observers being fired multiple\ntimes when observing multiple properties:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Person.reopen({\n  partOfNameChanged: Ember.observer('firstName', 'lastName', function() {\n    // Because both firstName and lastName were set, this observer will fire twice.\n  })\n});\n\nperson.set('firstName', 'John');\nperson.set('lastName', 'Smith');\n\n\n\nTo get around these problems, you should make use of Ember.run.once. This will\nensure that any processing you need to do only happens once, and happens in the\nnext run loop once all bindings are synchronized:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  Person.reopen({\n  partOfNameChanged: Ember.observer('firstName', 'lastName', function() {\n    Ember.run.once(this, 'processFullName');\n  }),\n\n  processFullName: Ember.observer('fullName', function() {\n    // This will only fire once if you set two properties at the same time, and\n    // will also happen in the next run loop once all properties are synchronized\n    console.log(this.get('fullName'));\n  })\n});\n\nperson.set('firstName', 'John');\nperson.set('lastName', 'Smith');\n\n\nObservers and object initialization\nObservers never fire until after the initialization of an object is complete.\n\nIf you need an observer to fire as part of the initialization process, you\ncannot rely on the side effect of set. Instead, specify that the observer\nshould also run after init by using Ember.on():\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Person = Ember.Object.extend({\n  init: function() {\n    this.set('salutation', 'Mr/Ms');\n  },\n\n  salutationDidChange: Ember.on('init', Ember.observer('salutation', function() {\n    // some side effect of salutation changing\n  }))\n});\n\n\nUnconsumed Computed Properties Do Not Trigger Observers\nIf you never get a computed property, its observers will not fire even if\nits dependent keys change. You can think of the value changing from one unknown\nvalue to another.\n\nThis doesn't usually affect application code because computed properties are\nalmost always observed at the same time as they are fetched. For example, you get\nthe value of a computed property, put it in DOM (or draw it with D3), and then\nobserve it so you can update the DOM once the property changes.\n\nIf you need to observe a computed property but aren't currently retrieving it,\njust get it in your init method.\nOutside of class definitions\nYou can also add observers to an object outside of a class definition\nusing addObserver:\n\n  1\n2\n3\n\n  person.addObserver('fullName', function() {\n  // deal with the change\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f8ecff8837ebc62045275db96d37ff19","fields":[{"name":"title","value":"Reopening Classes and Instances","type":"string"},{"name":"url","value":"/object-model/reopening-classes-and-instances/","type":"enum"},{"name":"body","value":"You don't need to define a class all at once. You can reopen a class and\ndefine new properties using the reopen method.\n\n  1\n2\n3\n4\n5\n\n  Person.reopen({\n  isPerson: true\n});\n\nPerson.create().get('isPerson') // true\n\n\n\nWhen using reopen, you can also override existing methods and\ncall this._super.\n\n  1\n2\n3\n4\n5\n6\n\n  Person.reopen({\n  // override `say` to add an ! at the end\n  say: function(thing) {\n    this._super(thing + \"!\");\n  }\n});\n\n\n\nreopen is used to add instance methods and properties that are shared across all instances of a class. It does not add\nmethods and properties to a particular instance of a class as in vanilla JavaScript (without using prototype).\n\nBut when you need to add static methods or static properties to the class itself you can use reopenClass.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  // add static property to class\nPerson.reopenClass({\n  isPerson: false\n});\n// override property of Person instance\nPerson.reopen({\n  isPerson: true\n});\n\nPerson.isPerson; // false - because it is static property created by `reopenClass`\nPerson.create().get(\"isPerson\"); // true\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e85689a1d05f5ca425e72f28075b9737","fields":[{"name":"title","value":"Bindings, Observers, Computed Properties: What Do I Use When?","type":"string"},{"name":"url","value":"/object-model/what-do-i-use-when/","type":"enum"},{"name":"body","value":"Sometimes new users are confused about when to use computed properties,\nbindings and observers. Here are some guidelines to help:\n\n\nUse computed properties to build a new property by synthesizing other\nproperties. Computed properties should not contain application behavior, and\nshould generally not cause any side-effects when called. Except in rare cases,\nmultiple calls to the same computed property should always return the same\nvalue (unless the properties it depends on have changed, of course.)\nObservers should contain behavior that reacts to changes in another\nproperty. Observers are especially useful when you need to perform some\nbehavior after a binding has finished synchronizing.\nBindings are most often used to ensure objects in two different layers\nare always in sync. For example, you bind your views to your controller using\nHandlebars.\n\nMore Resources\nStefan Penner at Yahoo discusses when to use observers and when to use computed properties:\n- The observer tip-jar - Stefan Penner Silicon Valley Ember.js meetup Jun 15, 2015\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2e1967ab300f10bb0db8e074948cdccf","fields":[{"name":"title","value":"Asynchronous Routing","type":"string"},{"name":"url","value":"/routing/asynchronous-routing/","type":"enum"},{"name":"body","value":"This section covers some more advanced features of the router and its\ncapability for handling complex async logic within your app.\nA Word on Promises...\nEmber's approach to handling asynchronous logic in the router makes\nheavy use of the concept of Promises. In short, promises are objects that\nrepresent an eventual value. A promise can either fulfill\n(successfully resolve the value) or reject (fail to resolve the\nvalue). The way to retrieve this eventual value, or handle the cases\nwhen the promise rejects, is via the promise's then method, which\naccepts two optional callbacks, one for fulfillment and one for\nrejection. If the promise fulfills, the fulfillment handler gets called\nwith the fulfilled value as its sole argument, and if the promise rejects,\nthe rejection handler gets called with a reason for the rejection as its\nsole argument. For example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  var promise = fetchTheAnswer();\n\npromise.then(fulfill, reject);\n\nfunction fulfill(answer) {\n  console.log(\"The answer is \" + answer);\n}\n\nfunction reject(reason) {\n  console.log(\"Couldn't get the answer! Reason: \" + reason);\n}\n\n\n\nMuch of the power of promises comes from the fact that they can be\nchained together to perform sequential asynchronous operations:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  // Note: jQuery AJAX methods return promises\nvar usernamesPromise = Ember.$.getJSON('/usernames.json');\n\nusernamesPromise.then(fetchPhotosOfUsers)\n                .then(applyInstagramFilters)\n                .then(uploadTrendyPhotoAlbum)\n                .then(displaySuccessMessage, handleErrors);\n\n\n\nIn the above example, if any of the methods\nfetchPhotosOfUsers, applyInstagramFilters, or\nuploadTrendyPhotoAlbum returns a promise that rejects,\nhandleErrors will be called with\nthe reason for the failure. In this manner, promises approximate an\nasynchronous form of try-catch statements that prevent the rightward\nflow of nested callback after nested callback and facilitate a saner\napproach to managing complex asynchronous logic in your applications.\n\nThis guide doesn't intend to fully delve into all the different ways\npromises can be used, but if you'd like a more thorough introduction,\ntake a look at the readme for RSVP,\nthe promise library that Ember uses.\nThe Router Pauses for Promises\nWhen transitioning between routes, the Ember router collects all of the\nmodels (via the model hook) that will be passed to the route's\ncontrollers at the end of the transition. If the model hook (or the related\nbeforeModel or afterModel hooks) return normal (non-promise) objects or\narrays, the transition will complete immediately. But if the model hook\n(or the related beforeModel or afterModel hooks) returns a promise (or\nif a promise was provided as an argument to transitionTo), the transition\nwill pause until that promise fulfills or rejects.\n\nThe router considers any object with a then method\ndefined on it to be a promise.\n\nIf the promise fulfills, the transition will pick up where it left off and\nbegin resolving the next (child) route's model, pausing if it too is a\npromise, and so on, until all destination route models have been\nresolved. The values passed to the setupController hook for each route\nwill be the fulfilled values from the promises.\n\nA basic example:\n\n  \n    \n      app/routes/tardy.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.Route.extend({\n  model() {\n    return new Ember.RSVP.Promise(function(resolve) {\n      Ember.run.later(function() {\n        resolve({ msg: \"Hold Your Horses\" });\n      }, 3000);\n    });\n  },\n\n  setupController(controller, model) {\n    console.log(model.msg); // \"Hold Your Horses\"\n  }\n});\n\n\n\nWhen transitioning into route:tardy, the model hook will be called and\nreturn a promise that won't resolve until 3 seconds later, during which time\nthe router will be paused in mid-transition. When the promise eventually\nfulfills, the router will continue transitioning and eventually call\nroute:tardy's setupController hook with the resolved object.\n\nThis pause-on-promise behavior is extremely valuable for when you need\nto guarantee that a route's data has fully loaded before displaying a\nnew template.\nWhen Promises Reject...\nWe've covered the case when a model promise fulfills, but what if it rejects?\n\nBy default, if a model promise rejects during a transition, the transition is\naborted, no new destination route templates are rendered, and an error\nis logged to the console.\n\nYou can configure this error-handling logic via the error handler on\nthe route's actions hash. When a promise rejects, an error event\nwill be fired on that route and bubble up to route:application's\ndefault error handler unless it is handled by a custom error handler\nalong the way, e.g.:\n\n  \n    \n      app/routes/good-for-nothing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  export default Ember.Route.extend({\n  model() {\n    return Ember.RSVP.reject(\"FAIL\");\n  },\n\n  actions: {\n    error(reason) {\n      alert(reason); // \"FAIL\"\n\n      // Can transition to another route here, e.g.\n      // this.transitionTo('index');\n\n      // Uncomment the line below to bubble this error event:\n      // return true;\n    }\n  }\n});\n\n\n\nIn the above example, the error event would stop right at\nroute:good-for-nothing's error handler and not continue to bubble. To\nmake the event continue bubbling up to route:application, you can\nreturn true from the error handler.\nRecovering from Rejection\nRejected model promises halt transitions, but because promises are chainable,\nyou can catch promise rejects within the model hook itself and convert\nthem into fulfills that won't halt the transition.\n\n  \n    \n      app/routes/funky.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Route.extend({\n  model() {\n    return iHopeThisWorks().then(null, function() {\n      // Promise rejected, fulfill with some default value to\n      // use as the route's model and continue on with the transition\n      return { msg: \"Recovered from rejected promise\" };\n    });\n  }\n});\n\n\nbeforeModel and afterModel\nThe model hook covers many use cases for pause-on-promise transitions,\nbut sometimes you'll need the help of the related hooks beforeModel\nand afterModel. The most common reason for this is that if you're\ntransitioning into a route with a dynamic URL segment via {{link-to}} or\ntransitionTo (as opposed to a transition caused by a URL change),\nthe model for the route you're transitioning into will have already been\nspecified (e.g. {{#link-to 'article' article}} or\nthis.transitionTo('article', article)), in which case the model hook\nwon't get called. In these cases, you'll need to make use of either\nthe beforeModel or afterModel hook to house any logic while the\nrouter is still gathering all of the route's models to perform a\ntransition.\nbeforeModel\nEasily the more useful of the two, the beforeModel hook is called\nbefore the router attempts to resolve the model for the given route. In\nother words, it is called before the model hook gets called, or, if\nmodel doesn't get called, it is called before the router attempts to\nresolve any model promises passed in for that route.\n\nLike model, returning a promise from beforeModel will pause the\ntransition until it resolves, or will fire an error if it rejects.\n\nThe following is a far-from-exhaustive list of use cases in which\nbeforeModel is very handy:\n\n\nDeciding whether to redirect to another route before performing a\npotentially wasteful server query in model\nEnsuring that the user has an authentication token before proceeding\nonward to model\nLoading application code required by this route\n\n\n  \n    \n      app/routes/secret-articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  beforeModel() {\n    if (!this.controllerFor('auth').get('isLoggedIn')) {\n      this.transitionTo('login');\n    }\n  }\n});\n\n\n\nSee the API Docs for beforeModel\nafterModel\nThe afterModel hook is called after a route's model (which might be a\npromise) is resolved, and follows the same pause-on-promise semantics as\nmodel and beforeModel. It is passed the already-resolved model\nand can therefore perform any additional logic that\ndepends on the fully resolved value of a model.\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Route.extend({\n  model() {\n    // `this.store.findAll('article')` returns a promise-like object\n    // (it has a `then` method that can be used like a promise)\n    return this.store.findAll('article');\n  },\n  afterModel(articles) {\n    if (articles.get('length') === 1) {\n      this.transitionTo('article.show', articles.get('firstObject'));\n    }\n  }\n});\n\n\n\nYou might be wondering why we can't just put the afterModel logic\ninto the fulfill handler of the promise returned from model; the\nreason, as mentioned above, is that transitions initiated\nvia {{link-to}} or transitionTo likely already provided the\nmodel for this route, so model wouldn't be called in these cases.\n\nSee the API Docs for afterModel\nMore Resources\n\nEmbercasts: Client-side Authentication Part 2\nRC6 Blog Post describing these new features\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"bc0bfb567fedd41ba7b17f66df025608","fields":[{"name":"title","value":"Defining Your Routes","type":"string"},{"name":"url","value":"/routing/defining-your-routes/","type":"enum"},{"name":"body","value":"When your application starts, the router is responsible for displaying\ntemplates, loading data, and otherwise setting up application state.\nIt does so by matching the current URL to the routes that you've\ndefined.\n\nThe map method\nof your Ember application's router can be invoked to define URL mappings. When\ncalling map, you should pass a function that will be invoked with the value\nthis set to an object which you can use to create\nroutes.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('about', { path: '/about' });\n  this.route('favorites', { path: '/favs' });\n});\n\n\n\nNow, when the user visits /about, Ember.js will render the about\ntemplate. Visiting /favs will render the favorites template.\n\nHeads up! You get a few routes for free: the route:application and\nroute:index (corresponding to the / path).\nSee below for more details.\n\nYou can leave off the path if it is the same as the route\nname. In this case, the following is equivalent to the above example:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('about');\n  this.route('favorites', { path: '/favs' });\n});\n\n\n\nInside your templates, you can use {{link-to}} to navigate between\nroutes, using the name that you provided to the route method (or, in\nthe case of /, the name index).\n\n  1\n2\n3\n4\n5\n6\n\n  {{#link-to 'index'}}\u003cimg class=\"logo\"\u003e{{/link-to}}\n\n\u003cnav\u003e\n  {{#link-to 'about'}}About{{/link-to}}\n  {{#link-to 'favorites'}}Favorites{{/link-to}}\n\u003c/nav\u003e\n\n\n\nThe {{link-to}} helper will also add an active class to the link that\npoints to the currently active route.\n\nYou can customize the behavior of a route by creating an Ember.Route\nsubclass. For example, to customize what happens when your user visits\n/, create an route:index:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Route.extend({\n  setupController(controller) {\n    // Set the IndexController's `title`\n    controller.set('title', 'My App');\n  }\n});\n\n\n\ncontroller:index is the starting context for the index template.\nNow that you've set title, you can use it in the template:\n\n  1\n2\n\n  \u003c!-- get the title from the IndexController --\u003e\n\u003ch1\u003e{{title}}\u003c/h1\u003e\n\n\n\n(If you don't explicitly define an controller:index, Ember.js will\nautomatically generate one for you.)\n\nEmber.js automatically figures out the names of the routes and controllers based on\nthe name you pass to this.route.\n\n\n  \n  \n    URL\n    Route Name\n    \n      Controller\n      app/controllers/\n    \n    \n      Route\n      app/routes/\n    \n    \n      Template\n      app/templates/\n    \n  \n  \n  \n    /\n    index\n    ↳index.js\n    ↳index.js\n    ↳index.hbs\n  \n  \n    /about\n    about\n    ↳about.js\n    ↳about.js\n    ↳about.hbs\n  \n  \n    /favs\n    favorites\n    ↳favorites.js\n    ↳favorites.js\n    ↳favorites.hbs\n  \n\nNested Routes\nYou can define nested routes by passing a callback to this.route:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', { path: '/posts' }, function() {\n    this.route('new');\n  });\n});\n\n\n\nThis router creates these routes:\n\n\n  \n  \n   URL\n   Route Name\n   \n     Controller\n     app/controllers/\n   \n   \n     Route\n     app/routes/\n   \n   \n     Template\n     app/templates/\n   \n  \n  \n  \n    /\n    index\n    ↳index.js\n    ↳index.js\n    ↳index.js\n  \n  \n    N/A\n    posts\n    ↳posts.js\n    ↳posts.js\n    ↳posts.hbs\n  \n  \n    /posts\n    posts.index\n    ↳posts.js↳posts/index.js\n    ↳posts.js↳posts/index.js\n    ↳posts.hbs↳posts/index.hbs\n  \n  \n    /posts/new\n    posts.new\n    ↳posts.js↳posts/new.js\n    ↳posts.js↳posts/new.js\n    ↳posts.hbs↳posts/new.hbs\n  \n\n\nA nested route's names includes the names of its ancestors.\nIf you want to transition to a route (either\nvia transitionTo or {{#link-to}}), make sure to use the full route\nname (posts.new, not new).\n\nThat said, transitioning to posts or creating a link to posts is equivalent\nto transitioning to posts.index or linking to posts.index.\n\nVisiting / renders the index template, as you would expect.\n\nVisiting /posts is slightly different. It will first render the\nposts template. Then, it will render the posts/index template into the\nposts template's outlet.\n\nFinally, visiting /posts/new will first render the posts template,\nthen render the posts/new template into its outlet.\nResetting Nested Route Namespace\nWhen nesting routes, it may be beneficial for a child route to not inherit its ancestors name. This allows you to reference and reuse a given route in multiple route trees as well as keep the class name short. This is equivalent to the behavior of the now deprecated this.resource() function.\n\nYou can reset the current \"namespace\" with the aptly named resetNamespace: true option.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Router.map(function() {\n  this.route('post', { path: '/post/:post_id' }, function() {\n    this.route('edit');\n    this.route('comments', { resetNamespace: true }, function() {\n      this.route('new');\n    });\n  });\n});\n\n\n\nThis router creates five routes:\n\n\n  \n    \n    \n      URL\n      Route Name\n      Controller\n      Route\n      Template\n    \n    \n    \n      /\n      index\n      app/controllers/index\n      app/routes/index\n      app/templates/index\n    \n    \n      N/A\n      post\n      app/controllers/post\n      app/routes/post\n      app/templates/post\n    \n    \n      /post/:post_id2\n      post.index\n      app/controllers/post/index\n      app/routes/post/index\n      app/templates/post/index\n    \n    \n      /post/:post_id/edit\n      post.edit\n      app/controllers/post/edit\n      app/routes/post/edit\n      app/templates/post/edit\n    \n    \n      N/A\n      comments\n      app/controllers/comments\n      app/routes/comments\n      app/templates/comments\n    \n    \n      /post/:post_id/comments\n      comments.index\n      app/controllers/comments/index\n      app/routes/comments/index\n      app/templates/comments/index\n    \n    \n      /post/:post_id/comments/new\n      comments.new\n      app/controllers/comments/new\n      app/routes/comments/new\n      app/templates/comments/new\n    \n  \n\n\n2 :post_id is the post's id.  For a post with id = 1, the route will be:\n/post/1\n\nThe comments template will be rendered in the post outlet.\nAll templates under comments (comments/index and comments/new) will be rendered in the comments outlet.\n\nThe route, controller, and view class names for the comments resource are not prefixed with Post.\nMulti-word Model Names\nFor multi-word models all the names are camel cased except for the dynamic segment. For example, a model named BigMac would have a path of /bigMacs/:big_mac_id, route named bigMac, template named bigMac.\nDynamic Segments\nOne of the responsibilities of a route handler is to convert a URL\ninto a model.\n\nFor example, if we have the route this.route('posts');, our\nroute handler might look like this:\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return $.getJSON(\"/url/to/some/posts.json\");\n  }\n});\n\n\n\nThe posts template will then receive a list of all available posts as\nits context.\n\nBecause /posts represents a fixed model, we don't need any\nadditional information to know what to retrieve.  However, if we want a route\nto represent a single post, we would not want to have to hardcode every\npossible post into the router.\n\nEnter dynamic segments.\n\nA dynamic segment is a portion of a URL that starts with a : and is\nfollowed by an identifier.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('posts');\n  this.route('post', { path: '/post/:post_id' });\n});\n\n\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model(params) {\n    return $.getJSON(\"/url/to/some/posts/\" + params.post_id + \".json\");\n  }\n});\n\n\n\nIf your model does not use the id property in the URL, you should\ndefine a serialize method on your route:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('post', { path: '/posts/:post_slug' });\n});\n\n\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Route.extend({\n  model(params) {\n    // the server returns `{ slug: 'foo-post' }`\n    return Ember.$.getJSON('/posts/' + params.post_slug);\n  },\n\n  serialize(model) {\n    // this will make the URL `/posts/foo-post`\n    return { post_slug: model.get('slug') };\n  }\n});\n\n\n\nThe default serialize method inserts the model's id into the route's\ndynamic segment (in this case, :post_id).\nInitial routes\nA few routes are immediately available within your application:\n\n\nroute:application is entered when your app first boots up. It renders\nthe application template.\nroute:index is the default route, and will render the index template\nwhen the user visits / (unless / has been overridden by your own\ncustom route).\n\n\nThese routes are part of every application, so you don't need to\nspecify them in your app/router.js.\nWildcard / globbing routes\nYou can define wildcard routes that will match multiple routes. This could be used, for example,\nif you'd like a catch-all route which is useful when the user enters an incorrect URL not managed\nby your app.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('catchall', { path: '/*wildcard' });\n});\n\n\n\nLike all routes with a dynamic segment, you must provide a context when using a {{link-to}}\nor transitionTo to programatically enter this route.\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  actions: {\n    error() {\n      this.transitionTo('catchall', 'application-error');\n    }\n  }\n});\n\n\n\nWith this code, if an error bubbles up to the Application route, your application will enter\nthe catchall route and display /application-error in the URL.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c5953994735a42bd20744325ddcc8f3c","fields":[{"name":"title","value":"Generated Objects","type":"string"},{"name":"url","value":"/routing/generated-objects/","type":"enum"},{"name":"body","value":"As explained in the routing guide, whenever\nyou define a new path in your router, Ember.js attempts to find a\ncorresponding route, controller, and template, each named according to\nnaming conventions. If an implementation of any of these objects is not\nfound, appropriate objects will be generated for you.\nGenerated routes\nGiven you have the following route:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('posts');\n});\n\n\n\nWhen you navigate to /posts, Ember.js looks for route:posts.\nIf it doesn't find it, it will automatically generate route:posts for you.\nGenerated Controllers\nIf you navigate to route posts, Ember.js looks for a controller called controller:posts.\nIf you did not define it, one will be generated for you.\nGenerated Templates\nA route also expects a template. If you don't provide a template, an\nempty one will be generated for you.\n\nThe empty template includes an {{outlet}}, so nested routes will\nrender correctly even if the route does not explicitly provide a\ntemplate.\n\n  1\n\n  {{outlet}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e220634be1096dfda0635ee4cccf6449","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/routing/","type":"enum"},{"name":"body","value":"Routing\nAs users interact with your application, it moves through many\ndifferent states. Ember.js gives you helpful tools for managing\nthat state in a way that scales with your application.\n\nTo understand why this is important, imagine we are writing a web app\nfor managing a blog. At any given time, we should be able to answer\nquestions like: Is the user currently logged in? Are they an admin\nuser? What post are they looking at? Is the settings screen open?  Are\nthey editing the current post?\n\nIn Ember.js, each of the possible states in your application is\nrepresented by a URL. Because all of the questions we asked above—\nAre we logged in?  What post are we looking at? —are encapsulated by\nroute handlers for the URLs, answering them is both simple and accurate.\n\nAt any given time, your application has one or more active route\nhandlers. The active handlers can change for one of two reasons:\n\n\nThe user interacted with a component, which generated an event that caused\nthe URL to change.\nThe user changed the URL manually (e.g., via the back button), or the\npage was loaded for the first time.\n\n\nWhen the current URL changes, the newly active route handlers may do one\nor more of the following:\n\n\nConditionally redirect to a new URL.\nUpdate a controller so that it represents a particular model.\nChange the template on screen, or place a new template into an\nexisting outlet.\n\nLogging Route Changes\nAs your application increases in complexity, it can be helpful to see exactly what is going on with the router. To have Ember write out transition events to the log modify your project configuration:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_TRANSITIONS = true;\n\n\nSpecifying a Root URL\nIf your Ember application is one of multiple web applications served from the same domain, it may be necessary to indicate to the router what the root URL for your Ember application is. By default, Ember will assume it is served from the root of your domain.\n\nFor example, if you wanted to serve your blogging application from http://emberjs.com/blog/, it would be necessary to specify a root URL of /blog/.\n\nThis can be achieved by setting the rootURL on the router:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Ember.Router.extend({\n  rootURL: '/blog/'\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b73d2dfe086aa008696fa624bef07e0e","fields":[{"name":"title","value":"Loading / Error Substates","type":"string"},{"name":"url","value":"/routing/loading-and-error-substates/","type":"enum"},{"name":"body","value":"In addition to the techniques described in the\nAsynchronous Routing Guide,\nthe Ember Router provides powerful yet overridable\nconventions for customizing asynchronous transitions\nbetween routes by making use of error and loading\nsubstates.\nloading substates\nThe Ember Router allows you to return promises from the various\nbeforeModel/model/afterModel hooks in the course of a transition\n(described here).\nThese promises pause the transition until they fulfill, at which point\nthe transition will resume.\n\nConsider the following:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('foo', function() {\n    this.route('slow-model');\n  });\n});\n\n\n\n  \n    \n      app/routes/foo/slow-model.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return somePromiseThatTakesAWhileToResolve();\n  }\n});\n\n\n\nIf you navigate to foo/slow-model, and in the model hook,\nyou return an AJAX query promise that takes a long time to complete.\nDuring this time, your UI isn't really giving you any feedback as to\nwhat's happening; if you're entering this route after a full page\nrefresh, your UI will be entirely blank, as you have not actually\nfinished fully entering any route and haven't yet displayed any\ntemplates; if you're navigating to foo/slow-model from another\nroute, you'll continue to see the templates from the previous route\nuntil the model finish loading, and then, boom, suddenly all the\ntemplates for foo/slow-model load.\n\nSo, how can we provide some visual feedback during the transition?\n\nEmber provides a default implementation of the loading process that implements\nthe following loading substate behavior.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  Router.map(function() {\n  this.route('foo', function() {\n    this.route('bar', function() {\n      this.route('baz');\n    });\n  });\n});\n\n\n\nIf a route with the path foo.bar.baz returns a promise that doesn't immediately\nresolve, Ember will try to find a loading route in the hierarchy\nabove foo.bar.baz that it can transition into, starting with\nfoo.bar.baz's sibling:\n\n\nfoo.bar.loading\nfoo.loading\nloading\n\n\nEmber will find a loading route at the above location if either a) a\nRoute subclass has been defined for such a route, e.g.\n\n\napp/routes/foo/bar/loading.js\napp/routes/foo/loading.js\napp/routes/loading.js\n\n\nor b) a properly-named loading template has been found, e.g.\n\n\napp/templates/foo/bar/loading.hbs\napp/templates/foo/loading.hbs\napp/templates/loading.hbs\n\n\nDuring a slow asynchronous transition, Ember will transition into the\nfirst loading sub-state/route that it finds, if one exists. The\nintermediate transition into the loading substate happens immediately\n(synchronously), the URL won't be updated, and, unlike other transitions\nthat happen while another asynchronous transition is active, the\ncurrently active async transition won't be aborted.\n\nAfter transitioning into a loading substate, the corresponding template\nfor that substate, if present, will be rendered into the main outlet of\nthe parent route, e.g. foo.bar.loading's template would render into\nfoo.bar's outlet. (This isn't particular to loading routes; all\nroutes behave this way by default.)\n\nOnce the main async transition into foo.bar.baz completes, the loading\nsubstate will be exited, its template torn down, foo.bar.baz will be\nentered, and its templates rendered.\nEager vs. Lazy Async Transitions\nLoading substates are optional, but if you provide one,\nyou are essentially telling Ember that you\nwant this async transition to be \"eager\"; in the absence of destination\nroute loading substates, the router will \"lazily\" remain on the pre-transition route\nwhile all of the destination routes' promises resolve, and only fully\ntransition to the destination route (and renders its templates, etc.)\nonce the transition is complete. But once you provide a destination\nroute loading substate, you are opting into an \"eager\" transition, which\nis to say that, unlike the \"lazy\" default, you will eagerly exit the\nsource routes (and tear down their templates, etc) in order to\ntransition into this substate. URLs always update immediately unless the\ntransition was aborted or redirected within the same run loop.\n\nThis has implications on error handling, i.e. when a transition into\nanother route fails, a lazy transition will (by default) just remain on the\nprevious route, whereas an eager transition will have already left the\npre-transition route to enter a loading substate.\nThe loading event\nIf you return a promise from the various beforeModel/model/afterModel hooks,\nand it doesn't immediately resolve, a loading event will be fired on that route\nand bubble upward to route:application.\n\nIf the loading handler is not defined at the specific route,\nthe event will continue to bubble above a transition's pivot\nroute, providing the route:application the opportunity to manage it.\n\n  \n    \n      app/routes/foo-slow-model.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  export default Ember.Route.extend({\n  model() {\n    return somePromiseThatTakesAWhileToResolve();\n  },\n  actions: {\n    loading(transition, originRoute) {\n      //displayLoadingSpinner();\n      this.router.one('didTransition', function () {\n        // hideLoadingSpinner();\n      });\n\n      // Return true to bubble this event to `FooRoute`\n      // or `ApplicationRoute`.\n      return true;\n    }\n  }\n});\n\n\n\nThe loading handler provides the ability to decide what to do during\nthe loading process. If the last loading handler is not defined\nor returns true, Ember will perform the loading substate behavior.\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Route.extend({\n  actions: {\n    loading(transition, originRoute) {\n      displayLoadingSpinner();\n\n      // substate implementation when returning `true`\n      return true;\n    }\n  }\n});\n\n\nerror substates\nEmber provides an analogous approach to loading substates in\nthe case of errors encountered during a transition.\n\nSimilar to how the default loading event handlers are implemented,\nthe default error handlers will look for an appropriate error substate to\nenter, if one can be found.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('articles', function() {\n    this.route('overview');\n  });\n});\n\n\n\nFor instance, an thrown error or rejected promise returned from\nroute:articles/overview's #model hook (or beforeModel or afterModel)\nwill look for:\n\n\nEither route:articles/error or articles/error template\nEither route:error or error template\n\n\nIf one of the above is found, the router will immediately transition into\nthat substate (without updating the URL). The \"reason\" for the error\n(i.e. the exception thrown or the promise reject value) will be passed\nto that error state as its model.\n\nIf no viable error substates can be found, an error message will be\nlogged.\nerror substates with dynamic segments\nRoutes with dynamic segments are often mapped to a mental model of \"two\nseparate levels.\" Take for example:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('foo', { path: '/foo/:id' }, function() {\n    this.route('baz');\n  });\n});\n\n\n\n  \n    \n      app/routes/foo.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  model(params) {\n    return new Ember.RSVP.Promise(function(resolve, reject) {\n       reject(\"Error\");\n    });\n  }\n});\n\n\n\nIn the URL hierarchy you would visit /foo/12 which would result in rendering\nthe foo template into the application template's outlet. In the event of\nan error while attempting to load the foo route you would also render the\ntop-level error template into the application template's outlet. This is\nintentionally parallel behavior as the foo route is never successfully\nentered. In order to create a foo scope for errors and render foo/error\ninto foo's outlet you would need to split the dynamic segment:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  Router.map(function() {\n  this.route('foo', {path: '/foo'}, function() {\n    this.route('elem', {path: ':id'}, function() {\n      this.route('baz');\n    });\n  });\n});\n\n\n\nExample JSBin\nThe error event\nIf route:articles/overview's model hook returns a promise that rejects (for\ninstance the server returned an error, the user isn't logged in,\netc.), an error event will fire on route:articles/overview and bubble upward.\nThis error event can be handled and used to display an error message,\nredirect to a login page, etc.\n\n  \n    \n      app/routes/articles-overview.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  export default Ember.Route.extend({\n  model(params) {\n    return new Ember.RSVP.Promise(function(resolve, reject) {\n       reject(\"Error\");\n    });\n  },\n  actions: {\n    error(error, transition) {\n\n      if (error \u0026\u0026 error.status === 400) {\n        // error substate and parent routes do not handle this error\n        return this.transitionTo('modelNotFound');\n      }\n\n      // Return true to bubble this event to any parent route.\n      return true;\n    }\n  }\n});\n\n\n\nAnalogous to the loading event, you could manage the error event\nat the Application level to perform any application logic and based on the\nresult of the last error handler, Ember will decide if substate behavior\nmust be performed or not.\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.Route.extend({\n  actions: {\n    error(error, transition) {\n\n      // Manage your errors\n      Ember.onerror(error);\n\n      // substate implementation when returning `true`\n      return true;\n\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"73217f11fed62d7b09ccc1c4378f49e7","fields":[{"name":"title","value":"Preventing and Retrying Transitions","type":"string"},{"name":"url","value":"/routing/preventing-and-retrying-transitions/","type":"enum"},{"name":"body","value":"During a route transition, the Ember Router passes a transition\nobject to the various hooks on the routes involved in the transition.\nAny hook that has access to this transition object has the ability\nto immediately abort the transition by calling transition.abort(),\nand if the transition object is stored, it can be re-attempted at a\nlater time by calling transition.retry().\nPreventing Transitions via willTransition\nWhen a transition is attempted, whether via {{link-to}}, transitionTo,\nor a URL change, a willTransition action is fired on the currently\nactive routes. This gives each active route, starting with the leaf-most\nroute, the opportunity to decide whether or not the transition should occur.\n\nImagine your app is in a route that's displaying a complex form for the user\nto fill out and the user accidentally navigates backwards. Unless the\ntransition is prevented, the user might lose all of the progress they\nmade on the form, which can make for a pretty frustrating user experience.\n\nHere's one way this situation could be handled:\n\n  \n    \n      app/routes/form.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export default Ember.Route.extend({\n  actions: {\n    willTransition(transition) {\n      if (this.controller.get('userHasEnteredData') \u0026\u0026\n          !confirm(\"Are you sure you want to abandon progress?\")) {\n        transition.abort();\n      } else {\n        // Bubble the `willTransition` action so that\n        // parent routes can decide whether or not to abort.\n        return true;\n      }\n    }\n  }\n});\n\n\n\nWhen the user clicks on a {{link-to}} helper, or when the app initiates a\ntransition by using transitionTo, the transition will be aborted and the URL\nwill remain unchanged. However, if the browser back button is used to\nnavigate away from route:form, or if the user manually changes the URL, the\nnew URL will be navigated to before the willTransition action is\ncalled. This will result in the browser displaying the new URL, even if\nwillTransition calls transition.abort().\nAborting Transitions Within model, beforeModel, afterModel\nThe model, beforeModel, and afterModel hooks described in\nAsynchronous Routing\neach get called with a transition object. This makes it possible for\ndestination routes to abort attempted transitions.\n\n  \n    \n      app/routes/disco.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  beforeModel(transition) {\n    if (new Date() \u003e new Date(\"January 1, 1980\")) {\n      alert(\"Sorry, you need a time machine to enter this route.\");\n      transition.abort();\n    }\n  }\n});\n\n\nStoring and Retrying a Transition\nAborted transitions can be retried at a later time. A common use case\nfor this is having an authenticated route redirect the user to a login\npage, and then redirecting them back to the authenticated route once\nthey've logged in.\n\n  \n    \n      app/routes/some-authenticated.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Route.extend({\n  beforeModel(transition) {\n    if (!this.controllerFor('auth').get('userIsLoggedIn')) {\n      var loginController = this.controllerFor('login');\n      loginController.set('previousTransition', transition);\n      this.transitionTo('login');\n    }\n  }\n});\n\n\n\n  \n    \n      app/controllers/login.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Controller.extend({\n  actions: {\n    login() {\n      // Log the user in, then reattempt previous transition if it exists.\n      var previousTransition = this.get('previousTransition');\n      if (previousTransition) {\n        this.set('previousTransition', null);\n        previousTransition.retry();\n      } else {\n        // Default back to homepage\n        this.transitionToRoute('index');\n      }\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a10da78f7f24528b1e5d721dbc5e424b","fields":[{"name":"title","value":"Query Parameters","type":"string"},{"name":"url","value":"/routing/query-params/","type":"enum"},{"name":"body","value":"Query parameters are optional key-value pairs that appear to the right of\nthe ? in a URL. For example, the following URL has two query params,\nsort and page, with respective values ASC and 2:\n\n  1\n\n  http://example.com/articles?sort=ASC\u0026page=2\n\n\n\nQuery params allow for additional application state to be serialized\ninto the URL that can't otherwise fit into the path of the URL (i.e.\neverything to the left of the ?). Common use cases for query params include\nrepresenting the current page number in a paginated collection, filter criteria, or sorting criteria.\nSpecifying Query Parameters\nQuery params are declared on route-driven controllers. For example, to\nconfigure query params that are active within the articles route,\nthey must be declared on controller:articles.\n\nTo add a category\nquery parameter that will filter out all the articles that haven't\nbeen categorized as popular we'd specify 'category'\nas one of controller:article's queryParams:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  queryParams: ['category'],\n  category: null\n});\n\n\n\nThis sets up a binding between the category query param in the URL,\nand the category property on controller:articles. In other words,\nonce the articles route has been entered, any changes to the\ncategory query param in the URL will update the category property\non controller:articles, and vice versa.\n\nNow we just need to define a computed property of our category-filtered\narray that the articles template will render:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Controller.extend({\n  queryParams: ['category'],\n  category: null,\n\n  filteredArticles: Ember.computed('category', 'model', function() {\n    var category = this.get('category');\n    var articles = this.get('model');\n\n    if (category) {\n      return articles.filterBy('category', category);\n    } else {\n      return articles;\n    }\n  })\n});\n\n\n\nWith this code, we have established the following behaviors:\n\n\nIf the user navigates to /articles, category will be null, so\nthe articles won't be filtered.\nIf the user navigates to /articles?category=recent,\ncategory will be set to \"recent\", so articles will be filtered.\nOnce inside the articles route, any changes to the category\nproperty on controller:articles will cause the URL to update the\nquery param. By default, a query param property change won't cause a\nfull router transition (i.e. it won't call model hooks and\nsetupController, etc.); it will only update the URL.\n\nlink-to Helper\nThe link-to helper supports specifying query params using the\nquery-params subexpression helper.\n\n  1\n2\n3\n4\n5\n\n  // Explicitly set target query params\n{{#link-to 'posts' (query-params direction=\"asc\")}}Sort{{/link-to}}\n\n// Binding is also supported\n{{#link-to 'posts' (query-params direction=otherDirection)}}Sort{{/link-to}}\n\n\n\nIn the above examples, direction is presumably a query param property\non the controller:post, but it could also refer to a direction property\non any of the controllers associated with the posts route hierarchy,\nmatching the leaf-most controller with the supplied property name.\n\nThe link-to helper takes into account query parameters when determining\nits \"active\" state, and will set the class appropriately. The active state\nis determined by calculating whether the query params end up the same after\nclicking a link. You don't have to supply all of the current,\nactive query params for this to be true.\ntransitionTo\nRoute#transitionTo and Controller#transitionToRoute\naccept a final argument, which is an object with the key queryParams.\n\n  \n    \n      app/routes/some-route.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  this.transitionTo('post', object, {queryParams: {showDetails: true}});\nthis.transitionTo('posts', {queryParams: {sort: 'title'}});\n\n// if you just want to transition the query parameters without changing the route\nthis.transitionTo({queryParams: {direction: 'asc'}});\n\n\n\nYou can also add query params to URL transitions:\n\n  \n    \n      app/routes/some-route.js\n    \n  \n\n  1\n\n  this.transitionTo(\"/posts/1?sort=date\u0026showDetails=true\");\n\n\nOpting into a full transition\nArguments provided to transitionTo\nor link-to only correspond to a change in query param values,\nand not a change in the route hierarchy, it is not considered a\nfull transition, which means that hooks like model and\nsetupController won't fire by default, but rather only\ncontroller properties will be updated with new query param values, as\nwill the URL.\n\nBut some query param changes necessitate loading data from the server,\nin which case it is desirable to opt into a full-on transition. To opt\ninto a full transition when a controller query param property changes,\nyou can use the optional queryParams configuration hash on the Route\nassociated with that controller, and set that query param's\nrefreshModel config property to true:\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  export default Ember.Route.extend({\n  queryParams: {\n    category: {\n      refreshModel: true\n    }\n  },\n  model(params) {\n    // This gets called upon entering 'articles' route\n    // for the first time, and we opt into refiring it upon\n    // query param changes by setting `refreshModel:true` above.\n\n    // params has format of { category: \"someValueOrJustNull\" },\n    // which we can just forward to the server.\n    return this.store.query('articles', params);\n  }\n});\n\n\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  queryParams: ['category'],\n  category: null\n});\n\n\nUpdate URL with replaceState instead\nBy default, Ember will use pushState to update the URL in the\naddress bar in response to a controller query param property change, but\nif you would like to use replaceState instead (which prevents an\nadditional item from being added to your browser's history), you can\nspecify this on the Route's queryParams config hash, e.g. (continued\nfrom the example above):\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  queryParams: {\n    category: {\n      replace: true\n    }\n  }\n});\n\n\n\nNote that the name of this config property and its default value of\nfalse is similar to the link-to helper's, which also lets\nyou opt into a replaceState transition via replace=true.\nMap a controller's property to a different query param key\nBy default, specifying foo as a controller query param property will\nbind to a query param whose key is foo, e.g. ?foo=123. You can also map\na controller property to a different query param key using the\nfollowing configuration syntax:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Controller.extend({\n  queryParams: {\n    category: \"articles_category\"\n  },\n  category: null\n});\n\n\n\nThis will cause changes to the controller:articles's category\nproperty to update the articles_category query param, and vice versa.\n\nNote that query params that require additional customization can\nbe provided along with strings in the queryParams array.\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Controller.extend({\n  queryParams: [ \"page\", \"filter\", {\n    category: \"articles_category\"\n  }],\n  category: null,\n  page: 1,\n  filter: \"recent\"\n});\n\n\nDefault values and deserialization\nIn the following example, the controller query param property page is\nconsidered to have a default value of 1.\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  queryParams: 'page',\n  page: 1\n});\n\n\n\nThis affects query param behavior in two ways:\n\n\nQuery param values are cast to the same datatype as the default\nvalue, e.g. a URL change from /?page=3 to /?page=2 will set\ncontroller:articles's page property to the number 2, rather than\nthe string \"2\". The same also applies to boolean default values.\nWhen a controller's query param property is currently set to its\ndefault value, this value won't be serialized into the URL. So in the\nabove example, if page is 1, the URL might look like /articles,\nbut once someone sets the controller's page value to 2, the URL\nwill become /articles?page=2.\n\nSticky Query Param Values\nBy default, query param values in Ember are \"sticky\", in that if you\nmake changes to a query param and then leave and re-enter the route, the\nnew value of that query param will be preserved (rather than reset to\nits default). This is a particularly handy default for preserving sort/filter\nparameters as you navigate back and forth between routes.\n\nFurthermore, these sticky query param values are remembered/restored\naccording to the model loaded into the route. So, given a team route\nwith dynamic segment /:team_name and controller query param \"filter\",\nif you navigate to /badgers and filter by \"rookies\", then navigate\nto /bears and filter by \"best\", and then navigate to /potatoes and\nfilter by \"lamest\", then given the following nav bar links,\n\n  1\n2\n3\n\n  {{#link-to 'team' 'badgers'}}Badgers{{/link-to}}\n{{#link-to 'team' 'bears'   }}Bears{{/link-to}}\n{{#link-to 'team' 'potatoes'}}Potatoes{{/link-to}}\n\n\n\nthe generated links would be\n\n  1\n2\n3\n\n  \u003ca href=\"/badgers?filter=rookies\"\u003eBadgers\u003c/a\u003e\n\u003ca href=\"/bears?filter=best\"\u003eBears\u003c/a\u003e\n\u003ca href=\"/potatoes?filter=lamest\"\u003ePotatoes\u003c/a\u003e\n\n\n\nThis illustrates that once you change a query param, it is stored and\ntied to the model loaded into the route.\n\nIf you wish to reset a query param, you have two options:\n\n\nexplicitly pass in the default value for that query param into\nlink-to or transitionTo\nuse the Route.resetController hook to set query param values back to\ntheir defaults before exiting the route or changing the route's model\n\n\nIn the following example, the controller's page query param is reset\nto 1, while still scoped to the pre-transition ArticlesRoute model.\nThe result of this is that all links pointing back into the exited route\nwill use the newly reset value 1 as the value for the page query\nparam.\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  resetController (controller, isExiting, transition) {\n    if (isExiting) {\n      // isExiting would be false if only the route's model was changing\n      controller.set('page', 1);\n    }\n  }\n});\n\n\n\nIn some cases, you might not want the sticky query param value to be\nscoped to the route's model but would rather reuse a query param's value\neven as a route's model changes. This can be accomplished by setting the\nscope option to \"controller\" within the controller's queryParams\nconfig hash:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Controller.extend({\n  queryParams: [{\n    showMagnifyingGlass: {\n      scope: \"controller\"\n    }\n  }]\n});\n\n\n\nThe following demonstrates how you can override both the scope and the\nquery param URL key of a single controller query param property:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Controller.extend({\n  queryParams: [ \"page\", \"filter\",\n    {\n      showMagnifyingGlass: {\n        scope: \"controller\",\n        as: \"glass\",\n      }\n    }\n  ]\n});\n\n\nExamples\n\nSearch queries\nSort: client-side, no refiring of model hook\nSort: server-side, refire model hook\nPagination + Sorting\nBoolean values. False value removes QP from URL\nGlobal query params on app route\nOpt-in to full transition via refresh()\nupdate query params by changing controller QP property\nupdate query params with replaceState by changing controller QP property\nw/ {{partial}} helper for easy tabbing\nlink-to with no route name, only QP change\nComplex: serializing textarea content into URL (and subexpressions))\nArrays\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"088e52d28fa44f8c93ca2f490bad93c3","fields":[{"name":"title","value":"Redirecting","type":"string"},{"name":"url","value":"/routing/redirection/","type":"enum"},{"name":"body","value":"Transitioning and Redirecting\nCalling transitionTo from a route or transitionToRoute from a controller\nwill stop any transition currently in progress and start a new one, functioning\nas a redirect. transitionTo takes parameters and behaves exactly like the link-to helper:\n\n\nIf you transition into a route without dynamic segments that route's model hook\nwill always run.\nIf the new route has dynamic segments, you need to pass either a model or an identifier for each segment.\nPassing a model will skip that segment's model hook.  Passing an identifier will run the model hook and you'll be able to access the identifier in the params. See Links for more detail.\n\nBefore the model is known\nIf you want to redirect from one route to another, you can do the transition in\nthe beforeModel hook of your route handler.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('posts');\n});\n\n\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  beforeModel() {\n    this.transitionTo('posts');\n  }\n});\n\n\nAfter the model is known\nIf you need information about the current model in order to decide about\nredirection, you should either use the afterModel or the redirect hook.\nThey receive the resolved model as the first parameter and the transition as\nthe second one, and thus function as aliases. (In fact, the default\nimplementation of afterModel just calls redirect.)\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('posts');\n  this.route('post', { path: '/post/:post_id' });\n});\n\n\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  afterModel(posts, transition) {\n    if (posts.get('length') === 1) {\n      this.transitionTo('post', posts.get('firstObject'));\n    }\n  }\n});\n\n\n\nWhen transitioning to the posts route if it turns out that there is only one post,\nthe current transition will be aborted in favor of redirecting to the PostRoute\nwith the single post object being its model.\nBased on other application state\nYou can conditionally transition based on some other application state.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Router.map(function() {\n  this.route('topCharts', function() {\n    this.route('choose', { path: '/' });\n    this.route('albums');\n    this.route('songs');\n    this.route('artists');\n    this.route('playlists');\n  });\n});\n\n\n\n  \n    \n      app/routes/top-charts/choose.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Route.extend({\n  beforeModel() {\n    var lastFilter = this.controllerFor('application').get('lastFilter');\n    this.transitionTo('topCharts.' + (lastFilter || 'songs'));\n  }\n});\n\n\n\n  \n    \n      app/routes/filter.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  // Superclass to be used by all of the filter routes: albums, songs, artists, playlists\nexport default Ember.Route.extend({\n  activate() {\n    var controller = this.controllerFor('application');\n    controller.set('lastFilter', this.templateName);\n  }\n});\n\n\n\nIn this example, navigating to the / URL immediately transitions into\nthe last filter URL that the user was at. The first time, it transitions\nto the /songs URL.\n\nYour route can also choose to transition only in some cases. If the\nbeforeModel hook does not abort or transition to a new route, the remaining\nhooks (model, afterModel, setupController, renderTemplate) will execute\nas usual.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b1db196c912b89d4bb0d82325bb9137c","fields":[{"name":"title","value":"Rendering a Template","type":"string"},{"name":"url","value":"/routing/rendering-a-template/","type":"enum"},{"name":"body","value":"One of the most important jobs of a route handler is rendering the\nappropriate template to the screen.\n\nBy default, a route handler will render the template into the closest\nparent with a template.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('post');\n});\n\n\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n\n  export default Ember.Route.extend();\n\n\n\nIf you want to render a template other than the one associated with the\nroute handler, implement the renderTemplate hook:\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  renderTemplate() {\n    this.render('favoritePost');\n  }\n});\n\n\n\nIf you want to use a different controller than the route handler's\ncontroller, pass the controller's name in the controller option:\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  renderTemplate() {\n    this.render({ controller: 'favoritePost' });\n  }\n});\n\n\n\nEmber allows you to name your outlets. For instance, this code allows\nyou to specify two outlets with distinct names:\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n2\n\n  \u003cdiv class=\"toolbar\"\u003e{{outlet \"toolbar\"}}\u003c/div\u003e\n\u003cdiv class=\"sidebar\"\u003e{{outlet \"sidebar\"}}\u003c/div\u003e\n\n\n\nSo, if you want to render your posts into the sidebar outlet, use code\nlike this:\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  renderTemplate() {\n    this.render({ outlet: 'sidebar' });\n  }\n});\n\n\n\nAll of the options described above can be used together in whatever\ncombination you'd like:\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.Route.extend({\n  renderTemplate() {\n    var controller = this.controllerFor('favoritePost');\n\n    // Render the `favoritePost` template into\n    // the outlet `post`, and use the `favoritePost`\n    // controller.\n    this.render('favoritePost', {\n      outlet: 'post',\n      controller: controller\n    });\n  }\n});\n\n\n\nIf you want to render two different templates into outlets of two different rendered templates of a route:\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export default Ember.Route.extend({\n  renderTemplate() {\n    this.render('favoritePost', {   // the template to render\n      into: 'posts',                // the template to render into\n      outlet: 'post',              // the name of the outlet in that template\n      controller: 'blogPost'        // the controller to use for the template\n    });\n    this.render('comments', {\n      into: 'favoritePost',\n      outlet: 'comment',\n      controller: 'blogPost'\n    });\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d03c0729ed2df89a208ead1f07dcf9fd","fields":[{"name":"title","value":"Setting Up a Controller","type":"string"},{"name":"url","value":"/routing/setting-up-a-controller/","type":"enum"},{"name":"body","value":"Changing the URL may also change which template is displayed on\nscreen. Templates, however, are usually only useful if they have some\nsource of information to display.\n\nIn Ember.js, a template retrieves information to display from a\ncontroller.\n\nTo tell the controller which model to present, set its\nmodel property in the route handler's setupController hook.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('post', { path: '/posts/:post_id' });\n});\n\n\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  // The code below is the default behavior, so if this is all you\n  // need, you do not need to provide a setupController implementation\n  // at all.\n  setupController: function(controller, model) {\n    controller.set('model', model);\n  }\n});\n\n\n\nThe setupController hook receives the route handler's associated\ncontroller as its first argument. In this case, the PostRoute's\nsetupController receives the application's instance of\ncontroller:posts.\n\nTo specify a controller other than the default, set the route's\ncontrollerName property:\n\n  \n    \n      app/routes/special-post.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Route.extend({\n  controllerName: 'post'\n});\n\n\n\nAs a second argument, it receives the route handler's model. For more\ninformation, see Specifying a Route's Model.\n\nThe default setupController hook sets the model property of the\nassociated controller to the route handler's model.\n\nIf you want to configure a controller other than the controller\nassociated with the route handler, use the controllerFor method:\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  setupController: function(controller, model) {\n    this.controllerFor('topPost').set('model', model);\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d94b756c7278f11f9a951d1a47d8640f","fields":[{"name":"title","value":"Specifying a Route's Model","type":"string"},{"name":"url","value":"/routing/specifying-a-routes-model/","type":"enum"},{"name":"body","value":"Templates in your application are backed by models. But how do templates\nknow which model they should display?\n\nFor example, if you have a photos template, how does it know which\nmodel to render?\n\nThis is one of the jobs of an Ember.Route. You can tell a template\nwhich model it should render by defining a route with the same name as\nthe template, and implementing its model hook.\n\nFor example, to provide some model data to the photos template, we\nwould define an route:photos object:\n\n  \n    \n      app/routes/photos.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Route.extend({\n  model() {\n    return [{\n      title: \"Tomster\",\n      url: \"http://emberjs.com/images/about/ember-productivity-sm.png\"\n    }, {\n      title: \"Eiffel Tower\",\n      url: \"http://emberjs.com/images/about/ember-structure-sm.png\"\n    }];\n  }\n});\n\n\n\nJS Bin\nAsynchronously Loading Models\nIn the above example, the model data was returned synchronously from the\nmodel hook. This means that the data was available immediately and\nyour application did not need to wait for it to load, in this case\nbecause we immediately returned an array of hardcoded data.\n\nOf course, this is not always realistic. Usually, the data will not be\navailable synchronously, but instead must be loaded asynchronously over\nthe network. For example, we may want to retrieve the list of photos\nfrom a JSON API available on our server.\n\nIn cases where data is available asynchronously, you can just return a\npromise from the model hook, and Ember will wait until that promise is\nresolved before rendering the template.\n\nIf you're unfamiliar with promises, the basic idea is that they are\nobjects that represent eventual values. For example, if you use jQuery's\ngetJSON() method, it will return a promise for the JSON that is\neventually returned over the network. Ember uses this promise object to\nknow when it has enough data to continue rendering.\n\nFor more about promises, see A Word on\nPromises\nin the Asynchronous Routing guide.\n\nLet's look at an example in action. Here's a route that loads the most\nrecent pull requests sent to Ember.js on GitHub:\n\n  \n    \n      app/routes/pull-requests.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return Ember.$.getJSON('https://api.github.com/repos/emberjs/ember.js/pulls');\n  }\n});\n\n\n\nWhile this example looks like it's synchronous, making it easy to read\nand reason about, it's actually completely asynchronous. That's because\njQuery's getJSON() method returns a promise. Ember will detect the\nfact that you've returned a promise from the model hook, and wait\nuntil that promise resolves to render the pullRequests template.\n\n(For more information on jQuery's XHR functionality, see\njQuery.ajax in the jQuery\ndocumentation.)\n\nBecause Ember supports promises, it can work with any persistence\nlibrary that uses them as part of its public API. You can also use many\nof the conveniences built in to promises to make your code even nicer.\n\nFor example, imagine if we wanted to modify the above example so that\nthe template only displayed the three most recent pull requests. We can\nrely on promise chaining to modify the data returned from the JSON\nrequest before it gets passed to the template:\n\n  \n    \n      app/routes/pull-requests.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  model() {\n    var url = 'https://api.github.com/repos/emberjs/ember.js/pulls';\n    return Ember.$.getJSON(url).then(function(data) {\n      return data.splice(0, 3);\n    });\n  }\n});\n\n\nSetting Up Controllers with the Model\nSo what actually happens with the value you return from the model\nhook?\n\nBy default, the value returned from your model hook will be assigned\nto the model property of the associated controller. For example, if your\nroute:posts returns an object from its model hook, that object\nwill be set as the model property of the controller:posts.\n\n(This, under the hood, is how templates know which model to render: they\nlook at their associated controller's model property. For example, the\nphotos template will render whatever the controller:photos's\nmodel property is set to.)\n\nSee the Setting Up a Controller guide to learn how to change this\ndefault behavior. Note that if you override the default behavior and do\nnot set the model property on a controller, your template will not\nhave any data to render!\nDynamic Models\nSome routes always display the same model. For example, the /photos\nroute will always display the same list of photos available in the\napplication. If your user leaves this route and comes back later, the\nmodel does not change.\n\nHowever, you will often have a route whose model will change depending\non user interaction. For example, imagine a photo viewer app. The\n/photos route will render the photos template with the list of\nphotos as the model, which never changes. But when the user clicks on a\nparticular photo, we want to display that model with the photo\ntemplate. If the user goes back and clicks on a different photo, we want\nto display the photo template again, this time with a different model.\n\nIn cases like this, it's important that we include some information in\nthe URL about not only which template to display, but also which model.\n\nIn Ember, this is accomplished by defining routes with dynamic segments.\n\nA dynamic segment is a part of the URL that is filled in by the current\nmodel's ID. Dynamic segments always start with a colon (:). Our photo\nexample might have its photo route defined like this:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('photo', { path: '/photos/:photo_id' });\n});\n\n\n\nIn this example, the photo route has a dynamic segment :photo_id.\nWhen the user goes to the photo route to display a particular photo\nmodel (usually via the {{link-to}} helper), that model's ID will be\nplaced into the URL automatically.\n\nSee Links for more information about linking\nto a route with a model using the {{link-to}} helper.\n\nFor example, if you transitioned to the photo route with a model whose\nid property was 47, the URL in the user's browser would be updated\nto:\n\n  1\n\n  /photos/47\n\n\n\nWhat happens if the user visits your application directly with a URL\nthat contains a dynamic segment? For example, they might reload the\npage, or send the link to a friend, who clicks on it. At that point,\nbecause we are starting the application up from scratch, the actual\nJavaScript model object to display has been lost; all we have is the ID\nfrom the URL.\n\nLuckily, Ember will extract any dynamic segments from the URL for\nyou and pass them as a hash to the model hook as the first argument:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('photo', { path: '/photos/:photo_id' });\n});\n\n\n\n  \n    \n      app/routes/photo.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model(params) {\n    return Ember.$.getJSON('/photos/'+params.photo_id);\n  }\n});\n\n\n\nIn the model hook for routes with dynamic segments, it's your job to\nturn the ID (something like 47 or post-slug) into a model that can\nbe rendered by the route's template. In the above example, we use the\nphoto's ID (params.photo_id) to construct a URL for the JSON\nrepresentation of that photo. Once we have the URL, we use jQuery to\nreturn a promise for the JSON model data.\n\nNote: A route with a dynamic segment will only have its model hook called\nwhen it is entered via the URL. If the route is entered through a transition\n(e.g. when using the link-to Handlebars helper), then a model context is\nalready provided and the hook is not executed. Routes without dynamic segments\nwill always execute the model hook.\nRefreshing your model\nIf your data represented by your model is being updated frequently, you may\nwant to refresh it periodically:\n\nJS Bin\n\nThe controller can send an action to the Route; in this example above, the\nIndexController exposes an action getLatest which sends the route an\naction called invalidateModel. Calling the route's refresh method will force\nEmber to execute the model hook again.\nEmber Data\nMany Ember developers use a model library to make finding and saving\nrecords easier than manually managing Ajax calls. In particular, using a\nmodel library allows you to cache records that have been loaded,\nsignificantly improving the performance of your application.\n\nOne popular model library built for Ember is Ember Data. To learn more\nabout using Ember Data to manage your models, see the\nModels guide.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6e746c1a547709a4f7e74f0ab1401f16","fields":[{"name":"title","value":"Specifying the URL Type","type":"string"},{"name":"url","value":"/routing/specifying-the-location-api/","type":"enum"},{"name":"body","value":"By default the Router uses the browser's hash to load the starting state of your\napplication and will keep it in sync as you move around. At present, this relies\non a hashchange event existing in the browser.\n\nGiven the following router, entering /#/posts/new will take you to the posts.new\nroute.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', function() {\n    this.route('new');\n  });\n});\n\n\n\nIf you want to remove the #/ at the beginning so that the URL is simply /posts/new,\nyou can tell the Router to use the browser's history API.\n\nKeep in mind that your server must serve the Ember app from all the URLs defined in your\nRouter.map function.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Ember.Router.extend({\n  location: 'history'\n});\n\n\n\nYou can tell Ember to use the best location option based on browser support by\nspecifying auto for the location. Ember will then use history if supported\nby the user's browser and fall back to hash otherwise.\n\nFinally, if you don't want the browser's URL to interact with your application\nat all, you can disable the location API entirely. This is useful for\ntesting, or when you need to manage state with your Router, but temporarily\ndon't want it to muck with the URL (for example when you embed your\napplication in a larger page).\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Ember.Router.extend({\n  location: 'none'\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"1b11151882558c3e878b1c432610d998","fields":[{"name":"title","value":"Actions","type":"string"},{"name":"url","value":"/templates/actions/","type":"enum"},{"name":"body","value":"The {{action}} Helper\nYour app will often need a way to let users interact with controls that\nchange application state. For example, imagine that you have a template\nthat shows a blog post, and supports expanding the post with additional\ninformation.\n\nYou can use the {{action}} helper to make an HTML element clickable.\nWhen a user clicks the element, the named event will be sent to your\napplication.\n\n  \n    \n      app/templates/post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  \u003cdiv class='intro'\u003e\n  {{intro}}\n\u003c/div\u003e\n\n{{#if isExpanded}}\n  \u003cdiv class='body'\u003e{{body}}\u003c/div\u003e\n  \u003cbutton {{action 'contract'}}\u003eContract\u003c/button\u003e\n{{else}}\n  \u003cbutton {{action 'expand'}}\u003eShow More...\u003c/button\u003e\n{{/if}}\n\n\n\n  \n    \n      app/controllers/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  export default Ember.Controller.extend({\n  intro: Ember.computed.alias('model.intro'),\n  body: Ember.computed.alias('model.body'),\n\n  // initial value\n  isExpanded: false,\n\n  actions: {\n    expand() {\n      this.set('isExpanded', true);\n    },\n\n    contract() {\n      this.set('isExpanded', false);\n    }\n  }\n});\n\n\n\nNote that actions may be attached to any element of the DOM, but not all\nrespond to the click event. For example, if an action is attached to an a\nlink without an href attribute, or to a div, some browsers won't execute\nthe associated function. If it's really needed to define actions over such\nelements, a CSS workaround exists to make them clickable, cursor: pointer.\nFor example:\n\n  1\n2\n3\n\n  [data-ember-action] {\n  cursor: pointer;\n}\n\n\nAction Bubbling\nBy default, the {{action}} helper triggers a method on the template's\ncontroller, as illustrated above.\n\nIf the controller does not implement a method with the same name as the\naction in its actions object, the action will be sent to the router, where\nthe currently active leaf route will be given a chance to handle the action.\n\nRoutes and controllers that handle actions must place action handlers\ninside an actions hash. Even if a route has a method with the same name\nas the actions, it will not be triggered unless it is inside an actions hash.\nIn the case of a controller, while there is deprecated support for triggering\na method directly on the controller, it is strongly recommended that you\nput your action handling methods inside an actions hash for forward\ncompatibility.\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Route.extend({\n  actions: {\n    expand() {\n      this.controller.set('isExpanded', true);\n    },\n\n    contract() {\n      this.controller.set('isExpanded', false);\n    }\n  }\n});\n\n\n\nAs you can see in this example, the action handlers are called such\nthat when executed, this is the route, not the actions hash.\n\nTo continue bubbling the action, you must return true from the handler:\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export default Ember.Route.extend({\n  actions: {\n    expand() {\n      this.controller.set('isExpanded', true);\n    },\n\n    contract() {\n      // ...\n      if (actionShouldAlsoBeTriggeredOnParentRoute) {\n        return true;\n      }\n    }\n  }\n});\n\n\n\nIf neither the template's controller nor the currently active route\nimplements a handler, the action will continue to bubble to any parent\nroutes. Ultimately, if an ApplicationRoute is defined, it will have an\nopportunity to handle the action.\n\nWhen an action is triggered, but no matching action handler is\nimplemented on the controller, the current route, or any of the\ncurrent route's ancestors, an error will be thrown.\n\n\n\nThis allows you to create a button that has different behavior based on\nwhere you are in the application. For example, you might want to have a\nbutton in a sidebar that does one thing if you are somewhere inside of\nthe /posts route, and another thing if you are inside of the /about\nroute.\nAction Parameters\nYou can optionally pass arguments to the action handler. Any values\npassed to the {{action}} helper after the action name will be passed to\nthe handler as arguments.\n\nFor example, if the post argument was passed:\n\n  1\n\n  \u003cp\u003e\u003cbutton {{action \"select\" post}}\u003e✓\u003c/button\u003e {{post.title}}\u003c/p\u003e\n\n\n\nThe controller's select action handler would be called with a single argument\ncontaining the post model:\n\n  \n    \n      app/controllers/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Controller.extend({\n  actions: {\n    select(post) {\n      console.log(post.get('title'));\n    }\n  }\n});\n\n\nSpecifying the Type of Event\nBy default, the {{action}} helper listens for click events and triggers\nthe action when the user clicks on the element.\n\nYou can specify an alternative event by using the on option.\n\n  1\n2\n3\n4\n\n  \u003cp\u003e\n  \u003cbutton {{action \"select\" post on=\"mouse-up\"}}\u003e✓\u003c/button\u003e\n  {{post.title}}\n\u003c/p\u003e\n\n\n\nYou should use the dasherized event names.\nIn general, two-word event names (like keypress) become key-press.\nSpecifying Whitelisted Modifier Keys\nBy default the {{action}} helper will ignore click events with\npressed modifier keys. You can supply an allowedKeys option\nto specify which keys should not be ignored.\n\n  1\n2\n3\n\n  \u003cbutton {{action 'anActionName' allowedKeys=\"alt\"}}\u003e\n  click me\n\u003c/button\u003e\n\n\n\nThis way the {{action}} will fire when clicking with the alt key\npressed down.\nDefault Event\nBy default, event.preventDefault() is called on all events handled by {{action}} helpers. To avoid this you can add preventDefault=false as a parameter. \nStopping Event Propagation\nBy default, the {{action}} helper allows events it handles to bubble\nup to parent DOM nodes. If you want to stop propagation, you can disable\npropagation to the parent node.\n\nFor example, if you have a ✗ button inside of a link, you will want\nto ensure that if the user clicks on the ✗, that the link is not\nclicked.\n\n  1\n2\n3\n4\n\n  {{#link-to 'post'}}\n  Post\n  \u003cbutton {{action 'close' bubbles=false}}\u003e✗\u003c/button\u003e\n{{/link-to}}\n\n\n\nWithout bubbles=false, if the user clicked on the button, Ember.js\nwill trigger the action, and then the browser will propagate the click\nto the link.\n\nWith bubbles=false, Ember.js will stop the browser from propagating\nthe event.\nHandling an Action\nThe {{action}} helper sends the action from a component's template to\nthe component.\n\nYou can handle the action by adding an actions hash to your component\nthat contains a method with the name of the action.\n\nFor example, given this template that adds the select action to a\nbutton:\n\n  \n    \n      app/templates/component/show-posts.hbs\n    \n  \n\n  1\n\n  \u003cbutton {{action \"select\" model}}\u003eSelect Post\u003c/button\u003e\n\n\n\nYou can implement a function that responds to the button being clicked\nby adding an actions hash to your component with a method called\nselect:\n\n  \n    \n      app/components/show-posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  actions: {\n    select(post) {\n      // do your business.\n    }\n  }\n});\n\n\nAllowing Default Browser Action\nBy default, the {{action}} helper prevents the default browser action of the DOM event. If you want to allow the browser action, you can stop ember from preventing it.\n\nFor example, if you have a normal link tag and want the link to bring the user to another page in addition to triggering an ember action when clicked.\n\n  1\n\n  \u003ca href=\"newPage.htm\" {{action 'logClick' preventDefault=false}}\u003eGo\u003c/a\u003e\n\n\n\nWithout preventDefault=false, if the user clicked on the link, Ember.js\nwill trigger the action, but the user will remain on the current page.\n\nWith preventDefault=false, if the user clicked on the link, Ember.js\nwill trigger the action and the user will be directed to the new page.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"59c50884dd61207af6fc0a831825eb47","fields":[{"name":"title","value":"Binding Element Attributes","type":"string"},{"name":"url","value":"/templates/binding-element-attributes/","type":"enum"},{"name":"body","value":"In addition to normal text, you may also want to have your templates\ncontain HTML elements whose attributes are bound to the controller.\n\nFor example, imagine your controller has a property that contains a URL\nto an image:\n\n  1\n2\n3\n\n  \u003cdiv id=\"logo\"\u003e\n  \u003cimg src={{logoUrl}} alt=\"Logo\"\u003e\n\u003c/div\u003e\n\n\n\nThis generates the following HTML:\n\n  1\n2\n3\n\n  \u003cdiv id=\"logo\"\u003e\n  \u003cimg src=\"http://www.example.com/images/logo.png\" alt=\"Logo\"\u003e\n\u003c/div\u003e\n\n\n\nIf you use data binding with a Boolean value, it will add or remove\nthe specified attribute. For example, given this template:\n\n  1\n\n  \u003cinput type=\"checkbox\" disabled={{isAdministrator}}\u003e\n\n\n\nIf isAdministrator is true, Handlebars will produce the following\nHTML element:\n\n  1\n\n  \u003cinput type=\"checkbox\" disabled\u003e\n\n\n\nIf isAdministrator is false, Handlebars will produce the following:\n\n  1\n\n  \u003cinput type=\"checkbox\"\u003e\n\n\nAdding Data Attributes\nBy default, view helpers do not accept data attributes. For example\n\n  1\n2\n3\n\n  {{#link-to \"photos\" data-toggle=\"dropdown\"}}Photos{{/link-to}}\n\n{{input type=\"text\" data-toggle=\"tooltip\" data-placement=\"bottom\" title=\"Name\"}}\n\n\n\nrenders the following HTML:\n\n  1\n2\n3\n4\n\n  \u003ca id=\"ember239\" class=\"ember-view\" href=\"#/photos\"\u003ePhotos\u003c/a\u003e\n\n\u003cinput id=\"ember257\" class=\"ember-view ember-text-field\" type=\"text\" \n       title=\"Name\"\u003e\n\n\n\nThere are two ways to enable support for data attributes. One way would be to add an\nattribute binding on the view, e.g. Ember.LinkComponent or Ember.TextField for the specific attribute:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.LinkComponent.reopen({\n  attributeBindings: ['data-toggle']\n});\n\nexport default Ember.TextField.reopen({\n  attributeBindings: ['data-toggle', 'data-placement']\n});\n\n\n\nNow the same handlebars code above renders the following HTML:\n\n  1\n2\n3\n4\n\n  \u003ca id=\"ember240\" class=\"ember-view\" href=\"#/photos\" data-toggle=\"dropdown\"\u003ePhotos\u003c/a\u003e\n\n\u003cinput id=\"ember259\" class=\"ember-view ember-text-field\"\n       type=\"text\" data-toggle=\"tooltip\" data-placement=\"bottom\" title=\"Name\"\u003e\n\n\n\nYou can also automatically bind data attributes on the base view with the\nfollowing:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.View.reopen({\n  init() {\n    this._super();\n    var self = this;\n\n    // bind attributes beginning with 'data-'\n    Ember.keys(this).forEach(function(key) {\n      if (key.substr(0, 5) === 'data-') {\n        self.get('attributeBindings').pushObject(key);\n      }\n    });\n  }\n});\n\n\n\nNow you can add as many data-attributes as you want without having to specify them by name.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e478e22e0d1033f8572e38161a50bf9a","fields":[{"name":"title","value":"Binding Element Class Names","type":"string"},{"name":"url","value":"/templates/binding-element-class-names/","type":"enum"},{"name":"body","value":"An HTML element's class attribute can be bound like any other\nattribute:\n\n  1\n2\n3\n\n  \u003cdiv class={{priority}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nIf the component's priority property is \"p4\", this template will emit the following HTML:\n\n  1\n2\n3\n\n  \u003cdiv class=\"p4\"\u003e\n  Warning!\n\u003c/div\u003e\n\n\nConditional Values\nIf you want a class value based on a conditional property, use the Handlebars if helper:\n\n  1\n2\n3\n\n  \u003cdiv class={{if isUrgent 'is-urgent'}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nIf isUrgent is true, this emits the following HTML:\n\n  1\n2\n3\n\n  \u003cdiv class=\"is-urgent\"\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nIf isUrgent is false, no class name is added:\n\n  1\n2\n3\n\n  \u003cdiv\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nYou can also specify a class name to add when the property is false:\n\n  1\n2\n3\n\n  \u003cdiv class={{if isEnabled 'enabled' 'disabled'}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nIn this case, if the isEnabled property is true, the enabled\nclass will be added. If the property is false, the class disabled\nwill be added.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"95d724148efe2cc1481ae51952ecf2b7","fields":[{"name":"title","value":"Conditionals","type":"string"},{"name":"url","value":"/templates/conditionals/","type":"enum"},{"name":"body","value":"Sometimes you may only want to display part of your template if a property\nexists.\n\nWe can use the {{#if}} helper to conditionally render a block:\n\n  1\n2\n3\n\n  {{#if person}}\n  Welcome back, \u003cb\u003e{{person.firstName}} {{person.lastName}}\u003c/b\u003e!\n{{/if}}\n\n\n\nHandlebars will not render the block if the argument passed evaluates to\nfalse, undefined, null or [] (i.e., any \"falsy\" value).\n\nIf the expression evaluates to falsy, we can also display an alternate template\nusing {{else}}:\n\n  1\n2\n3\n4\n5\n\n  {{#if person}}\n  Welcome back, \u003cb\u003e{{person.firstName}} {{person.lastName}}\u003c/b\u003e!\n{{else}}\n  Please log in.\n{{/if}}\n\n\n\nHandlebars also supports chained else helpers, the most common use being else if. An example:\n\n  1\n2\n3\n4\n5\n\n  {{#if isAtWork}}\n  Ship that code!\n{{else if isReading}}\n  You can finish War and Peace eventually...\n{{/if}}\n\n\n\nTo only render a block if a value is falsy, use {{#unless}}:\n\n  1\n2\n3\n\n  {{#unless hasPaid}}\n  You owe: ${{total}}\n{{/unless}}\n\n\n\n{{#if}} and {{#unless}} are examples of block expressions. These allow you\nto invoke a helper with a portion of your template. Block expressions look like\nnormal expressions except that they contain a hash (#) before the helper name,\nand require a closing expression.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a114533ff2793c31df860c375985bcb","fields":[{"name":"title","value":"Development Helpers","type":"string"},{"name":"url","value":"/templates/development-helpers/","type":"enum"},{"name":"body","value":"Development Helpers\nHandlebars and Ember come with a few helpers that can make developing your\ntemplates a bit easier. These helpers make it simple to output variables into\nyour browser's console, or activate the debugger from your templates.\nLogging\nThe {{log}} helper makes it easy to output variables or expressions in the\ncurrent rendering context into your browser's console:\n\n  1\n\n  {{log 'Name is:' name}}\n\n\n\nThe {{log}} helper also accepts primitive types such as strings or numbers.\nAdding a breakpoint\nThe {{debugger}} helper provides a handlebars equivalent to JavaScript's\ndebugger keyword.  It will halt execution inside the debugger helper and give\nyou the ability to inspect the current rendering context:\n\n  1\n\n  {{debugger}}\n\n\n\nWhen using the debugger helper you will have access to a get function. This\nfunction retrieves values available in the context of the template.\nFor example, if you're wondering why a value {{foo}} isn't rendering as\nexpected within a template, you could place a {{debugger}} statement and,\nwhen the debugger; breakpoint is hit, you can attempt to retrieve this value:\n\n  1\n\n  \u003e get('foo')\n\n\n\nget is also aware of keywords. So in this situation:\n\n  1\n2\n3\n\n  {{#each items as |item|}}\n  {{debugger}}\n{{/each}}\n\n\n\nYou'll be able to get values from the current item:\n\n  1\n\n  \u003e get('item.name')\n\n\n\nYou can also access the context of the view to make sure it is the object that\nyou expect:\n\n  1\n\n  \u003e context\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"94f518795fa706013cfd0ed73c5a9d3c","fields":[{"name":"title","value":"Displaying a List of Items","type":"string"},{"name":"url","value":"/templates/displaying-a-list-of-items/","type":"enum"},{"name":"body","value":"If you need to enumerate over a list of objects, use Handlebars' {{#each}} helper:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each people key=\"id\" as |person|}}\n    \u003cli\u003eHello, {{person.name}}!\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nThe template inside of the {{#each}} block will be repeated once for\neach item in the array, with the each item set to the person keyword.\n\nThe above example will print a list like this:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003eHello, Yehuda!\u003c/li\u003e\n  \u003cli\u003eHello, Tom!\u003c/li\u003e\n  \u003cli\u003eHello, Trek!\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\nThe {{#each}} helper is bindings-aware.  If your\napplication adds a new item to the array, or removes an item, the DOM\nwill be updated without having to write any code. Note that a [].push()\nwill not update the helper. Adding items need to be done with [].pushObject,\nand related Ember Mutable Array methods so that Ember can observe the change.\nSpecifying Keys\nThe key option is used to tell Ember how to determine if the array being\n  iterated over with {{#each}} has changed between renders. By helping Ember\n  detect that some elements in the array are the same, DOM elements can be\n  re-used, significantly improving rendering speed and preventing unexpected\n  results. For example, here's the {{#each}} helper with its key set to\n  id:\n  handlebars\n  {{#each people key=\"id\" as |person|}}\n  {{/each}}\n\n  When this {{#each}} re-renders, Ember will match up the previously rendered\n  items (and reorder the generated DOM elements) based on each item's id\n  property. Make sure the value you pass to key is unique!\n\nThere are a few special values for key:\n    * @index - The index of the item in the array.\n    * @item - The item in the array itself.  This can only be used for arrays of strings\n      or numbers.\n    * @guid - Generate a unique identifier for each object (uses Ember.guidFor).\nEmpty Lists\nThe {{#each}} helper can have a matching {{else}}.\nThe contents of this block will render if the collection is empty:\n\n  1\n2\n3\n4\n5\n\n  {{#each people key=\"id\" as |person|}}\n  Hello, {{person.name}}!\n{{else}}\n  Sorry, nobody is here.\n{{/each}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"619a7f1e4091d5852889772b71be63d0","fields":[{"name":"title","value":"Handlebars Basics","type":"string"},{"name":"url","value":"/templates/handlebars-basics/","type":"enum"},{"name":"body","value":"Ember.js uses the Handlebars templating library\nto power your app's user interface. Handlebars templates are just like\nregular HTML, but also give you the ability to embed expressions that\nchange what is displayed.\n\nEmber takes Handlebars and extends it with many powerful features. It may\nhelp to think of your Handlebars templates as an HTML-like DSL for\ndescribing the user interface of your app. And, once you've told\nEmber.js to render a given template on the screen, you don't need to\nwrite any additional code to make sure it keeps up-to-date.\nDefining Templates\nThe first thing you should change is your application template that is created\nautomatically for you and is displayed when your app loads.\n\nNext, you can define templates in the app/templates folder. Remember from\nNaming Convetions that by default,\na route will render a template with the same name as the route.\n\n  \n    \n      app/templates/kittens.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003eKittens\u003c/h1\u003e\n\u003cp\u003eKittens are the cutest!\u003c/p\u003e\n\n\n\nIf you would like to create a template that is shared across many areas of your site, you should investigate components.\nHandlebars Expressions\nEach template has an associated controller: this is where the template\nfinds the properties that it displays.\n\nYou can display a property from your controller by wrapping the property\nname in curly braces, like this:\n\n  1\n\n  Hello, \u003cstrong\u003e{{firstName}} {{lastName}}\u003c/strong\u003e!\n\n\n\nThis would look up the firstName and lastName properties from the\ncontroller, insert them into the HTML described in the template, then\nput them into the DOM.\n\nBy default, your top-most application template is bound to your application controller. Note that this file is not shown by default because it is created behind the scenes by Ember CLI. To customize the controller, create the following file:\n\n  \n    \n      app/controllers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Controller.extend({\n  firstName: \"Trek\",\n  lastName: \"Glowacki\"\n});\n\n\n\n\nThe above template and controller would combine to display the following\nrendered HTML:\n\n  1\n\n  Hello, \u003cstrong\u003eTrek Glowacki\u003c/strong\u003e!\n\n\n\nThese expressions (and the other Handlebars features you will learn\nabout next) are bindings aware. That means that if the values used\nby your templates ever change, your HTML will be updated automatically.\n\nAs your application grows in size, it will have many templates, each\nbound to different controllers.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"cbc42197752a02e932444274327e4808","fields":[{"name":"title","value":"Input Helpers","type":"string"},{"name":"url","value":"/templates/input-helpers/","type":"enum"},{"name":"body","value":"Input Helpers\nThe {{input}} and {{textarea}} helpers in Ember.js are the easiest way to\ncreate common form controls. The {{input}} helper wraps the built-in\nEmber.TextField and Ember.Checkbox views, while {{textarea}} wraps\nEmber.TextArea. Using these helpers, you can create these views with\ndeclarations almost identical to how you'd create a traditional \u003cinput\u003e or\n\u003ctextarea\u003e element.\nText fields\n  1\n\n  {{input value=\"http://www.facebook.com\"}}\n\n\n\nWill become:\n\n  1\n\n  \u003cinput type=\"text\" value=\"http://www.facebook.com\"/\u003e\n\n\n\nYou can pass the following standard \u003cinput\u003e attributes within the input\nhelper:\n\n\n  `readonly``required``autofocus`\n  `value``placeholder``disabled`\n  `size``tabindex``maxlength`\n  `name``min``max`\n  `pattern``accept``autocomplete`\n  `autosave``formaction``formenctype`\n  `formmethod``formnovalidate``formtarget`\n  `height``inputmode``multiple`\n  `step``width``form`\n  `selectionDirection``spellcheck` \n\n\nIf these attributes are set to a quoted string, their values will be set\ndirectly on the element, as in the previous example. However, when left\nunquoted, these values will be bound to a property on the template's current\nrendering context. For example:\n\n  1\n\n  {{input type=\"text\" value=firstName disabled=entryNotAllowed size=\"50\"}}\n\n\n\nWill bind the disabled attribute to the value of entryNotAllowed in the\ncurrent context.\nActions\nTo dispatch an action on specific events, such as enter or key-press, use the following\n\n  1\n\n  {{input value=firstName key-press=\"updateFirstName\"}}\n\n\n\nEvent Names must be dasherized.\nCheckboxes\nYou can also use the {{input}} helper to create a checkbox by setting its\ntype:\n\n  1\n\n  {{input type=\"checkbox\" name=\"isAdmin\" checked=isAdmin}}\n\n\n\nCheckboxes support the following properties:\n\n\nchecked\ndisabled\ntabindex\nindeterminate\nname\nautofocus\nform\n\n\nWhich can be bound or set as described in the previous section.\nText Areas\n  1\n\n  {{textarea value=name cols=\"80\" rows=\"6\"}}\n\n\n\nWill bind the value of the text area to name on the current context.\n\n{{textarea}} supports binding and/or setting the following properties:\n\n\nvalue\nname\nrows\ncols\nplaceholder\ndisabled\nmaxlength\ntabindex\nselectionEnd\nselectionStart\nselectionDirection\nwrap\nreadonly\nautofocus\nform\nspellcheck\nrequired\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a3506f82f88ccbc90b445c4c8d73f39a","fields":[{"name":"title","value":"Links","type":"string"},{"name":"url","value":"/templates/links/","type":"enum"},{"name":"body","value":"The {{link-to}} Helper\nYou create a link to a route using the {{link-to}} helper.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route(\"photos\", function(){\n    this.route(\"edit\", { path: \"/:photo_id\" });\n  });\n});\n\n\n\n  \n    \n      app/templates/photos.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each photos as |photo|}}\n    \u003cli\u003e{{#link-to 'photos.edit' photo}}{{photo.title}}{{/link-to}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nIf the model for the photos template is a list of three photos, the\nrendered HTML would look something like this:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003e\u003ca href=\"/photos/1\"\u003eHappy Kittens\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/2\"\u003ePuppy Running\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/3\"\u003eMountain Landscape\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\nThe {{link-to}} helper takes one or two arguments:\n\n\nThe name of a route. In this example, it would be index, photos, or\nphotos.edit.\nAt most one model for each dynamic segment.\nBy default, Ember.js will replace each segment with the value of the corresponding object's id property.\nIn the example above, the second argument is each photo object, and the id property is used to fill in\nthe dynamic segment with either 1, 2, or 3. If there is no model to pass to the helper, you can provide\nan explicit value instead:\n\n\n  \n    \n      app/templates/photos.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#link-to 'photos.photo.edit' 1}}\n  First Photo Ever\n{{/link-to}}\n\n\n\nWhen the rendered link matches the current route, and the same\nobject instance is passed into the helper, then the link is given\nclass=\"active\". For example, if you were at the URL /photos/2,\nthe first example above would render as:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003e\u003ca href=\"/photos/1\"\u003eHappy Kittens\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/2\" class=\"active\"\u003ePuppy Running\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/3\"\u003eMountain Landscape\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\nExample for Multiple Segments\nIf the route is nested, you can supply a model or an identifier for each dynamic\nsegment.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Router.map(function() {\n  this.route(\"photos\", function(){\n    this.route(\"photo\", { path: \"/:photo_id\" }, function(){\n      this.route(\"comments\");\n      this.route(\"comment\", { path: \"/comments/:comment_id\" });\n    });\n  });\n});\n\n\n\n  \n    \n      app/templates/photo/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cdiv class=\"photo\"\u003e\n  {{body}}\n\u003c/div\u003e\n\n\u003cp\u003e{{#link-to 'photos.photo.comment' primaryComment}}Main Comment{{/link-to}}\u003c/p\u003e\n\n\n\nIf you specify only one model, it will represent the innermost dynamic segment :comment_id.\nThe :photo_id segment will use the current photo.\n\nAlternatively, you could pass both a photo's ID and a comment to the helper:\n\n  \n    \n      app/templates/photo/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cp\u003e\n  {{#link-to 'photo.comment' 5 primaryComment}}\n    Main Comment for the Next Photo\n  {{/link-to}}\n\u003c/p\u003e\n\n\n\nIn the above example, the model hook for PhotoRoute will run with params.photo_id = 5.  The model hook for\nCommentRoute won't run since you supplied a model object for the comment segment. The comment's id will\npopulate the url according to CommentRoute's serialize hook.\nUsing link-to as an inline helper\nIn addition to being used as a block expression, the link-to helper\ncan also be used in inline form by specifying the link text as the first\nargument to the helper:\n\n  1\n2\n\n  A link in {{#link-to 'index'}}Block Expression Form{{/link-to}},\nand a link in {{link-to 'Inline Form' 'index'}}.\n\n\n\nThe output of the above would be:\n\n  1\n2\n\n  A link in \u003ca href='/'\u003eBlock Expression Form\u003c/a\u003e,\nand a link in \u003ca href='/'\u003eInline Form\u003c/a\u003e.\n\n\nAdding additional attributes on a link\nWhen generating a link you might want to set additional attributes for it. You can do this with additional\narguments to the link-to helper:\n\n  1\n2\n3\n\n  \u003cp\u003e\n  {{link-to 'Edit this photo' 'photo.edit' photo class=\"btn btn-primary\"}}\n\u003c/p\u003e\n\n\n\nMany of the common HTML properties you would want to use like class, and rel will work. When\nadding class names, Ember will also apply the standard ember-view and possibly active class names.\nReplacing history entries\nThe default behavior for link-to is to add entries to the browser's history\nwhen transitioning between the routes. However, to replace the current entry in\nthe browser's history you can use the replace=true option:\n\n  1\n2\n3\n4\n5\n\n  \u003cp\u003e\n  {{#link-to 'photo.comment' 5 primaryComment replace=true}}\n    Main Comment for the Next Photo\n  {{/link-to}}\n\u003c/p\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"bc7ea295f86185ac867cf8954eef551a","fields":[{"name":"title","value":"Rendering with Helpers","type":"string"},{"name":"url","value":"/templates/rendering-with-helpers/","type":"enum"},{"name":"body","value":"Ember.js provides several helpers that allow you to render templates in different ways.\nThe {{partial}} Helper\n{{partial}} takes the template to be rendered as an argument, and renders that template in place.\n\n{{partial}} does not change context or scope.  It simply drops the given template into place with the current scope.\n\n  \n    \n      app/templates/author.hbs\n    \n  \n\n  1\n\n  Written by {{author.firstName}} {{author.lastName}}\n\n\n\n  \n    \n      app/templates/post.hbs\n    \n  \n\n  1\n2\n3\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003cdiv\u003e{{body}}\u003c/div\u003e\n{{partial \"author\"}}\n\n\n\nOutput:\n\n  1\n2\n3\n4\n5\n\n  \u003cdiv\u003e\n  \u003ch1\u003eWhy You Should Use Ember.js\u003c/h1\u003e\n  \u003cdiv\u003eBecause it's awesome!\u003c/div\u003e\n  Written by Yehuda Katz\n\u003c/div\u003e\n\n\nThe {{render}} Helper\n{{render}} takes two parameters:\n\n\nThe first parameter describes the context to be setup\nThe optional second parameter is a model, which will be passed to the controller if provided\n\n\n{{render}} does several things:\n\n\nWhen no model is provided it gets the singleton instance of the corresponding controller\nWhen a model is provided it gets a unique instance of the corresponding controller\nRenders the named template using this controller\nSets the model of the corresponding controller\n\n\nModifying the post / author example slightly:\n\n  \n    \n      app/templates/author.hbs\n    \n  \n\n  1\n2\n\n  Written by {{firstName}} {{lastName}}.\nTotal Posts: {{postCount}}\n\n\n\n  \n    \n      app/templates/post.hbs\n    \n  \n\n  1\n2\n3\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003cdiv\u003e{{body}}\u003c/div\u003e\n{{render \"author\" author}}\n\n\n\n  \n    \n      app/controllers/author.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Controller.extend({\n  postCount: Ember.computed('model.posts.[]', function() {\n    return this.get('model.posts.length');\n  })\n})\n\n\n\nIn this example, render will:\n\n\nUse the corresponding template (in this case the default of \"author\")\nGet (or generate) the singleton instance of AuthorController\nSet the AuthorController's model to the 2nd argument passed to render, here the author field on the post\nRender the template in place, with the context created in the previous steps.\n\n\n{{render}} does not require the presence of a matching route.\n\n{{render}} is similar to {{outlet}}. Both tell Ember.js to devote this portion of the page to something.\n\n{{outlet}}: The router determines the route and sets up the appropriate controllers/views/models.\n{{render}}: You specify (directly and indirectly) the appropriate controllers/views/models.\n\nNote: {{render}} cannot be called multiple times for the same route when not specifying a model.\nComparison TableGeneral\n\n  \n  \n    Helper\n    Template\n    Model\n    Controller\n  \n  \n  \n  \n    {{partial}}\n    Specified Template\n    Current Model\n    Current Controller\n  \n  \n    {{render}}\n    Template\n    Specified Model\n    Specified Controller\n  \n  \n\nSpecific\n\n  \n  \n    Helper\n    Template\n    Model\n    Controller\n  \n  \n  \n  \n    {{partial \"author\"}}\n    templates/author.hbs\n    models/post.js\n    controllers/post.js\n  \n  \n    {{render \"author\" author}}\n    templates/author.hbs\n    models/author.js\n    controllers/author.js\n  \n  \n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b691fc4bca513d0a74056434e4d51519","fields":[{"name":"title","value":"The Application Template","type":"string"},{"name":"url","value":"/templates/the-application-template/","type":"enum"},{"name":"body","value":"The application template is the default template that is rendered when\nyour application starts.\n\nYou should put your header, footer, and any other decorative content\nhere. Additionally, you should have at least one {{outlet}}:\na placeholder that the router will fill in with the appropriate template,\nbased on the current URL.\n\nHere's an example template:\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  \u003cheader\u003e\n  \u003ch1\u003eIgor's Blog\u003c/h1\u003e\n\u003c/header\u003e\n\n\u003cdiv\u003e\n  {{outlet}}\n\u003c/div\u003e\n\n\u003cfooter\u003e\n  \u0026copy;2013 Igor's Publishing, Inc.\n\u003c/footer\u003e\n\n\n\nThe header and footer will always be displayed on screen, but the\ncontents of the \u003cdiv\u003e will change depending on if the user is\ncurrently at /posts or /posts/15, for example.\n\nFor more information about how outlets are filled in by the router, see\nRouting.\n\nEmber CLI will create application.hbs for you by default in app/templates/application.hbs.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4d51ca61c042a6e0f4dfd8e0cdb116ed","fields":[{"name":"title","value":"Writing Helpers","type":"string"},{"name":"url","value":"/templates/writing-helpers/","type":"enum"},{"name":"body","value":"Helpers allow you to add additional functionality to your\ntemplates beyond what is included out-of-the-box in Ember. Helpers are\nmost useful for transforming raw values from models and components into\na format more appropriate for your users.\n\nFor example, imagine we have an Invoice model that contains a\ntotalDue attribute, which represents the total amount due for that\ninvoice.  Because we do not want our company to go out of business due\nto strange JavaScript rounding errors, we store this value in cents\ninstead of a floating point dollar value.\n\nHowever, if we display dollar values to our users as \"100¢\" instead of\n\"$1.00\", they may be very confused. We can write a helper to\nformat these values into the appropriate human-readable form.\n\nLet's create a format-currency helper that takes an integer count of\ncents and turns it into formatted dollars.\n\nTo use the format-currency helper, you call it using curly braces in\nyour template:\n\n  1\n\n  Your total is {{format-currency model.totalDue}}.\n\n\n\nLet's now implement the helper. Helpers are just functions that take\none or more inputs and return a single output that should be put into\nthe HTML.\n\nTo add a new helper, create a file with the name of the helper you want\n(e.g. format-currency.js) in your application's helpers directory.\nYou can also have Ember generate the file for you from the command line:\n\n  1\n\n  ember generate helper format-currency\n\n\n\nThat file should export a function wrapped with Ember.Helper.helper():\n\n  \n    \n      app/helpers/format-currency.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import Ember from \"ember\";\n\nexport default Ember.Helper.helper(function(params) {\n  let value = params[0],\n      dollars = Math.floor(value / 100),\n      cents = value % 100,\n      sign = '$';\n\n  if (cents.toString().length === 1) { cents = '0' + cents; }\n  return `${sign}${dollars}.${cents}`;\n});\n\n\n\nIn this example, the function receives a dollar amount in cents as the first\nparameter (params[0]). We then use regular JavaScript to turn the\ncount of cents into a formatted string, like \"$5.00\".\n\nWhenever you use your helper in a template, Ember will call this\nfunction and insert whatever you return from the helper into the DOM.\n\nSo, for example, if we had a template like this where we pass a value in\ncents:\n\n  1\n\n  Your total is {{format-currency 250}}.\n\n\n\nEmber would replace the content inside the {{ }} with the formatted\namount:\n\n  1\n\n  Your total is $2.50.\n\n\n\nWhenever the arguments you've passed to a helper change, whether they\ncome from a model or a component, Ember will automatically call your\nhelper again with the new values and keep the DOM up-to-date.\nHelper Names\nUnlike components, helpers do not require a dash (-) character in\ntheir name.\nHelper Arguments\nYou can pass one or more arguments to  which can be used\ninside the function. In the above example, we passed the amount in cents\nas the first and only argument.\n\nTo pass multiple arguments to a helper, add them as a space-separated\nlist after the helper name:\n\n  1\n\n  {{my-helper \"hello\" \"world\"}}\n\n\n\nAn array of these arguments is passed to the helper function:\n\n  \n    \n      app/helpers/my-helper.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  import Ember from \"ember\";\n\nexport default Ember.Helper.helper(function(params) {\n  let arg1 = params[0];\n  let arg2 = params[1];\n\n  console.log(arg1); // =\u003e \"hello\"\n  console.log(arg2); // =\u003e \"world\"\n});\n\n\n\nYou can use JavaScript's destructuring assignment shorthand to clean up\nthe code. This example is equivalent to the above example (note the function signature):\n\n  \n    \n      app/helpers/my-helper.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Ember from \"ember\";\n\nexport default Ember.Helper.helper(function([arg1, arg2]) {\n  console.log(arg1); // =\u003e \"hello\"\n  console.log(arg2); // =\u003e \"world\"\n});\n\n\nNamed Arguments\nNormal arguments are useful for passing data to be transformed into\nhelper functions. However, because the order in which you pass arguments\nmatters, it is usually best not to have helpers take more than one or\ntwo of them.\n\nThat said, sometimes you may want to make behavior of helpers\nconfigurable by the developers that call them from their templates. For\nexample, let's abandon our American-centric ways and update our\nformat-currency helper to take an optional configuration for which\ncurrency symbol to display.\n\nHelpers allow you to pass named arguments as a JavaScript\nobject that contains the name of the argument along with an associated\nvalue.  The order in which named arguments are supplied does not affect\nfunctionality.\n\nIn this example, we can pass a sign argument to our format-currency\nhelper:\n\n  1\n\n  {{format-currency 350 sign=\"£\"}}\n\n\n\nWe'd like our helper to print pounds sterling rather than US dollars:\n\n  1\n\n  £3.50\n\n\n\nThe object containing named arguments is passed as the second argument\nto the helper function.  Here is our example from above, updated to\nsupport the optional sign option:\n\n  \n    \n      app/helpers/format-currency.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import Ember from \"ember\";\n\nexport default Ember.Helper.helper(function(params, namedArgs) {\n  let value = params[0],\n      dollars = Math.floor(value / 100),\n      cents = value % 100,\n      sign = namedArgs.sign === undefined ? '$' : namedArgs.sign;\n\n  if (cents.toString().length === 1) { cents = '0' + cents; }\n  return `${sign}${dollars}.${cents}`;\n});\n\n\n\nYou can pass as many named arguments as you'd like. They get added to the\nnamedArgs argument passed to the function:\n\n  1\n2\n\n  {{my-helper option1=\"hello\" option2=\"world\" option3=\"goodbye cruel\nworld\"}}\n\n\n\n  \n    \n      app/helpers/my-helper.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Ember from \"ember\";\nexport default Ember.Helper.helper(function(params, namedArgs) {\n  console.log(namedArgs.option1); // =\u003e \"hello\"\n  console.log(namedArgs.option2); // =\u003e \"world\"\n  console.log(namedArgs.option3); // =\u003e \"goodbye cruel world\"\n});\n\n\n\nYou can use JavaScript's destructuring assignment shorthand in this case\nas well to clean up the above code:\n\n  \n    \n      app/helpers/my-helper.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Ember from \"ember\";\nexport default Ember.Helper.helper(function(params, { option1, option2, option3 }) {\n  console.log(option1); // =\u003e \"hello\"\n  console.log(option2); // =\u003e \"world\"\n  console.log(option3); // =\u003e \"goodbye cruel world\"\n});\n\n\n\nIn sum, arguments are good for passing values:\n\n  1\n\n  {{format-date currentDate}}\n\n\n\nHashes are useful for configuring the behavior of a helper:\n\n  1\n\n  {{print-current-date format=\"YYYY MM DD\"}}\n\n\n\nYou can have as many of both as you want, so long as the parameters come\nfirst:\n\n  1\n\n  {{format-date-and-time date time format=\"YYYY MM DD h:mm\" locale=\"en\"}}\n\n\n\nThe above example contains two arguments:\n\n\ndate\ntime\n\n\nAnd two named arguments:\n\n\nformat=\"YYY MM DD h:mm\"\nlocale=\"en\"\n\nStateful Helpers\nBy default, helpers are stateless. They are passed inputs (parameters\nand a hash), they perform an operation on those inputs, and return a\nsingle output. They have no side-effects and don't save any information\nthat is used on subsequent runs of the function.\n\nIn some situations, however, you may need to write a helper that\ninteracts with the rest of your application. You can create stateful\nhelpers that have access to services in your application, and can\noptionally save state as well.\n\nTo create a stateful helper, rather than returning a simple function,\nyou should return a subclass of Ember.Helper. Helper classes must\ncontain a compute method that behaves the same as the function passed\nto Ember.Helper.helper.\n\nIn fact, we can refactor the above stateless helper into a stateful\nhelper just by making the function into a compute method on the class:\n\n  \n    \n      app/helpers/format-currency.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  import Ember from \"ember\";\n\nexport default Ember.Helper.extend({\n  compute(params, hash) {\n    let value = params[0],\n        dollars = Math.floor(value / 100),\n        cents = value % 100,\n        sign = hash.sign === undefined ? '$' : hash.sign;\n\n    if (cents.toString().length === 1) { cents = '0' + cents; }\n    return `${sign}${dollars}.${cents}`;\n  }\n});\n\n\n\nThis is exactly equivalent to the example above. You can think of the\nfunction version as a shorthand for the longer class form if it does not\nrequire any state.\nAdding Services\nStateful helpers can access the services in your application. In order to\naccess a service, you must first inject it into the stateful helper.\nOnce added, you can call the service's methods or access its properties\nfrom within the compute() method.\n\n  \n    \n      app/helpers/is-authenticated.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  import Ember from \"ember\";\n\nexport default Ember.Helper.extend({\n  authentication: Ember.inject.service()\n  compute() {\n    let authentication = this.get('authentication');\n\n    if (authentication.get('isAuthenticated')) {\n      return \"Welcome back, \" + authentication.get('username');\n    } else {\n      return \"Not logged in\";\n    }\n  }\n});\n\n\nEscaping HTML Content\nTo protect your application from cross-site scripting attacks (XSS),\nEmber automatically escapes any value you return from a helper so that\nthe browser will not interpret it as HTML.\n\nFor example, here's a make-bold helper that returns a string containing HTML:\n\n  \n    \n      app/helpers/make-bold.js\n    \n  \n\n  1\n2\n3\n4\n\n  import Ember from \"ember\";\nexport default Ember.Helper.helper(function(params) {\n  return `\u003cb\u003e${params[0]}\u003c/b\u003e`;\n});\n\n\n\nYou can invoke it like this:\n\n  1\n\n  {{make-bold \"Hello world\"}}\n\n\n\nEmber will escape the HTML tags, like this:\n\n  1\n\n  \u0026lt;b\u0026gt;Hello world\u0026lt;/b\u0026gt;\n\n\n\nThis shows the literal string \u003cb\u003eHello world\u003c/b\u003e to the user, rather\nthan the text in bold as you probably intended. We can tell Ember not to\nescape the return value (that is, that it is safe) by using the\nhtmlSafe string utility:\n\n  \n    \n      app/helpers/make-bold.js\n    \n  \n\n  1\n2\n3\n4\n\n  import Ember from \"ember\";\nexport default Ember.Helper.helper(function(params) {\n  return Ember.String.htmlSafe(`\u003cb\u003e${params[0]}\u003c/b\u003e`);\n});\n\n\n\nIf you return a SafeString (a string that has been wrapped in a call\nto htmlSafe), Ember knows that you have vouched on its behalf that it\ncontains no malicious HTML.\n\nHowever, note that in the above code we may have just inadvertently\nintroduced an XSS vulnerability into our application! By blindly marking\nthe string as safe, a malicious user could get their own HTML into our\napp, allowing them to do things like access sensitive customer data.\n\nFor example, imagine that we have a chat app  and use our make-bold\nhelper to welcome the new users into the channel:\n\n  1\n\n  Welcome back! {{make-bold model.firstName}} has joined the channel.\n\n\n\nNow a malicious user simply needs to set their firstName to a string\ncontaining HTML (like a \u003cscript\u003e tag that sends private customer data\nto their server, for example) and every user in that chat room has been\ncompromised.\n\nIn general, you should prefer using components if you are wrapping\ncontent in HTML. However, if you really want to include a mix of HTML\nand values from models in what you return from the helper, make sure you\nescape anything that may have come from an untrusted user with the\nescapeExpression utility:\n\n  \n    \n      app/helpers/make-bold.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  import Ember from \"ember\";\nexport default Ember.Helper.helper(function(params) {\n  let value = Handlebars.Utils.escapeExpression(params[0]);\n  return Ember.String.htmlSafe(`\u003cb\u003e${value}\u003c/b\u003e`);\n});\n\n\n\nNow the value passed into the helper has its HTML escaped, but the trusted\n\u003cb\u003e tags that we want to wrap the value in are not escaped. A\nmalicious user setting their firstName to something containing HTML\nwould just see this:\n\n  1\n2\n\n  Welcome back! \u003cb\u003e\u0026lt;script\ntype=\"javascript\"\u0026gt;alert('pwned!');\u0026lt;/script\u0026gt;\u003c/b\u003e has joined the channel.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6b92476d3f19a3ac5f6ea85e474595d8","fields":[{"name":"title","value":"Acceptance Tests","type":"string"},{"name":"url","value":"/testing/acceptance/","type":"enum"},{"name":"body","value":"Acceptance tests are generally used to test important workflows within your application. They emulate user interaction and confirm expected results.\nIntroduction\nember-cli comes with acceptance test support out of the box. For creating your\nfirst test, you just need to run ember generate acceptance-test \u003cname\u003e. In\nour case, ember generate acceptance-test user-can-login-via-form. ember-cli will\ncreate a new test file under tests/acceptance/.\n\nAfter a few imports, ember-cli adds two hooks to the module definition. In the \nbeforeEach, a new Ember application is created and put in testing mode. This way, \nthe readiness of the application is deferred until your tests are ready to run. \nThe helper also sets the router's location to 'none' so that the window's location \nwill not be modified. After each test run, the application is destroyed to assure your \ntests are run in isolation.\n\n  \n    \n      tests/acceptance/user-can-login-via-form-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  var application;\n\nmodule('Acceptance: UserCanLoginViaForm', {\n  beforeEach: function() {\n    application = startApp();\n  },\n\n  afterEach: function() {\n    Ember.run(application, 'destroy');\n  }\n});\n\n\n\nember-cli also generates a sample test. In this case, we visit \n'/user-can-login-via-form' and assert we got there without any problem.\n\n  \n    \n      tests/acceptance/user-can-login-via-form-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  test('visiting /user-can-login-via-form', function(assert) {\n  visit('/user-can-login-via-form');\n\n  andThen(function() {\n    assert.equal(currentPath(), 'user-can-login-via-form');\n  });\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d111ada688dff43a36c7d27aea287dc5","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/testing/","type":"enum"},{"name":"body","value":"Testing is a core part of the Ember framework and its development cycle.\n\nLet's assume you are writing an Ember application which will serve as a blog. \nThis application would likely include models such as user and post. It would \nalso include interactions such as login and create post. Let's finally \nassume that you would like to have automated tests in place for your application. \n\nThere are two different classifications of tests that you will need: \nAcceptance and Unit.\nAcceptance Tests\nAcceptance tests are used to test user interaction and application flow. With \nthe example scenario above, some acceptance tests you might write are:\n\n\nA user is able to log in via the login form.\nA user is able to create a blog post.\nA visitor does not have access to the admin panel.\n\nUnit Tests\nUnit tests are used to test isolated chunks of functionality, or \"units\", without \nworrying about their dependencies. Some examples of unit tests for the scenario \nabove might be:\n\n\nA user has a role\nA user has a username\nA user has a fullname attribute which is the aggregate of its first and last \nnames with a space between\nA post has a title\nA post's title must be no longer than 50 characters\n\nTesting Frameworks\nQUnit is the default testing framework for this guide, but others are \nsupported through third-party addons.\nHow to Run Your Tests\nRun your tests with ember test on the command-line. You can re-run your tests on every file-change with ember test --server. For more details and options, see Ember CLI – Testing and ember help test.\nContributing\nThe Ember testing guide provides best practices and examples on how to test your\nEmber applications. If you find any errors or believe the documentation can be\nimproved, please feel free to contribute.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8339b4dfcf839b8409d37b5417877c11","fields":[{"name":"title","value":"Test Helpers","type":"string"},{"name":"url","value":"/testing/test-helpers/","type":"enum"},{"name":"body","value":"One of the major issues in testing web applications is that all code is\nevent-driven, therefore has the potential to be asynchronous (i.e. output can\nhappen out of sequence from input). This has the ramification that code can be\nexecuted in any order.\n\nAn example may help here: Let's say a user clicks two buttons, one after another\nand both load data from different servers. They take different times to respond.\n\nWhen writing your tests, you need to be keenly aware of the fact that you cannot\nbe sure that the response will return immediately after you make your requests,\ntherefore your assertion code (the \"tester\") needs to wait for the thing being\ntested (the \"testee\") to be in a synchronized state. In the example above, that\nwould be when both servers have responded and the test code can go about its\nbusiness checking the data (whether it is mock data, or real data).\n\nThis is why all Ember's test helpers are wrapped in code that ensures Ember is\nback in a synchronized state when it makes its assertions. It saves you from\nhaving to wrap everything in code that does that, and it makes it easier to read\nyour tests because there's less boilerplate in them.\n\nEmber includes several helpers to facilitate acceptance testing. There are two\ntypes of helpers: asynchronous and synchronous.\nAsynchronous Helpers\nAsynchronous helpers are \"aware\" of (and wait for) asynchronous behavior within\nyour application, making it much easier to write deterministic tests.\n\nAlso, these helpers register themselves in the order that you call them and will\nbe run in a chain; each one is only called after the previous one finishes. You can rest assured, therefore, that the order you call them in will also\nbe their execution order, and that the previous helper has finished before the\nnext one starts.\n\n\nclick(selector)\n\n\nClicks an element and triggers any actions triggered by the element's click\nevent and returns a promise that fulfills when all resulting async behavior\nis complete.\n\nfillIn(selector, text)\n\n\nFills in the selected input with the given text and returns a promise that\nfulfills when all resulting async behavior is complete. Works with \u003cselect\u003e elements as well as \u003cinput\u003e elements.\n\nkeyEvent(selector, type, keyCode)\n\n\nSimulates a key event type, e.g. keypress, keydown, keyup with the\ndesired keyCode on element found by the selector.\n\ntriggerEvent(selector, type, options)\n\n\nTriggers the given event, e.g. blur, dblclick on the element identified\nby the provided selector.\n\nvisit(url)\n\n\nVisits the given route and returns a promise that fulfills when all resulting\nasync behavior is complete.\n\n\nSynchronous Helpers\nSynchronous helpers are performed immediately when triggered.\n\n\ncurrentPath()\n\n\nReturns the current path.\n\ncurrentRouteName()\n\n\nReturns the currently active route name.\n\ncurrentURL()\n\n\nReturns the current URL.\n\nfind(selector, context)\n\n\nFinds an element within the app's root element and within the context\n(optional). Scoping to the root element is especially useful to avoid\nconflicts with the test framework's reporter, and this is done by default\nif the context is not specified.\n\n\nWait Helpers\nThe andThen helper will wait for all preceding asynchronous helpers to\ncomplete prior to progressing forward. Let's take a look at the following\nexample.\n\n  \n    \n      tests/acceptance/new-post-appears-first-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  test('simple test', function(assert) {\n  assert.expect(1); // Ensure that we will perform one assertion\n\n  visit('/posts/new');\n  fillIn('input.title', 'My new post');\n  click('button.submit');\n\n  // Wait for asynchronous helpers above to complete\n  andThen(function() {\n    assert.equal(find('ul.posts li:first').text(), 'My new post');\n  });\n});\n\n\n\nFirst we tell QUnit that this test should have one assertion made by the end\nof the test by calling assert.expect with an argument of 1. We then visit the new\nposts URL \"/posts/new\", enter the text \"My new post\" into an input control\nwith the CSS class \"title\", and click on a button whose class is \"submit\".\n\nWe then make a call to the andThen helper which will wait for the preceding\nasynchronous test helpers to complete (specifically, andThen will only be\ncalled after the new posts URL was visited, the text filled in and the\nsubmit button was clicked, and the browser has returned from doing whatever\nthose actions required). Note andThen has a single argument of the function\nthat contains the code to execute after the other test helpers have finished.\n\nIn the andThen helper, we finally make our call to assert.equal which makes an\nassertion that the text found in the first li of the ul whose class is \"posts\"\nis equal to \"My new post\".\nCustom Test Helpers\nFor creating your own test helper, just run ember generate test-helper\n\u003chelper-name\u003e. Here is the result of running ember g test-helper\nshouldHaveElementWithCount:\n\n  \n    \n      tests/helpers/should-have-element-with-count.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Test.registerAsyncHelper(\n    'shouldHaveElementWithCount', function(app) {\n\n});\n\n\n\nEmber.Test.registerAsyncHelper and Ember.Test.registerHelper are used to\nregister test helpers that will be injected when startApp is\ncalled. The difference between Ember.Test.registerHelper and\nEmber.Test.registerAsyncHelper is that the latter will not run until any\nprevious async helper has completed and any subsequent async helper will wait\nfor it to finish before running.\n\nThe helper method will always be called with the current Application as the\nfirst parameter. Other parameters need to be provided when calling the helper. Helpers need to be registered prior to calling\nstartApp, but ember-cli will take care of it for you.\n\nHere is an example of a non-async helper:\n\n  \n    \n      tests/helpers/should-have-element-with-count.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Test.registerHelper(\n    'shouldHaveElementWithCount',\n    function(app, assert, selector, n, context) {\n\n    var el = findWithAssert(selector, context);\n    var count = el.length;\n    assert.equal(n, count, 'found ' + count + ' times');\n  }\n);\n\n// shouldHaveElementWithCount(assert, \"ul li\", 3);\n\n\n\nHere is an example of an async helper:\n\n  \n    \n      tests/helpers/dblclick.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Test.registerAsyncHelper('dblclick',\n  function(app, assert, selector, context) {\n    var $el = findWithAssert(selector, context);\n    Ember.run(function() {\n      $el.dblclick();\n    });\n  }\n);\n\n// dblclick(\"#person-1\")\n\n\n\nAsync helpers also come in handy when you want to group interaction\ninto one helper. For example:\n\n  \n    \n      tests/helpers/add-contact.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Test.registerAsyncHelper('addContact',\n  function(app, assert, name, context) {\n    fillIn('#name', name);\n    click('button.create');\n  }\n);\n\n// addContact(\"Bob\");\n// addContact(\"Dan\");\n\n\n\nFinally, don't forget to add your helpers in tests/.jshintrc and in\ntests/helpers/start-app.js. In tests/.jshintrc you need to add it in the\npredef section, otherwise you will get failing jshint tests:\n\n  \n    \n      tests/.jshintc\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  {\n  \"predef\": [\n    \"document\",\n    \"window\",\n    \"location\",\n    ...\n    \"shouldHaveElementWithCount\",\n    \"dblclick\",\n    \"addContact\"\n  ],\n  ...\n}\n\n\n\nIn tests/helpers/start-app.js you just need to import the helper file: it\nwill be registered then.\n\n  \n    \n      tests/helpers/start-app.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import Ember from 'ember';\nimport Application from '../../app';\nimport Router from '../../router';\nimport config from '../../config/environment';\nimport shouldHaveElementWithCount from \"./should-have-element-with-count\";\nimport dblclick from \"./dblclick\";\nimport addContact from \"./add-contact\";\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a0e26dbd7878af23525081f7441c1b0","fields":[{"name":"title","value":"Testing Components","type":"string"},{"name":"url","value":"/testing/testing-components/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown\nin Unit Testing Basics because Ember.Component extends Ember.Object.\n\nComponents can be tested using the moduleForComponent helper.\n\nLet's assume we have a component with a style property that is updated\nwhenever the value for its name property changes. The style attribute of the\ncomponent is bound to its style property.\n\n\nYou can follow along by generating your own component with ember generate\ncomponent pretty-color.\n\n\n  \n    \n      app/components/pretty-color.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  attributeBindings: ['style'],\n\n  style: Ember.computed('name', function() {\n    return 'color: ' + this.get('name') + ';';\n  })\n});\n\n\n\n  \n    \n      app/templates/components/pretty-color.hbs\n    \n  \n\n  1\n\n  Pretty Color: {{name}}\n\n\n\nThe moduleForComponent helper will find the component by name (pretty-color)\nand its template (if available).\n\n  \n    \n      tests/unit/components/pretty-color-test.js\n    \n  \n\n  1\n2\n3\n4\n\n  moduleForComponent('pretty-color', {\n  // specify the other units that are required for this test\n  // needs: ['component:foo', 'helper:bar']\n});\n\n\n\nEach test following the moduleForComponent call has access to the subject()\nfunction, which lets us create a new instance of the component, as well as\nprovide any initial values we want it to have.\n\nWe can test that changing the component's name property updates the\ncomponent's style attribute and is reflected in the  rendered HTML:\n\n  \n    \n      tests/unit/components/pretty-color-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n  test('changing colors', function(assert) {\n  assert.expect(2);\n\n  // this.subject() is available because we used moduleForComponent\n  var component = this.subject({ name: 'red' });\n\n  // Renders the component to the page\n  this.render();\n\n  // Assert the initial style\n  assert.equal(this.$().attr('style'), 'color: red;');\n\n  // We wrap this with Ember.run because this.set is an async function\n  Ember.run(function() {\n    // Change the name\n    component.set('name', 'green');\n  });\n\n  // Assert the style has changed\n  assert.equal(this.$().attr('style'), 'color: green;');\n});\n\n\n\nWe might also test this component to ensure that the content of its template is\nbeing rendered properly:\n\n  \n    \n      tests/unit/components/pretty-color-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n  test('template is rendered with the color name', function(assert) {\n  assert.expect(2);\n\n  // this.subject() is available because we used moduleForComponent\n  var component = this.subject();\n\n  // Renders the component to the page\n  this.render();\n\n  // Assert initial content of the component\n  var initialContent = $.trim(this.$().text());\n  assert.equal(initialContent, 'Pretty Color:');\n\n  // we wrap this with Ember.run because it is an async function\n  Ember.run(function() {\n    component.set('name', 'green');\n  });\n\n  // Assert content of the component has changed\n  var finalContent = $.trim(this.$().text());\n  assert.equal(finalContent, 'Pretty Color: green');\n});\n\n\nTesting User Interaction\nComponents are a great way to create powerful, interactive, and self-contained\ncustom HTML elements. It is important to test the component's methods and the\nuser's interaction with the component.\n\nImagine you have the following component that changes its title when a button is\nclicked on:\n\n\nYou can follow along by generating your own component with ember generate\ncomponent magic-title.\n\n\n  \n    \n      app/components/magic-title.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  title: 'Hello World',\n\n  actions: {\n    updateTitle: function() {\n      this.set('title', 'This is Magic');\n    }\n  }\n});\n\n\n\n  \n    \n      app/templates/components/magic-title.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003ch2\u003e{{title}}\u003c/h2\u003e\n\n\u003cbutton {{action \"updateTitle\"}}\u003e\n  Update Title\n\u003c/button\u003e\n\n\n\njQuery triggers can be used to simulate user interaction and test that the title\nis updated when the button is clicked on:\n\n  \n    \n      tests/unit/components/magic-title-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  test('clicking the button updates the title', function(assert) {\n  assert.expect(2);\n\n  // Create the component instance\n  var component = this.subject();\n\n  // Assert the initial title\n  var initialTitle = this.$().find('h2').text();\n  assert.equal(initialTitle, 'Hello World');\n\n  // Click on the button\n  this.$().find('button').click();\n\n  // Assert that the title has changed\n  var finalTitle = this.$().find('h2').text();\n  assert.equal(finalTitle, 'Hello Ember World');\n});\n\n\nTesting Actions\nComponents often utilize the sendAction() method to send actions to other\nobjects in your application.\n\nFor example, imagine you have a comment form component that sends a specified\nsubmit action when the form is submitted, passing along the form's data:\n\n\nYou can follow along by generating your own component with ember generate\ncomponent comment-form.\n\n\n  \n    \n      app/components/comment-form.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  import Ember from 'ember';\n\nexport default Ember.Component.extend({\n  body: null,\n\n  actions: {\n    submit: function() {\n      var body = this.get('body');\n\n      this.sendAction('submit', { body: body });\n    }\n  }\n});\n\n\n\n  \n    \n      app/templates/components/comment-form.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  \u003cform {{action \"submit\" on=\"submit\"}}\u003e\n  \u003clabel\u003eComment:\u003c/label\u003e\n  {{textarea value=body}}\n\n  \u003cinput type=\"submit\" value=\"Submit\"\u003e\n\u003c/form\u003e\n\n\n\nYou might use this component in your application like this:\n\n  1\n\n  {{comment-form submit=\"createComment\"}}\n\n\n\nHere's an example test that asserts that the specified externalAction action\nis sent when the component's internal submit action is triggered by making use\nof a test double (dummy object):\n\n  \n    \n      tests/unit/components/comment-form-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n  test('external action is triggered when form is submitted', function(assert) {\n  // This is important to make sure that the test fails if\n  // our assertion is never called\n  assert.expect(1);\n\n  // Create our test double\n  var targetObject = {\n    externalAction: function(attributes) {\n      // This assertion will be called when the action is triggered\n      assert.deepEqual(attributes, { body: 'You are not a wizard!' });\n    }\n  };\n\n  // Creates the component\n  var component = this.subject({\n    // Sets sample data\n    body: 'You are not a wizard!',\n\n    // Sets the targetObject to our test double\n    // (this is where sendAction will send its action)\n    targetObject: targetObject,\n\n    // Specifies which action to send to targetObject on submit\n    submit: 'externalAction',\n  });\n\n  // Renders the component to the page\n  this.render();\n\n  // Submits the form\n  this.$().find('input[type=\"submit\"]').click();\n});\n\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b52674636f495b78ec905a98c63e1233","fields":[{"name":"title","value":"Testing Controllers","type":"string"},{"name":"url","value":"/testing/testing-controllers/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown\nin Unit Testing Basics because Ember.Controller extends Ember.Object.\n\nUnit testing controllers is very simple using the unit test helper which is part\nof the ember-qunit framework.\nTesting Controller Actions\nHere we have a controller PostsController with some computed properties and an\naction setProps.\n\n  \n    \n      app/controllers/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  export default Ember.Controller.extend({\n\n  propA: 'You need to write tests',\n  propB: 'And write one for me too',\n\n  setPropB: function(str) {\n    this.set('propB', str);\n  },\n\n  actions: {\n    setProps: function(str) {\n      this.set('propA', 'Testing is cool');\n      this.setPropB(str);\n    }\n  }\n});\n\n\n\nsetProps sets a property on the controller and also calls a method. In our \ngenerated test, ember-cli already uses the moduleFor helper to setup a test \ncontainer:\n\n  \n    \n      tests/unit/controllers/posts-test.js\n    \n  \n\n  1\n2\n3\n4\n\n  moduleFor('controller:posts', {\n  // Specify the other units that are required for this test.\n  // needs: ['controller:foo']\n});\n\n\n\nNext we use this.subject() to get an instance of the PostsController and\nwrite a test to check the action. this.subject() is a helper method from the\nember-qunit library that returns a singleton instance of the module set up\nusing moduleFor.\n\n  \n    \n      tests/unit/controllers/posts-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  test('calling the action setProps updates props A and B', function(assert) {\n  assert.expect(4);\n\n  // get the controller instance\n  var ctrl = this.subject();\n\n  // check the properties before the action is triggered\n  assert.equal(ctrl.get('propA'), 'You need to write tests');\n  assert.equal(ctrl.get('propB'), 'And write one for me too');\n\n  // trigger the action on the controller by using the `send` method,\n  // passing in any params that our action may be expecting\n  ctrl.send('setProps', 'Testing Rocks!');\n\n  // finally we assert that our values have been updated\n  // by triggering our action.\n  assert.equal(ctrl.get('propA'), 'Testing is cool');\n  assert.equal(ctrl.get('propB'), 'Testing Rocks!');\n});\n\n\nTesting Controller Needs\nSometimes controllers have dependencies on other controllers. This is\naccomplished by using needs. For example, here are two simple controllers. The\nPostController is a dependency of the CommentsController:\n\n  \n    \n      app/controllers/post.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Controller.extend({\n  title: Ember.computed.alias('model.title')\n});\n\n\n\n  \n    \n      app/controllers/comments.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  needs: 'post',\n  title: Ember.computed.alias('controllers.post.title'),\n});\n\n\n\nThis time when we setup our moduleFor we need to pass an options object as\nour third argument that has the controller's needs.\n\n  \n    \n      tests/unit/controllers/comments-test.js\n    \n  \n\n  1\n2\n3\n\n  moduleFor('controller:comments', 'Comments Controller', {\n  needs: ['controller:post']\n});\n\n\n\nNow let's write a test that sets a property on our post model in the\nPostController that would be available on the CommentsController.\n\n  \n    \n      tests/unit/controllers/comments-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  test('modify the post', function(assert) {\n  assert.expect(2);\n\n  // grab an instance of `CommentsController` and `PostController`\n  var ctrl = this.subject();\n  var postCtrl = ctrl.get('controllers.post');\n\n  // wrap the test in the run loop because we are dealing with async functions\n  Ember.run(function() {\n\n    // set a generic model on the post controller\n    postCtrl.set('model', Ember.Object.create({ title: 'foo' }));\n\n    // check the values before we modify the post\n    assert.equal(ctrl.get('title'), 'foo');\n\n    // modify the title of the post\n    postCtrl.get('model').set('title', 'bar');\n\n    // assert that the controllers title has changed\n    assert.equal(ctrl.get('title'), 'bar');\n  });\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9e4b1c3650cd96bd8485e0b98d722871","fields":[{"name":"title","value":"Testing Models","type":"string"},{"name":"url","value":"/testing/testing-models/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown \nin Unit Testing Basics because DS.Model extends Ember.Object.\n\nEmber Data Models can be tested using the moduleForModel helper.\n\nLet's assume we have a Player model that has level and levelName \nattributes. We want to call levelUp() to increment the level and assign a \nnew levelName when the player reaches level 5.\n\n  \n    \n      app/models/player.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default DS.Model.extend({\n  level:     DS.attr('number', { defaultValue: 0 }),\n  levelName: DS.attr('string', { defaultValue: 'Noob' }),\n\n  levelUp: function() {\n    var newLevel = this.incrementProperty('level');\n    if (newLevel === 5) {\n      this.set('levelName', 'Professional');\n    }\n  }\n});\n\n\n\nNow let's create a test which will call levelUp on the player when they are\nlevel 4 to assert that the levelName changes. We will use moduleForModel:\n\n  \n    \n      tests/unit/models/player-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  moduleForModel('player');\n\ntest('levelUp', function(assert) {\n  // this.subject aliases the createRecord method on the model\n  var player = this.subject({ level: 4 });\n\n  // wrap asynchronous call in run loop\n  Ember.run(function() {\n    player.levelUp();\n  });\n\n  assert.equal(player.get('level'), 5);\n  assert.equal(player.get('levelName'), 'Professional');\n});\n\n\nTesting Relationships\nFor relationships you probably only want to test that the relationship\ndeclarations are setup properly.\n\nAssume that a User can own a Profile.\n\n  \n    \n      app/models/profile.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n\n});\n\n\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  profile: DS.belongsTo('profile')\n});\n\n\n\nThen you could test that the relationship is wired up correctly\nwith this test.\n\n  \n    \n      tests/unit/models/user-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  moduleForModel('user', {\n  // Specify the other units that are required for this test.\n  needs: ['model:profile']\n});\n\ntest('profile relationship', function(assert) {\n  var User = this.store().modelFor('user');\n  var relationship = Ember.get(User, 'relationshipsByName').get('profile');\n\n  assert.equal(relationship.key, 'profile');\n  assert.equal(relationship.kind, 'belongsTo');\n});\n\n\n\nEmber Data contains extensive tests around the functionality of\nrelationships, so you probably don't need to duplicate those tests.  You could\nlook at the Ember Data tests for examples of deeper relationship testing if you\nfeel the need to do it.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"50d7d9948190dd788cabc6f1e832ec60","fields":[{"name":"title","value":"Testing Routes","type":"string"},{"name":"url","value":"/testing/testing-routes/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown \nin Unit Testing Basics because Ember.Route extends Ember.Object.\n\nTesting routes can be done both via acceptance or unit tests. Acceptance tests \nwill likely provide better coverage for routes because routes are typically used \nto perform transitions and load data, both of which are tested more easily in \nfull context rather than isolation.\n\nThat being said, sometimes it is important to unit test your routes. For example, \nlet's say we'd like to have an alert that can be triggered from anywhere within \nour application. The alert function displayAlert should be put into the \nApplicationRoute because all actions and events bubble up to it from \nsub-routes and controllers.\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Route.extend({\n  actions: {\n    displayAlert: function(text) {\n      this._displayAlert(text);\n    }\n  },\n\n  _displayAlert: function(text) {\n    alert(text);\n  }\n});\n\n\n\nThis is made possible by using moduleFor.\n\nIn this route we've separated our concerns:\nThe action displayAlert contains the code that is called when the action is \nreceived, and the private function _displayAlert performs the work. While not \nnecessarily obvious here because of the small size of the functions, separating \ncode into smaller chunks (or \"concerns\"), allows it to be more readily isolated \nfor testing, which in turn allows you to catch bugs more easily.\n\nHere is an example of how to unit test this route:\n\n  \n    \n      tests/unit/routes/application-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n  let originalAlert;\n\nmoduleFor('route:application', {\n  beforeEach: function() {\n    originalAlert = window.alert; // store a reference to window.alert\n  },\n\n  afterEach: function() {\n    window.alert = originalAlert; // restore window.alert\n  }\n});\n\ntest('Alert is called on displayAlert', function(assert) {\n  assert.expect(1);\n\n  // with moduleFor, the subject returns an instance of the route\n  var route = this.subject();\n  var expectedText = 'foo';\n\n  // stub window.alert to perform a qunit test\n  window.alert = function(text) {\n    assert.equal(text, expectedText, 'expected ' + text + ' to be ' + expectedText);\n  };\n\n  // call the _displayAlert function which triggers the qunit test above\n  route._displayAlert(expectedText);\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8cbbc37817038e7af55d7494378a4c9f","fields":[{"name":"title","value":"Testing User Interaction","type":"string"},{"name":"url","value":"/testing/testing-user-interaction/","type":"enum"},{"name":"body","value":"Almost every test has a pattern of visiting a route, interacting with the page\n(using the helpers), and checking for expected changes in the DOM.\n\nExample:\n\n  \n    \n      tests/acceptance/root-lists-first-page-of-posts-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  test('root lists first page of posts', function(assert){\n  visit('/posts');\n  andThen(function() {\n    assert.equal(find('ul.posts li').length, 3, 'The first page should have 3 posts');\n  });\n});\n\n\n\nThe helpers that perform actions use a global promise object and automatically\nchain onto that promise object if it exists. This allows you to write your tests\nwithout worrying about async behaviour your helper might trigger.\n\n  \n    \n      tests/acceptance/new-post-appears-first-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  var application;\nmodule('Acceptance: New Post Appears First', {\n  beforeEach: function() {\n    application = startApp();\n  },\n  afterEach: function() {\n    Ember.run(application, 'destroy');\n  }\n});\n\ntest('add new post', function(assert) {\n  visit('/posts/new');\n  fillIn('input.title', 'My new post');\n  click('button.submit');\n\n  andThen(function() {\n    assert.equal(find('ul.posts li:first').text(), 'My new post');\n  });\n});\n\n\nTesting Transitions\nSuppose we have an application which requires authentication. When a visitor\nvisits a certain URL as an unauthenticated user, we expect them to be transitioned\nto a login page.\n\n  \n    \n      app/routes/profile.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  beforeModel: function() {\n    var user = this.modelFor('application');\n    if (Ember.isEmpty(user)) {\n      this.transitionTo('login');\n    }\n  }\n});\n\n\n\nWe could use the route helpers to ensure that the user would be redirected to the login page\nwhen the restricted URL is visited.\n\n  \n    \n      tests/acceptance/transitions-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n  var application;\n\nmodule('Acceptance: Transitions', {\n  beforeEach: function() {\n    application = startApp();\n  },\n\n  afterEach: function() {\n    Ember.run(application, 'destroy');\n  }\n});\n\ntest('visiting /profile', function(assert) {\n  visit('/profile');\n\n  andThen(function() {\n    assert.equal(currentRouteName(), 'login');\n    assert.equal(currentPath(), 'login');\n    assert.equal(currentURL(), '/login');\n  });\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"1ce450bb46bb44d1336b990817414fae","fields":[{"name":"title","value":"Unit Test Helpers","type":"string"},{"name":"url","value":"/testing/unit-test-helpers/","type":"enum"},{"name":"body","value":"Globals vs Modules\nIn the past, it has been difficult to test portions of your Ember application\nwithout loading the entire app as a global. By having your application written\nusing modules (CommonJS, AMD, etc), you are able to require just code that\nis to be tested without having to pluck the pieces out of your global\napplication.\nUnit Testing Helpers\nEmber-QUnit is the default unit testing helper suite for Ember. It can and\nshould be used as a template for other test framework helpers. It uses your\napplication's resolver to find and automatically create test subjects for you\nusing the moduleFor and test helpers.\n\nA test subject is simply an instance of the object that a particular test is\nmaking assertions about. Usually test subjects are manually created by the\nwriter of the test.\n\n\n\nThe unit testing section of this guide will use the Ember-QUnit library, but\nthe concepts and examples should translate easily to other frameworks.\nAvailable Helpers\nBy including Ember-QUnit, you will have access to a number of test helpers.\n\n\nmoduleFor(fullName [, description [, callbacks]])\n\n\nfullName: The full name of the unit, (ie. controller:application,\nroute:index, etc.)\ndescription: the description of the module\ncallbacks: normal QUnit callbacks (beforeEach and afterEach), with addition to\nneeds, which allows you specify the other units the tests will need.\n\nmoduleForComponent(name [, description [, callbacks]])\n\n\nname: the short name of the component that you'd use in a template, (ie.\nx-foo, ic-tabs, etc.)\ndescription: the description of the module\ncallbacks: normal QUnit callbacks (beforeEach and afterEach), with addition to\nneeds, which allows you specify the other units the tests will need.\n\nmoduleForModel(name [, description [, callbacks]])\n\n\nname: the short name of the model you'd use in store\noperations (ie. user, assignmentGroup, etc.)\ndescription: the description of the module\ncallbacks: normal QUnit callbacks (beforeEach and afterEach), with addition to\nneeds, which allows you specify the other units the tests will need.\n\ntest\n\n\nSame as QUnit test except it includes the subject function which is used\nto create the test subject.\n\nsetResolver\n\n\nSets the resolver which will be used to lookup objects from the application\ncontainer.\n\n\nUnit Testing Setup\nIn order to unit test your Ember application, you need to let Ember know it is in\ntest mode. To do so, you must call Ember.setupForTesting().\n\n  1\n\n  Ember.setupForTesting();\n\n\n\nThe setupForTesting() function call makes ember turn off its automatic run\nloop execution. This gives us an ability to control the flow of the run loop\nourselves, to a degree. Its default behaviour of resolving all promises and\ncompleting all async behaviour are suspended to give you a chance to set up\nstate and make assertions in a known state. In other words, you know that if you\nrun \"visit\" to get to a particular URL, you can be sure the URL has been visited\nand that's the only behaviour that has transpired. If we didn't use this mode,\nour assertions would most likely be executed before the async behaviour had taken place, so our assertion results would be unpredictable.\nThe Resolver\nThe Ember resolver plays a huge role when unit testing your application. It\nprovides the lookup functionality based on name, such as route:index or\nmodel:post.\n\nIf you do not have a custom resolver or are testing a global Ember application,\nthe resolver should be set like this:\n\nMake sure to replace \"App\" with your application's namespace in the following line\n\n  1\n\n  setResolver(Ember.DefaultResolver.create({ namespace: App }))\n\n\n\nOtherwise, you would require the custom resolver and pass it to setResolver\nlike this (ES6 example):\n\n  1\n2\n3\n\n  import Resolver from './path/to/resolver';\nimport { setResolver } from 'ember-qunit';\nsetResolver(Resolver.create());\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8da16330e9a3a38299664dcc2f2233af","fields":[{"name":"title","value":"Unit Testing Basics","type":"string"},{"name":"url","value":"/testing/unit-testing-basics/","type":"enum"},{"name":"body","value":"Unit tests are generally used to test a small piece of code and ensure that it\nis doing what was intended. Unlike acceptance tests, they are narrow in scope\nand do not require the Ember application to be running.\n\nAs it is the basic object type in Ember, being able to test a simple\nEmber.Object sets the foundation for testing more specific parts of your\nEmber application such as controllers, components, etc. Testing an Ember.Object\nis as simple as creating an instance of the object, setting its state, and\nrunning assertions against the object. By way of example lets look at a few\ncommon cases.\nTesting Computed Properties\nLet's start by looking at an object that has a computedFoo computed property\nbased on a foo property.\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Object.extend({\n  foo: 'bar',\n\n  computedFoo: Ember.computed('foo', function() {\n    return 'computed ' + this.get('foo');\n  })\n});\n\n\n\nWithin the test we'll create an instance, update the foo property (which\nshould trigger the computed property), and assert that the logic in our\ncomputed property is working correctly.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import SomeThing from '\u003cyour-app-name\u003e/models/some-thing';\n\nmoduleFor('model:some-thing', 'Unit: some-thing');\n\ntest('computedFoo correctly concats foo', function(assert) {\n  var someThing = SomeThing.create({});\n\n  someThing.set('foo', 'baz');\n\n  assert.equal(someThing.get('computedFoo'), 'computed baz');\n});\n\n\n\nSee that we have used moduleFor one of the several unit-test helpers provided\nby Ember-Qunit.\nTesting Object Methods\nNext let's look at testing logic found within an object's method. In this case\nthe testMethod method alters some internal state of the object (by updating\nthe foo property).\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Object.extend({\n  foo: 'bar',\n  testMethod: function() {\n    this.set('foo', 'baz');\n  }\n});\n\n\n\nTo test it, we create an instance of our class SomeThing as defined above,\ncall the testMethod method and assert that the internal state is correct as a\nresult of the method call.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import SomeThing from '\u003cyour-app-name\u003e/models/some-thing';\n\nmoduleFor('model:some-thing', 'Unit: some-thing');\n\ntest('calling testMethod updated foo', function(assert) {\n  var someThing = SomeThing.create({});\n\n  someThing.testMethod();\n\n  assert.equal(someThing.get('foo'), 'baz');\n});\n\n\n\nIn the event the object's method returns a value you can simply assert that the\nreturn value is calculated correctly. Suppose our object has a calc method\nthat returns a value based on some internal state.\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Object.extend({\n  count: 0,\n  calc: function() {\n    this.incrementProperty('count');\n    return 'count: ' + this.get('count');\n  }\n});\n\n\n\nThe test would call the calc method and assert it gets back the correct value.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  import SomeThing from '\u003cyour-app-name\u003e/models/some-thing';\n\nmoduleFor('model:some-thing', 'Unit: some-thing');\n\ntest('calc returns incremented count', function(assert) {\n  var someThing = SomeThing.create({});\n  assert.equal(someThing.calc(), 'count: 1');\n  assert.equal(someThing.calc(), 'count: 2');\n});\n\n\nTesting Observers\nSuppose we have an object that has a property and a method observing that property.\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Object.extend({\n  foo: 'bar',\n  other: 'no',\n  doSomething: Ember.observer('foo', function(){\n    this.set('other', 'yes');\n  })\n});\n\n\n\nIn order to test the doSomething method we create an instance of SomeThing,\nupdate the observed property (foo), and assert that the expected effects are present.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  import SomeThing from '\u003cyour-app-name\u003e/models/some-thing';\n\nmoduleFor('model:some-thing', 'Unit: some-thing');\n\ntest('doSomething observer sets other prop', function() {\n  var someThing = SomeThing.create();\n  someThing.set('foo', 'baz');\n  equal(someThing.get('other'), 'yes');\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ee5ea607aecd946ab8c953297847e0b8","fields":[{"name":"title","value":"Debugging","type":"string"},{"name":"url","value":"/understanding-ember/debugging/","type":"enum"},{"name":"body","value":"Debugging Ember\nAll Ember developers should install the\nEmber Inspector\nwhich provides debugging and development tools for the browser.\n\nYou should also become comfortable with the browser debugging\ntooling for Chrome, Firefox, Safari, and Internet Explorer.\nRoutingLog router transitions\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Application.extend({\n  // Basic logging, e.g. \"Transitioned into 'post'\"\n  LOG_TRANSITIONS: true,\n\n  // Extremely detailed logging, highlighting every internal\n  // step made while transitioning into a route, including\n  // `beforeModel`, `model`, and `afterModel` hooks, and\n  // information about redirects and aborted transitions\n  LOG_TRANSITIONS_INTERNAL: true\n});\n\n\nViews / TemplatesLog view lookups\n  \n    \n      config/environment.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_VIEW_LOOKUPS = true;\n\n\n\n  1\n\n  Ember.keys(Ember.TEMPLATES)\n\n\nHandlebars Debugging Helpers\n  1\n2\n\n  {{debugger}}\n{{log model}}\n\n\nControllersLog generated controller\n  \n    \n      config/environment.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_ACTIVE_GENERATION = true;\n\n\nObservers / BindingSee all observers for a object, key\n  1\n\n  Ember.observersFor(comments, keyName);\n\n\nLog object bindings\n  \n    \n      config/environments.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_BINDINGS = true\n\n\nMiscellaneousTurn on resolver resolution logging\nThis option logs all the lookups that are done to the console. Custom objects\nyou've created yourself have a tick, and Ember generated ones don't.\n\nIt's useful for understanding which objects Ember is finding when it does a lookup\nand which it is generating automatically for you.\n\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Application.extend({\n  LOG_RESOLVER: true\n});\n\n\nDealing with deprecations\n  1\n2\n\n  Ember.ENV.RAISE_ON_DEPRECATION = true\nEmber.ENV.LOG_STACKTRACE_ON_DEPRECATION = true\n\n\nImplement an Ember.onerror hook to log all errors in production\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Ember.onerror = function(error) {\n  Ember.$.ajax('/error-notification', {\n    type: 'POST',\n    data: {\n      stack: error.stack,\n      otherInformation: 'exception message'\n    }\n  });\n}\n\n\nImport the console\nIf you are using imports with Ember, be sure to import the console:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  Ember = {\n  imports: {\n    Handlebars: Handlebars,\n    jQuery: $,\n    console: window.console\n  }\n};\n\n\nErrors within an RSVP.Promise\nThere are times when dealing with promises that it seems like any errors\nare being 'swallowed', and not properly raised. This makes it extremely\ndifficult to track down where a given issue is coming from. Thankfully,\nRSVP has a solution for this problem built in.\n\nYou can provide an onerror function that will be called with the error\ndetails if any errors occur within your promise. This function can be anything\nbut a common practice is to call console.assert to dump the error to the\nconsole.\n\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n\n  Ember.RSVP.on('error', function(error) {\n  Ember.Logger.assert(false, error);\n});\n\n\nErrors within Ember.run.later (Backburner.js)\nBackburner has support for stitching the stacktraces together so that you can\ntrack down where an erroring Ember.run.later is being initiated from. Unfortunately,\nthis is quite slow and is not appropriate for production or even normal development.\n\nTo enable this mode you can set:\n\n  1\n\n  Ember.run.backburner.DEBUG = true;\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ba55166358a3df3672dfc989bc7eee52","fields":[{"name":"title","value":"Dependency Injection \u0026 Service Lookup","type":"string"},{"name":"url","value":"/understanding-ember/dependency-injection-and-service-lookup/","type":"enum"},{"name":"body","value":"Dependency injection and service lookup are two important framework concepts. The first, dependency injection, refers to a dependent object being injected onto another object during instantiation. For example, all route objects have the property router set on them during instantiation. We say that the dependency of the router has been injected onto the route object.\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  actions: {\n    showPath() {\n      // Dependency injection provides the router object to the route instance.\n      alert(this.get('router.currentPath'));\n    }\n  }\n});\n\n\n\nSometimes an Ember.js library will use dependency injection to expose its API to developers. An example of this is Ember-Data, which injects its store into all routes and controllers.\n\n  \n    \n      app/controllers/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Controller.extend({\n  actions: {\n    findItems() {\n      // Dependency injection provides the store object to the controller instance.\n      this.store.findAll('item').then((items) =\u003e {\n        this.set('items', items);\n      });\n    }\n  }\n});\n\n\n\nThese are just two examples of how dependency injection, or DI, is used in Ember applications.\n\nThe second tool, service lookup, describes when a dependency is created or fetched on demand. Service lookup is the simpler pattern, and will be discussed first. Fundamentally, these two patterns share the same goals:\n\n\nIsolate responsibilities in an application\nAvoid the use of global variables and instances (important for testing)\nAllow a single object instance to represent state, but share that state with other objects.\n\nLightweight Services with Ember.inject\nA common use-case for service lookup is that of a singleton service. Often, these services will live near application state, and thus Ember provides an API that makes services easy to write.\n\nFor example, a session service can easily be made available to this index controller:\n\n  \n    \n      app/services/session.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Service.extend({\n  isAuthenticated: false\n});\n\n\n\n  \n    \n      app/controllers/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Controller.extend({\n  session: Ember.inject.service(),\n  // Using inject, the service instance will be available:\n  isLoggedIn: Ember.computed.reads('session.isAuthenticated')\n});\n\n\n\nEmber.inject bases the service it injects on the name of the property is is\nassigned to. If injecting a service with a different name than the property\nis required, that name can be passed as an argument to service().\n\nFor example, this component can take advantage of reading state from the\nsame singleton service instance:\n\n  \n    \n      app/components/sign-in-button.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Component.extend({\n  sessionService: Ember.inject.service('session'),\n  isLoggedIn: Ember.computed.alias('serviceService.isAuthenticated'),\n  actions: {\n    signIn() {\n      // There is an alias to the session property, so this change propagates\n      // to the session object then the IndexController.\n      this.set('isLoggedIn', true);\n    }\n  }\n});\n\n\n\nThe session object returned in both classes is the same.\nServices with DOM via components\nServices can be combined with components to create a serivce backed with DOM.\n\nLet's build a service that manages audio playback and makes it available to\nother components.\n\nFirst, we create an audio-player component and attach it to the DOM by using\nit in the application template.\n\n  1\n2\n3\n\n  {{! application.hbs }}\n{{audio-player}}\n{{outlet}}\n\n\n\nAnd we must create an app/templates/components/audio-player.hbs template to render:\n\n  \n    \n      app/templates/components/audio-player.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003caudio id=\"audio\" controls loop\u003e\n  \u003csource src={{audioService.currentSrc}} type=\"audio/mpeg\"\u003e\u003c/source\u003e\n\u003c/audio\u003e\n\u003cdiv\u003e{{audioService.currentSrc}}\u003c/div\u003e\n\n\n\nThe JavaScript of this component registers itself to the service to control\nplay functionality.\n\n  \n    \n      app/components/audio-player.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  audioService: Ember.inject.service('audio')\n});\n\n\n\nTo allow other controllers to play audio, we author a service that can set\ncurrentSrc to play audio:\n\n  \n    \n      app/services/audio.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Service.extend({\n  currentSrc: null,\n  selectSrc(src) {\n    this.set('currentSrc', src);\n  }\n});\n\n\n\nWhen another component injects the service audio, it has access to the same\nsingleton as the audio-player component. Those other components can call\nselectSrc and pass a new URL to be played.\n\nServices are a simple way to share behavior between controllers and isolate responsibilities in an application.\n\nFor a more powerful way to connect Ember.js components, let's look at dependency injection.\nDependency Management in Ember.js\nWhen an Ember application starts running, it will create and use a single instance of the\nEmber.Container object. This container object is responsible for managing factories and the dependencies between them. At the level of the container, a factory can be any framework component. The index template is a factory with the name template:index, and the application route is a factory with the name route:application. The container understands how to use these factories (are they singleton? Should they be instantiated?) and manages their dependencies.\n\nFactory names have two parts segmented by a :. The first segment is the framework component type, and the second is the name of the component requested. Hence, the show-posts component would be named component:show-posts.\n\nIf the container does not already have a requested factory, it uses a\nresolver to discover that factory. The resolver is responsible for\nmapping the name of component:show-posts to the JavaScript module\nlocated in the filesystem at app/components/show-posts.js.  After\noptionally adding dependencies to the requested factory, that factory is\ncached and returned.\n\nEmber's container should be viewed as an implementation detail, and is not part of the supported public API.\nDependency Injection with register/inject\nInstead of accessing the container directly, Ember provides an API for registering factories and managing injections on the application instance with an initializer\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export function initialize(container, application) {\n  var logger = {\n    log(message) {\n      console.log(message);\n    }\n  };\n\n  application.register('logger:main', logger, { instantiate: false });\n  application.inject('route', 'logger', 'logger:main');\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n\n\n\nInitializers can be declared at any time before an application is instantiated, making them easier to declare than directly registering factories on the application.\n\nAny dependency injection is comprised of two parts. The first is the factory registration:\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  var logger = {\n  log(m) {\n    console.log(m);\n  }\n};\n\napplication.register('logger:main', logger, { instantiate: false });\n\n\n\nThe register function adds the factory (logger) into the container. It adds it with the full name of logger:main, and with the option not to instantiate. When the factory is injected onto another object, it will be injected \"as-is\".\n\nOften, it is preferable to register a factory that can be instantiated:\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  var Logger = Ember.Object.extend({\n  log(m) {\n    console.log(m);\n  }\n});\n\napplication.register('logger:main', Logger);\n\n\n\nThis class will be instantiated before it is used by the container. This gives it the important benefit of being able to accept injections of its own.\n\nThe second part of dependency injection is, you guessed it, the dependency injection:\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n\n  application.inject('route', 'logger', 'logger:main');\n\n\n\nThis is an example of a type injection. Onto all factories of the type route the property, logger will be injected with the factory named logger:main. Routes in this example application can now access the logger:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Route.extend({\n  activate() {\n    // The logger property is injected into all routes\n    this.logger.log('Entered the index route!');\n  }\n});\n\n\n\nInjections can also be made on a specific factory by using its full name:\n\n  1\n\n  application.inject('route:index', 'logger', 'logger:main');\n\n\n\nInjections can be made onto all of Ember's major framework classes including components, controllers, routes, and the router.\n\nDependency injection and service lookup are two powerful tools in your Ember.js toolset, and every mature Ember application will require their use.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ead09a4fdf3e0a0ce7e4f5b67db647d7","fields":[{"name":"title","value":"The Run Loop","type":"string"},{"name":"url","value":"/understanding-ember/run-loop/","type":"enum"},{"name":"body","value":"Ember's internals and most of the code you will write in your applications takes place in a run loop. The run loop is used to\nbatch, and order (or reorder) work in a way that is most effective and efficient.\n\nIt does so by scheduling work on specific queues. These queues have a priority,\nand are processed to completion in priority order.\nWhy is this useful?\nVery often, batching similar work has benefits. Web browsers do something quite similar\nby batching changes to the DOM.\n\nConsider the following HTML snippet:\n\n  1\n2\n3\n\n  \u003cdiv id=\"foo\"\u003e\u003c/div\u003e\n\u003cdiv id=\"bar\"\u003e\u003c/div\u003e\n\u003cdiv id=\"baz\"\u003e\u003c/div\u003e\n\n\n\nand executing the following code:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  foo.style.height = \"500px\" // write\nfoo.offsetHeight // read (recalculate style, layout, expensive!)\n\nbar.style.height = \"400px\" // write\nbar.offsetHeight // read (recalculate style, layout, expensive!)\n\nbaz.style.height = \"200px\" // write\nbaz.offsetHeight // read (recalculate style, layout, expensive!)\n\n\n\nIn this example, the sequence of code forced the browser to recalculate style,\nand relayout after each step. However, if we were able to batch similar jobs together,\nthe browser would have only needed to recalculate the style and layout once.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  foo.style.height = \"500px\" // write\nbar.style.height = \"400px\" // write\nbaz.style.height = \"200px\" // write\n\nfoo.offsetHeight // read (recalculate style, layout, expensive!)\nbar.offsetHeight // read (fast since style and layout is already known)\nbaz.offsetHeight // read (fast since style and layout is already known)\n\n\n\nInterestingly, this pattern holds true for many other types of work. Essentially,\nbatching similar work allows for better pipelining, and further optimization.\n\nLet's look at a similar example that is optimized in Ember, starting with a User object:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var User = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  })\n});\n\n\n\nand a template to display its attributes:\n\n  1\n2\n\n  {{firstName}}\n{{fullName}}\n\n\n\nIf we execute the following code without the run loop:\n\n  1\n2\n3\n4\n5\n6\n\n  var user = User.create({ firstName: 'Tom', lastName: 'Huda' });\nuser.set('firstName', 'Yehuda');\n// {{firstName}} and {{fullName}} are updated\n\nuser.set('lastName', 'Katz');\n// {{lastName}} and {{fullName}} are updated\n\n\n\nWe see that the browser will rerender the template twice.\n\n  1\n2\n3\n4\n5\n\n  var user = User.create({firstName:'Tom', lastName:'Huda'});\nuser.set('firstName', 'Yehuda');\nuser.set('lastName', 'Katz');\n\n// {{firstName}}  {{lastName}} and {{fullName}} are updated\n\n\n\nHowever, if we have the run loop in the above code, the browser will only rerender the template once the attributes have all been set.\n\n  1\n2\n3\n4\n5\n\n  var user = User.create({ firstName: 'Tom', lastName: 'Huda' });\nuser.set('firstName', 'Yehuda');\nuser.set('lastName', 'Katz');\nuser.set('firstName', 'Tom');\nuser.set('lastName', 'Huda');\n\n\n\nIn the above example with the run loop, since the user's attributes end up at the same values as before execution, the template will not even rerender!\n\nIt is of course possible to optimize these scenarios on a case-by-case basis,\nbut getting them for free is much nicer. Using the run loop, we can apply these\nclasses of optimizations not only for each scenario, but holistically app-wide.\nHow does the Run Loop work in Ember?\nAs mentioned earlier, we schedule work (in the form of function invocations) on\nqueues, and these queues are processed to completion in priority order.\n\nWhat are the queues, and what is their priority order?\n\n  1\n2\n\n  Ember.run.queues\n// =\u003e [\"sync\", \"actions\", \"routerTransitions\", \"render\", \"afterRender\", \"destroy\"]\n\n\n\nBecause the priority is first to last, the \"sync\" queue has higher priority than the \"render\" or \"destroy\" queue.\nWhat happens in these queues?\n\nThe sync queue contains binding synchronization jobs\nThe actions queue is the general work queue and will typically contain scheduled tasks e.g. promises\nThe routerTransitions queue contains transition jobs in the router\nThe render queue contains jobs meant for rendering, these will typically update the DOM\nThe afterRender contains jobs meant to be run after all previously scheduled render tasks are complete. This is often good for 3rd-party DOM manipulation libraries, that should only be run after an entire tree of DOM has been updated\nThe destroy queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy\n\nIn what order are jobs executed on the queues?\nThe algorithm works this way:\n\n\nLet the highest priority queue with pending jobs be: CURRENT_QUEUE, if there are no queues with pending jobs the run loop is complete\nLet a new temporary queue be defined as WORK_QUEUE\nMove jobs from CURRENT_QUEUE into WORK_QUEUE\nProcess all the jobs sequentially in WORK_QUEUE\nReturn to Step 1\n\nAn example of the internals\nRather than writing the higher level app code that internally invokes the various\nrun loop scheduling functions, we have stripped away the covers, and shown the raw run-loop interactions.\n\nWorking with this API directly is not common in most Ember apps, but understanding this example will\nhelp you to understand the run-loops algorithm, which will make you a better Ember developer.\n\n\nFAQsWhat do I need to know to get started with Ember?\nFor basic Ember app development scenarios, nothing. All common paths are paved nicely\nfor you and don't require working with the run loop directly.\nWhat do I need to know to actually build an app?\nIt is possible to build good apps without working with the run loop directly, so if\nyou don't feel the need to do so, don't.\nWhat scenarios will require me to understand the run loop?\nThe most common case you will run into is integrating with a non-Ember API\nthat includes some sort of asynchronous callback. For example:\n\n\nAJAX callbacks\nDOM update and event callbacks\nWebsocket callbacks\nsetTimeout and setInterval callbacks\npostMessage and messageChannel event handlers\n\n\nYou should begin a run loop when the callback fires.\nHow do I tell Ember to start a run loop?\nThe Ember.run method can be used to create a runloop. In this example, jQuery\nand Ember.run are used to handle a click event and run some Ember code.\n\nThis example uses the =\u003e function syntax, which is a new ES2015 syntax for\ncallback functions that provides a lexical this. If this syntax is new,\nthink of it as a function that has the same this as the context it is\ndefined in.\n\n  1\n2\n3\n4\n5\n\n  $('a').click(() =\u003e {\n  Ember.run(() =\u003e {  // begin loop\n    // Code that results in jobs being scheduled goes here\n  }); // end loop, jobs are flushed and executed\n});\n\n\nWhat happens if I forget to start a run loop in an async handler?\nAs mentioned above, you should wrap any non-Ember async callbacks in\nEmber.run. If you don't, Ember will try to approximate a beginning and end for you.\nConsider the following callback:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  $('a').click(() =\u003e {\n  console.log('Doing things...');\n\n  Ember.run.schedule('actions', () =\u003e {\n    // Do more things\n  });\n  Ember.run.scheduleOnce('afterRender', () =\u003e {\n    // Yet more things\n  });\n});\n\n\n\nThe runloop API calls that schedule work i.e. run.schedule,\nrun.scheduleOnce, run.once have the property that they will approximate a\nrunloop for you if one does not already exist. These automatically created\nrunloops we call autoruns.\n\nHere is some pseudocode to describe what happens using the example above:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n  $('a').click(() =\u003e {\n  // 1. autoruns do not change the execution of arbitrary code in a callback.\n  //    This code is still run when this callback is executed and will not be\n  //    scheduled on an autorun.\n  console.log('Doing things...');\n\n  Ember.run.schedule('actions', () =\u003e {\n    // 2. schedule notices that there is no currently available runloop so it\n    //    creates one. It schedules it to close and flush queues on the next\n    //    turn of the JS event loop.\n    if (! Ember.run.hasOpenRunloop()) {\n      Ember.run.start();\n      nextTick(() =\u003e {\n        Ember.run.end()\n      }, 0);\n    }\n\n    // 3. There is now a runloop available so schedule adds its item to the\n    //    given queue\n    Ember.run.schedule('actions', () =\u003e {\n      // Do more things\n    });\n\n  });\n\n  // 4. scheduleOnce sees the autorun created by schedule above as an available\n  //    runloop and adds its item to the given queue.\n  Ember.run.scheduleOnce('afterRender', () =\u003e {\n    // Yet more things\n  });\n\n});\n\n\n\nAlthough autoruns are convenient, they are suboptimal. The current JS frame is\nallowed to end before the run loop is flushed, which sometimes means the browser\nwill take the opportunity to do other things, like garbage collection. GC\nrunning in between data changing and DOM rerendering can cause visual lag and\nshould be minimized.\n\nRelying on autoruns is not a rigorous or efficient way to use the runloop.\nWrapping event handlers manually is preferred.\nHow is runloop behaviour different when testing?\nWhen your application is in testing mode then\nEmber will throw an error if you try to schedule work without an available\nrunloop.\n\nAutoruns are disabled in testing for several reasons:\n\n\nAutoruns are Embers way of not punishing you in production if you forget to\nopen a runloop before you schedule callbacks on it. While this is useful in\nproduction, these are still situations that should be revealed in testing to\nhelp you find and fix them.\nSome of Ember's test helpers are promises that wait for the run loop to empty\nbefore resolving. If your application has code that runs outside a runloop,\nthese will resolve too early and give erroneous test failures which are\ndifficult to find. Disabling autoruns help you identify these scenarios and\nhelps both your testing and your application!\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]}]}