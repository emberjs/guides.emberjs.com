{"documents": [{"external_id":"712e5fb8e95aa39cf5b12ffb170cec61","fields":[{"name":"title","value":"Managing Dependencies","type":"string"},{"name":"url","value":"/addons-and-dependencies/managing-dependencies/","type":"enum"},{"name":"body","value":"As you're developing your Ember app, you'll likely run into common scenarios that aren't addressed by Ember itself, such as authentication or using SASS for your stylesheets. Ember CLI provides a common format called Ember Addons for distributing reusable libraries to solve these problems. Additionally, you may want to make use of front-end dependencies like a CSS framework or a JavaScript datepicker that aren't specific to Ember apps. Ember CLI supports installing these packages through the standard Bower package manager.\nAddons\nEmber Addons are installed using NPM (eg. npm install --save-dev ember-cli-sass). Addons\nmay bring in other dependencies by modifying your project's bower.json file\nautomatically.\n\nYou can find listings of addons on Ember Observer.\nBower\nEmber CLI uses the Bower package manager, making it easy\nto keep your front-end dependencies up to date. The Bower configuration file, bower.json, is located at the root of your Ember\nCLI project, and lists the dependencies for your project. Executing bower install\nwill install all of the dependencies listed in bower.json in one step.\n\nEmber CLI watches bower.json for changes. Thus it reloads your app if you\ninstall new dependencies via bower install \u003cdependencies\u003e --save.\nOther assets\nAssets not available as an addon or Bower package should be placed in the vendor folder in your project.\nCompiling Assets\nWhen you're using dependencies that are not included in an addon, you will\nhave to instruct Ember CLI to include your assets in the build. This is done using\nthe asset manifest file ember-cli-build.js. You should only try to import assets\nlocated in the bower_components and vendor folders.\nGlobals provided by Javascript assets\nThe globals provided by some assets (like moment in the below example) can be\nused in your application without the need to import them.  Provide the asset\npath as the first and only argument.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n\n  app.import('bower_components/moment/moment.js');\n\n\n\nYou will need to add \"moment\": true to the predef section in .jshintrc to\nprevent JSHint errors about using an undefined variable.\nAMD Javascript modules\nProvide the asset path as the first argument, and the list of modules and exports as the second.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  app.import('bower_components/ic-ajax/dist/named-amd/main.js', {\n  exports: {\n    'ic-ajax': [\n      'default',\n      'defineFixture',\n      'lookupFixture',\n      'raw',\n      'request'\n    ]\n  }\n});\n\n\n\nYou can now import them in your app. Eg. import { raw as icAjaxRaw } from 'ic-ajax';\nEnvironment Specific Assets\nIf you need to use different assets in different environments, specify an object as the first parameter. That object's key should be the environment name, and the value should be the asset to use in that environment.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n2\n3\n4\n\n  app.import({\n  development: 'bower_components/ember/ember.js',\n  production:  'bower_components/ember/ember.prod.js'\n});\n\n\n\nIf you need to import an asset in only one environment you can wrap app.import in an if statement.\nFor assets needed during testing, you should also use the {type: 'test'} option to make sure they\nare available in test mode.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  if (app.env === 'development') {\n  // Only import when in development mode\n  app.import('vendor/ember-renderspeed/ember-renderspeed.js');\n}\nif (app.env === 'test') {\n  // Only import in test mode and place in test-supoprt.js\n  app.import(app.bowerDirectory + '/sinonjs/sinon.js', { type: 'test' });\n  app.import(app.bowerDirectory + '/sinon-qunit/lib/sinon-qunit.js', { type: 'test' });\n}\n\n\nCSS\nProvide the asset path as the first argument:\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n\n  app.import('bower_components/foundation/css/foundation.css');\n\n\n\nAll style assets added this way will be concatenated and output as /assets/vendor.css.\nOther Assets\nAll other assets like images or fonts can also be added via import(). By default, they\nwill be copied to dist/ as they are.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n\n  app.import('bower_components/font-awesome/fonts/fontawesome-webfont.ttf');\n\n\n\nThis example would create the font file in dist/font-awesome/fonts/fontawesome-webfont.ttf.\n\nYou can also optionally tell import() to place the file at a different path.\nThe following example will copy the file to dist/assets/fontawesome-webfont.ttf.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n2\n3\n\n  app.import('bower_components/font-awesome/fonts/fontawesome-webfont.ttf', {\n  destDir: 'assets'\n});\n\n\n\nIf you need to load certain dependencies before others, you can set the prepend property equal to true on the second argument of import(). This will prepend the dependency to the vendor file instead of appending it, which is the default behavior.\n\n  \n    \n      ember-cli-build.js\n    \n  \n\n  1\n2\n3\n4\n\n  app.import('bower_components/es5-shim/es5-shim.js', {\n  type: 'vendor',\n  prepend: true\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e1e33e1164aae59122e344151a7b6a4f","fields":[{"name":"title","value":"Applications and Instances","type":"string"},{"name":"url","value":"/applications/applications-and-instances/","type":"enum"},{"name":"body","value":"Every Ember application is represented by a class that extends\nEmber.Application. This class is used to declare and configure the many\nobjects that make up your app.\n\nAs your application boots, it creates an Ember.ApplicationInstance that is\nused to manage its stateful aspects. This instance acts as a container for the\nobjects instantiated for your app.\n\nEssentially, the Application defines your application while the\nApplicationInstance manages its state.\n\nThis separation of concerns not only clarifies the architecture of your app, it\ncan also improve its efficiency. This is particularly true when your app needs\nto be booted repeatedly during testing and / or server-rendering (e.g. via\nFastBoot). The configuration of\na single Application can be done once and shared among multiple stateful\nApplicationInstance instances. These instances can be discarded once they're\nno longer needed (e.g. when a test run or FastBoot request has finished).\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6dc47d4b01c5fc819e641b21e5148081","fields":[{"name":"title","value":"Dependency Injection","type":"string"},{"name":"url","value":"/applications/dependency-injection/","type":"enum"},{"name":"body","value":"Ember applications utilize the dependency\ninjection (\"DI\") design\npattern to declare and instantiate classes of objects and dependencies between\nthem. Applications and application instances each serve a role in Ember's DI\nimplementation.\n\nAn Ember.Application serves as a \"registry\" for dependency declarations.\nFactories (i.e. classes) are registered with an application, as well as rules\nabout \"injecting\" dependencies that are applied when objects are instantiated.\n\nAn Ember.ApplicationInstance serves as a \"container\" for objects that are\ninstantiated from registered factories. Application instances provide a means to\n\"look up\" (i.e. instantiate and / or retrieve) objects.\n\n\nNote: Although an Application serves as the primary registry for an app,\neach ApplicationInstance can also serve as a registry. Instance-level\nregistrations are useful for providing instance-level customizations, such as\nA/B testing of a feature.\n\nFactory Registrations\nA factory can represent any part of your application, like a route,\ntemplate, or custom class. Every factory is registered with a particular key.\nFor example, the index template is registered with the key template:index, and\nthe application route is registered with the key route:application.\n\nRegistration keys have two segments split by a colon (:). The first segment is\nthe framework factory type, and the second is the name of the particular\nfactory. Hence, the index template has the key template:index. Ember has\nseveral built-in factory types, such as service, route, template, and\ncomponent.\n\nYou can create your own factory type by simply registering a factory with the\nnew type. For example, to create a user type, you'd simply register your\nfactory with application.register('user:user-to-register').\n\nFactory registrations must be performed either in application or application\ninstance initializers (with the former being much more common).\n\nFor example, an application initializer could register a Logger factory with\nthe key logger:main:\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export function initialize(application) {\n  var Logger = Ember.Object.extend({\n    log(m) {\n      console.log(m);\n    }\n  });\n\n  application.register('logger:main', Logger);\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n\n\nRegistering Already Instantiated Objects\nBy default, Ember will attempt to instantiate a registered factory when it is\nlooked up. When registering an already instantiated object instead of a class,\nuse the instantiate: false option to avoid attempts to re-instantiate it\nduring lookups.\n\nIn the following example, the logger is a plain JavaScript object that should\nbe returned \"as is\" when it's looked up:\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export function initialize(application) {\n  var logger = {\n    log(m) {\n      console.log(m);\n    }\n  };\n\n  application.register('logger:main', logger, { instantiate: false });\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n\n\nRegistering Singletons vs. Non-Singletons\nBy default, registrations are treated as \"singletons\". This simply means that\nan instance will be created when it is first looked up, and this same instance\nwill be cached and returned from subsequent lookups.\n\nWhen you want fresh objects to be created for every lookup, register your\nfactories as non-singletons using the singleton: false option.\n\nIn the following example, the Message class is registered as a non-singleton:\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export function initialize(application) {\n  var Message = Ember.Object.extend({\n    text: ''\n  });\n\n  application.register('notification:message', Message, { singleton: false });\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n\n\nFactory Injections\nOnce a factory is registered, it can be \"injected\" where it is needed.\n\nFactories can be injected into whole \"types\" of factories with type\ninjections. For example:\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export function initialize(application) {\n  var Logger = Ember.Object.extend({\n    log(m) {\n      console.log(m);\n    }\n  });\n\n  application.register('logger:main', Logger);\n  application.inject('route', 'logger', 'logger:main');\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n\n\n\nAs a result of this type injection, all factories of the type route will be\ninstantiated with the property logger injected. The value of logger will\ncome from the factory named logger:main.\n\nRoutes in this example application can now access the injected logger:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Route.extend({\n  activate() {\n    // The logger property is injected into all routes\n    this.get('logger').log('Entered the index route!');\n  }\n});\n\n\n\nInjections can also be made on a specific factory by using its full key:\n\n  1\n\n  application.inject('route:index', 'logger', 'logger:main');\n\n\n\nIn this case, the logger will only be injected on the index route.\n\nInjections can be made onto any class that requires instantiation. This includes\nall of Ember's major framework classes, such as components, helpers, routes, and\nthe router.\nAd Hoc Injections\nDependency injections can also be declared directly on Ember classes using\nEmber.inject. Currently, Ember.inject supports injecting controllers (via\nEmber.inject.controller) and services (via Ember.inject.service).\n\nThe following code injects the shopping-cart service on the cart-contents\ncomponent as the property cart:\n\n  \n    \n      app/components/cart-contents.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  cart: Ember.inject.service('shopping-cart')\n});\n\n\n\nIf you'd like to inject a service with the same name as the property, simply\nleave off the service name (the dasherized version of the name will be used):\n\n  \n    \n      app/components/cart-contents.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  shoppingCart: Ember.inject.service()\n});\n\n\nFactory Lookups\nThe vast majority of Ember registrations and lookups are performed implicitly.\n\nIn the rare cases in which you want to perform an explicit lookup of a\nregistered factory, you can do so on an application instance in its associated\ninstance initializer. For example:\n\n  \n    \n      app/instance-initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export function initialize(applicationInstance) {\n  var logger = applicationInstance.lookup('logger:main');\n\n  logger.log('Hello from the instance initializer!');\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d42b8021b21156225227a3820a1acfb2","fields":[{"name":"title","value":"Initializers","type":"string"},{"name":"url","value":"/applications/initializers/","type":"enum"},{"name":"body","value":"Initializers provide an opportunity to configure your application as it boots.\n\nThere are two types of initializers: application initializers and application\ninstance initializers.\n\nApplication initializers are run as your application boots, and provide the\nprimary means to configure dependency injections in\nyour application.\n\nApplication instance initializers are run as an application instance is loaded.\nThey provide a way to configure the initial state of your application, as well\nas to set up dependency injections that are local to the application instance\n(e.g. A/B testing confurations).\n\nOperations performed in initializers should be kept as lightweight as possible\nto minimize delays in loading your application. Although advanced techniques\nexist for allowing asynchrony in application initializers (i.e. deferReadiness\nand advanceReadiness), these techniques should generally be avoided. Any\nasynchronous loading conditions (e.g. user authorization) are almost always\nbetter handled in your application route's hooks, which allows for DOM\ninteraction while waiting for conditions to resolve.\nApplication Initializers\nApplication initializers can be created with Ember CLI's initializer\ngenerator:\n\n  1\n\n  ember generate initializer shopping-cart\n\n\n\nLet's customize the shopping-cart initializer to inject a cart property into\nall the routes in your application:\n\n  \n    \n      app/initializers/shopping-cart.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export function initialize(application) {\n  application.inject('route', 'cart', 'service:shopping-cart');\n};\n\nexport default {\n  name: 'shopping-cart',\n  initialize: initialize\n};\n\n\nApplication Instance Initializers\nApplication instance initializers can be created with Ember CLI's\ninstance-initializer generator:\n\n  1\n\n  ember generate instance-initializer logger\n\n\n\nLet's add some simple logging to indicate that the instance has booted:\n\n  \n    \n      app/instance-initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export function initialize(applicationInstance) {\n  var logger = applicationInstance.lookup('logger:main');\n  logger.log('Hello from the instance initializer!');\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n\n\nSpecifying Initializer Order\nIf you'd like to control the order in which initializers run, you can use the\nbefore and/or after options:\n\n  \n    \n      app/initializers/config-reader.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export function initialize(application) {\n  // ... your code ...\n};\n\nexport default {\n  name: 'configReader',\n  before: 'websocketInit',\n  initialize: initialize\n};\n\n\n\n  \n    \n      app/initializers/websocket-init.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export function initialize(application) {\n  // ... your code ...\n};\n\nexport default {\n  name: 'websocketInit',\n  after: 'configReader',\n  initialize: initialize\n};\n\n\n\nNote that ordering only applies to initializers of the same type (i.e.\napplication or application instance). Application initializers will always run\nbefore application instance initializers.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a840458ea333b782c4c091667a396113","fields":[{"name":"title","value":"The Run Loop","type":"string"},{"name":"url","value":"/applications/run-loop/","type":"enum"},{"name":"body","value":"Ember's internals and most of the code you will write in your applications takes\nplace in a run loop. The run loop is used to\nbatch, and order (or reorder) work in a way that is most effective and efficient.\n\nIt does so by scheduling work on specific queues. These queues have a priority,\nand are processed to completion in priority order.\n\nFor basic Ember app development scenarios, you don't need to understand the run\nloop or use it directly. All common paths are paved nicely\nfor you and don't require working with the run loop directly.\n\nThe most common case for using the run loop is integrating with a non-Ember API\nthat includes some sort of asynchronous callback. For example:\n\n\nDOM update and event callbacks\nsetTimeout and setInterval callbacks\npostMessage and messageChannel event handlers\nAJAX callbacks\nWebsocket callbacks\n\nWhy is the run loop useful?\nVery often, batching similar work has benefits. Web browsers do something quite similar\nby batching changes to the DOM.\n\nConsider the following HTML snippet:\n\n  1\n2\n3\n\n  \u003cdiv id=\"foo\"\u003e\u003c/div\u003e\n\u003cdiv id=\"bar\"\u003e\u003c/div\u003e\n\u003cdiv id=\"baz\"\u003e\u003c/div\u003e\n\n\n\nand executing the following code:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  foo.style.height = '500px' // write\nfoo.offsetHeight // read (recalculate style, layout, expensive!)\n\nbar.style.height = '400px' // write\nbar.offsetHeight // read (recalculate style, layout, expensive!)\n\nbaz.style.height = '200px' // write\nbaz.offsetHeight // read (recalculate style, layout, expensive!)\n\n\n\nIn this example, the sequence of code forced the browser to recalculate style,\nand relayout after each step. However, if we were able to batch similar jobs together,\nthe browser would have only needed to recalculate the style and layout once.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  foo.style.height = '500px' // write\nbar.style.height = '400px' // write\nbaz.style.height = '200px' // write\n\nfoo.offsetHeight // read (recalculate style, layout, expensive!)\nbar.offsetHeight // read (fast since style and layout is already known)\nbaz.offsetHeight // read (fast since style and layout is already known)\n\n\n\nInterestingly, this pattern holds true for many other types of work. Essentially,\nbatching similar work allows for better pipelining, and further optimization.\n\nLet's look at a similar example that is optimized in Ember, starting with a User object:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var User = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return `${this.get('firstName')} ${this.get('lastName')}`;\n  })\n});\n\n\n\nand a template to display its attributes:\n\n  1\n2\n\n  {{firstName}}\n{{fullName}}\n\n\n\nIf we execute the following code without the run loop:\n\n  1\n2\n3\n4\n5\n6\n\n  var user = User.create({ firstName: 'Tom', lastName: 'Huda' });\nuser.set('firstName', 'Yehuda');\n// {{firstName}} and {{fullName}} are updated\n\nuser.set('lastName', 'Katz');\n// {{lastName}} and {{fullName}} are updated\n\n\n\nWe see that the browser will rerender the template twice.\n\nHowever, if we have the run loop in the above code, the browser will only rerender the template once the attributes have all been set.\n\n  1\n2\n3\n4\n5\n\n  var user = User.create({ firstName: 'Tom', lastName: 'Huda' });\nuser.set('firstName', 'Yehuda');\nuser.set('lastName', 'Katz');\nuser.set('firstName', 'Tom');\nuser.set('lastName', 'Huda');\n\n\n\nIn the above example with the run loop, since the user's attributes end up at the same values as before execution, the template will not even rerender!\n\nIt is of course possible to optimize these scenarios on a case-by-case basis,\nbut getting them for free is much nicer. Using the run loop, we can apply these\nclasses of optimizations not only for each scenario, but holistically app-wide.\nHow does the Run Loop work in Ember?\nAs mentioned earlier, we schedule work (in the form of function invocations) on\nqueues, and these queues are processed to completion in priority order.\n\nWhat are the queues, and what is their priority order?\n\n  1\n2\n\n  Ember.run.queues\n// =\u003e [\"sync\", \"actions\", \"routerTransitions\", \"render\", \"afterRender\", \"destroy\"]\n\n\n\nBecause the priority is first to last, the \"sync\" queue has higher priority than the \"render\" or \"destroy\" queue.\nWhat happens in these queues?\n\nThe sync queue contains binding synchronization jobs\nThe actions queue is the general work queue and will typically contain scheduled tasks e.g. promises\nThe routerTransitions queue contains transition jobs in the router\nThe render queue contains jobs meant for rendering, these will typically update the DOM\nThe afterRender queue contains jobs meant to be run after all previously scheduled render tasks are complete. This is often good for 3rd-party DOM manipulation libraries, that should only be run after an entire tree of DOM has been updated\nThe destroy queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy\n\nIn what order are jobs executed on the queues?\nThe algorithm works this way:\n\n\nLet the highest priority queue with pending jobs be: CURRENT_QUEUE, if there are no queues with pending jobs the run loop is complete\nLet a new temporary queue be defined as WORK_QUEUE\nMove jobs from CURRENT_QUEUE into WORK_QUEUE\nProcess all the jobs sequentially in WORK_QUEUE\nReturn to Step 1\n\nAn example of the internals\nRather than writing the higher level app code that internally invokes the various\nrun loop scheduling functions, we have stripped away the covers, and shown the raw run-loop interactions.\n\nWorking with this API directly is not common in most Ember apps, but understanding this example will\nhelp you to understand the run-loops algorithm, which will make you a better Ember developer.\n\n\nHow do I tell Ember to start a run loop?\nYou should begin a run loop when the callback fires.\n\nThe Ember.run method can be used to create a runloop. In this example, jQuery\nand Ember.run are used to handle a click event and run some Ember code.\n\nThis example uses the =\u003e function syntax, which is a new ES2015 syntax for\ncallback functions that provides a lexical this. If this syntax is new,\nthink of it as a function that has the same this as the context it is\ndefined in.\n\n  1\n2\n3\n4\n5\n\n  $('a').click(() =\u003e {\n  Ember.run(() =\u003e {  // begin loop\n    // Code that results in jobs being scheduled goes here\n  }); // end loop, jobs are flushed and executed\n});\n\n\nWhat happens if I forget to start a run loop in an async handler?\nAs mentioned above, you should wrap any non-Ember async callbacks in\nEmber.run. If you don't, Ember will try to approximate a beginning and end for you.\nConsider the following callback:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  $('a').click(() =\u003e {\n  console.log('Doing things...');\n\n  Ember.run.schedule('actions', () =\u003e {\n    // Do more things\n  });\n});\n\n\n\nThe runloop API calls that schedule work i.e. run.schedule,\nrun.scheduleOnce, run.once have the property that they will approximate a\nrunloop for you if one does not already exist. These automatically created\nrunloops we call autoruns.\n\nHere is some pseudocode to describe what happens using the example above:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n  $('a').click(() =\u003e {\n  // 1. autoruns do not change the execution of arbitrary code in a callback.\n  //    This code is still run when this callback is executed and will not be\n  //    scheduled on an autorun.\n  console.log('Doing things...');\n\n  Ember.run.schedule('actions', () =\u003e {\n    // 2. schedule notices that there is no currently available runloop so it\n    //    creates one. It schedules it to close and flush queues on the next\n    //    turn of the JS event loop.\n    if (! Ember.run.hasOpenRunloop()) {\n      Ember.run.start();\n      nextTick(() =\u003e {\n        Ember.run.end()\n      }, 0);\n    }\n\n    // 3. There is now a runloop available so schedule adds its item to the\n    //    given queue\n    Ember.run.schedule('actions', () =\u003e {\n      // Do more things\n    });\n\n  });\n\n  // 4. This schedule sees the autorun created by schedule above as an available\n  //    runloop and adds its item to the given queue.\n  Ember.run.schedule('afterRender', () =\u003e {\n    // Do yet more things\n  });\n});\n\n\n\nAlthough autoruns are convenient, they are suboptimal. The current JS frame is\nallowed to end before the run loop is flushed, which sometimes means the browser\nwill take the opportunity to do other things, like garbage collection. GC\nrunning in between data changing and DOM rerendering can cause visual lag and\nshould be minimized.\n\nRelying on autoruns is not a rigorous or efficient way to use the runloop.\nWrapping event handlers manually is preferred.\nHow is runloop behaviour different when testing?\nWhen your application is in testing mode then\nEmber will throw an error if you try to schedule work without an available\nrunloop.\n\nAutoruns are disabled in testing for several reasons:\n\n\nAutoruns are Embers way of not punishing you in production if you forget to\nopen a runloop before you schedule callbacks on it. While this is useful in\nproduction, these are still situations that should be revealed in testing to\nhelp you find and fix them.\nSome of Ember's test helpers are promises that wait for the run loop to empty\nbefore resolving. If your application has code that runs outside a runloop,\nthese will resolve too early and give erroneous test failures which are\ndifficult to find. Disabling autoruns help you identify these scenarios and\nhelps both your testing and your application!\n\nWhere can I find more information?\nCheck out the Ember.run API\ndocumentation, as well as the Backburner library\nthat powers the run loop.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"de74394cb5de1e6f7bbcd8e9446fab89","fields":[{"name":"title","value":"Services","type":"string"},{"name":"url","value":"/applications/services/","type":"enum"},{"name":"body","value":"An Ember.Service is a long-lived Ember object that can be made available in\ndifferent parts of your application.\n\nExample uses of services include:\n\n\nLogging\nUser/session authentication\nGeolocation\nThird-party APIs\nWeb Sockets\nServer-sent events or notifications\nServer-backed API calls that may not fit Ember Data\n\nDefining Services\nServices can be generated using Ember CLI's service generator. For example,\nthe following command will create the ShoppingCart service:\n\n  1\n\n  ember generate service shopping-cart\n\n\n\nServices must extend the Ember.Service base class:\n\n  \n    \n      app/services/shopping-cart.js\n    \n  \n\n  1\n2\n\n  export default Ember.Service.extend({\n});\n\n\n\nLike any Ember object, a service is initialized and can have properties and\nmethods of its own.\n\n  \n    \n      app/services/shopping-cart.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  export default Ember.Service.extend({\n  items: null,\n\n  init() {\n    this._super(...arguments);\n    this.set('items', []);\n  },\n\n  add(item) {\n    this.get('items').pushObject(item);\n  },\n\n  remove(item) {\n    this.get('items').removeObject(item);\n  },\n\n  empty() {\n    this.get('items').setObjects([]);\n  }\n});\n\n\nAccessing Services\nTo access a service, inject it either in an initializer or with Ember.inject:\n\n  \n    \n      app/components/cart-contents.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  cart: Ember.inject.service('shopping-cart')\n});\n\n\n\nThis injects the shopping cart service into the component and makes it available\nas the cart property.\n\nYou can then access properties and methods on the service:\n\n  \n    \n      app/components/cart-contents.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Component.extend({\n  cart: Ember.inject.service('shopping-cart'),\n\n  actions: {\n    remove(item) {\n      this.get('cart').remove(item);\n    }\n  }\n});\n\n\n\n  \n    \n      app/templates/components/cart-contents.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  \u003cul\u003e\n  {{#each cart.items as |item|}}\n    \u003cli\u003e\n      {{item.name}}\n      \u003cbutton {{action \"remove\" item}}\u003eRemove\u003c/button\u003e\n    \u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nThe injected property is lazy; the service will not be instantiated until the\nproperty is explicitly called. It will then persist until the application exits.\n\nIf no argument is provided to service(), Ember will use the dasherized version\nof the property name:\n\n  \n    \n      app/components/cart-contents.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  shoppingCart: Ember.inject.service()\n});\n\n\n\nThis also injects the shopping cart service, as the shoppingCart property.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"47913aec12ee9dbd0749f8ee0c891428","fields":[{"name":"title","value":"Customizing a Component's Element","type":"string"},{"name":"url","value":"/components/customizing-a-components-element/","type":"enum"},{"name":"body","value":"By default, each component is backed by a \u003cdiv\u003e element. If you were\nto look at a rendered component in your developer tools, you would see\na DOM representation that looked something like:\n\n  1\n2\n3\n\n  \u003cdiv id=\"ember180\" class=\"ember-view\"\u003e\n  \u003ch1\u003eMy Component\u003c/h1\u003e\n\u003c/div\u003e\n\n\n\nYou can customize what type of element Ember generates for your\ncomponent, including its attributes and class names, by creating a\nsubclass of Ember.Component in your JavaScript.\nCustomizing the Element\nTo use a tag other than div, subclass Ember.Component and assign it\na tagName property. This property can be any valid HTML5 tag name as a\nstring.\n\n  \n    \n      app/components/navigation-bar.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  tagName: 'nav'\n});\n\n\n\n  \n    \n      app/templates/components/navigation-bar.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003cul\u003e\n  \u003cli\u003e{{#link-to \"home\"}}Home{{/link-to}}\u003c/li\u003e\n  \u003cli\u003e{{#link-to \"about\"}}About{{/link-to}}\u003c/li\u003e\n\u003c/ul\u003e\n\n\nCustomizing Class Names\nYou can also specify which class names are applied to the component's\nelement by setting its classNames property to an array of strings:\n\n  \n    \n      app/components/navigation-bar.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  classNames: ['primary']\n});\n\n\n\nIf you want class names to be determined by properties of the component,\nyou can use class name bindings. If you bind to a Boolean property, the\nclass name will be added or removed depending on the value:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isUrgent'],\n  isUrgent: true\n});\n\n\n\nThis component would render the following:\n\n  1\n\n  \u003cdiv class=\"ember-view is-urgent\"\u003e\u003c/div\u003e\n\n\n\nIf isUrgent is changed to false, then the is-urgent class name will be removed.\n\nBy default, the name of the Boolean property is dasherized. You can customize the class name\napplied by delimiting it with a colon:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isUrgent:urgent'],\n  isUrgent: true\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view urgent\"\u003e\n\n\n\nBesides the custom class name for the value being true, you can also specify a class name which is used when the value is false:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isEnabled:enabled:disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nYou can also specify a class which should only be added when the property is\nfalse by declaring classNameBindings like this:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isEnabled::disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nIf the isEnabled property is set to true, no class name is added:\n\n  1\n\n  \u003cdiv class=\"ember-view\"\u003e\n\n\n\nIf the bound property's value is a string, that value will be added as a class name without\nmodification:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['priority'],\n  priority: 'highestPriority'\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view highestPriority\"\u003e\n\n\nCustomizing Attributes\nYou can bind attributes to the DOM element that represents a component\nby using attributeBindings:\n\n  \n    \n      app/components/link-item.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  tagName: 'a',\n  attributeBindings: ['href'],\n  href: \"http://emberjs.com\"\n});\n\n\n\nYou can also bind these attributes to differently named properties:\n\n  \n    \n      app/components/link-item.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  tagName: 'a',\n  attributeBindings: ['customHref:href'],\n  customHref: 'http://emberjs.com'\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6faa3aaa66dd8ba5f798d307f0136e3c","fields":[{"name":"title","value":"Defining a Component","type":"string"},{"name":"url","value":"/components/defining-a-component/","type":"enum"},{"name":"body","value":"To define a component, run:\n\n  1\n\n  ember generate component my-component-name\n\n\n\nComponents must have at least one dash in their name. So blog-post is an acceptable\nname, and so is audio-player-controls, but post is not. This prevents clashes with\ncurrent or future HTML element names, aligns Ember components with the W3C Custom\nElements\nspec, and ensures Ember detects the components automatically.\n\nA sample component template could look like this:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003carticle class=\"blog-post\"\u003e\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n  \u003cp\u003e{{yield}}\u003c/p\u003e\n  \u003cp\u003eEdit title: {{input type=\"text\" value=title}}\u003c/p\u003e\n\u003c/article\u003e\n\n\n\nGiven the above template, you can now use the {{blog-post}} component:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  {{#each model as |post|}}\n  {{#blog-post title=post.title}}\n    {{post.body}}\n  {{/blog-post}}\n{{/each}}\n\n```app/routes/index.js\nexport default Ember.Route.extend({\n  model() {\n    return this.store.findAll('post');\n  }\n});\n\n\n\nEach component, under the hood, is backed by an element. By default\nEmber will use a \u003cdiv\u003e element to contain your component's template.\nTo learn how to change the element Ember uses for your component, see\nCustomizing a Component's\nElement.\nDefining a Component Subclass\nOften times, your components will just encapsulate certain snippets of\nHandlebars templates that you find yourself using over and over. In\nthose cases, you do not need to write any JavaScript at all. Just define\nthe Handlebars template as described above and use the component that is\ncreated.\n\nIf you need to customize the behavior of the component you'll\nneed to define a subclass of Ember.Component. For example, you would\nneed a custom subclass if you wanted to change a component's element,\nrespond to actions from the component's template, or manually make\nchanges to the component's element using JavaScript.\n\nEmber knows which subclass powers a component based on its filename. For\nexample, if you have a component called blog-post, you would create a\nfile at app/components/blog-post.js. If your component was called\naudio-player-controls, the file name would be at\napp/components/audio-player-controls.js.\nDynamically rendering a component\nThe {{component}} helper can be used to defer the selection of a component to\nrun time. The {{my-component}} syntax always renders the same component,\nwhile using the {{component}} helper allows choosing a component to render on\nthe fly. This is useful in cases where you want to interact with different\nexternal libraries depending on the data. Using the {{component}} helper would\nallow you to keep different logic well-separated.\n\nThe first parameter of the helper is the name of a component to render, as a\nstring. So {{component 'blog-post'}} is just the same as using {{blog-post}}.\n\nThe real value of {{component}} comes from being able to dynamically pick\nthe component being rendered. Below is an example of using the helper as a\nmeans of choosing different components for displaying different kinds of posts:\n\n  \n    \n      app/templates/components/foo-component.hbs\n    \n  \n\n  1\n2\n\n  \u003ch3\u003eHello from foo!\u003c/h3\u003e\n\u003cp\u003e{{post.body}}\u003c/p\u003e\n\n\n\n  \n    \n      app/templates/components/bar-component.hbs\n    \n  \n\n  1\n2\n\n  \u003ch3\u003eHello from bar!\u003c/h3\u003e\n\u003cdiv\u003e{{post.author}}\u003c/div\u003e\n\n\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.findAll('post');\n  }\n});\n\n\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  {{#each model as |post|}}\n  {{!-- either foo-component or bar-component --}}\n  {{component post.componentName post=post}}\n{{/each}}\n\n\n\nWhen the parameter passed to {{component}} evaluates to null or undefined,\nthe helper renders nothing. When the parameter changes, the currently rendered\ncomponent is destroyed and the new component is created and brought in.\n\nPicking different components to render in response to the data allows you to\nhave different template and behavior for each case. The {{component}} helper\nis a powerful tool for improving code modularity.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ea688f6a5cc0ff994d040e8d75335c8e","fields":[{"name":"title","value":"Handling Events","type":"string"},{"name":"url","value":"/components/handling-events/","type":"enum"},{"name":"body","value":"You can respond to user events on your component like double-clicking, hovering,\nand key presses through event handlers. Simply implement the name of the event\nyou want to respond to as a method on your component.\n\nFor example, imagine we have a template like this:\n\n  1\n2\n3\n\n  {{#double-clickable}}\n  This is a double clickable area!\n{{/double-clickable}}\n\n\n\nLet's implement double-clickable such that when it is\nclicked, an alert is displayed:\n\n  \n    \n      app/components/double-clickable.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  doubleClick: function() {\n    alert(\"DoubleClickableComponent was clicked!\");\n  }\n});\n\n\n\nBrowser events may bubble up the DOM which potentially target parent component(s)\nin succession. To enable bubbling return true; from the event handler method\nin your component.\n\n  \n    \n      app/components/double-clickable.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Component.extend({\n  doubleClick: function() {\n    Ember.Logger.info(\"DoubleClickableComponent was clicked!\");\n    return true;\n  }\n});\n\n\n\nSee the list of event names at the end of this page. Any event can be defined\nas an event handler in your component.\nSending Actions\nIn some cases your component needs to define event handlers, perhaps to support\nvarious draggable behaviors. For example, a component may need to send an id\nwhen it receives a drop event:\n\n  1\n\n  {{drop-target action=\"didDrop\"}}\n\n\n\nYou can define the component's event handlers to manage the drop event.\nAnd if you need to, you may also stop events from bubbling, by using\nreturn false;.\n\n  \n    \n      app/components/drop-target.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.Component.extend({\n  attributeBindings: ['draggable'],\n  draggable: 'true',\n\n  dragOver: function() {\n    return false;\n  },\n\n  drop: function(event) {\n    let id = event.dataTransfer.getData('text/data');\n    this.sendAction('action', id);\n  }\n});\n\n\nEvent Names\nThe event handling examples described above respond to one set of events.\nThe names of the built-in events are listed below. Custom events can be\nregistered by using Ember.Application.customEvents.\n\nTouch events:\n\n\ntouchStart\ntouchMove\ntouchEnd\ntouchCancel\n\n\nKeyboard events\n\n\nkeyDown\nkeyUp\nkeyPress\n\n\nMouse events\n\n\nmouseDown\nmouseUp\ncontextMenu\nclick\ndoubleClick\nmouseMove\nfocusIn\nfocusOut\nmouseEnter\nmouseLeave\n\n\nForm events:\n\n\nsubmit\nchange\nfocusIn\nfocusOut\ninput\n\n\nHTML5 drag and drop events:\n\n\ndragStart\ndrag\ndragEnter\ndragLeave\ndragOver\ndragEnd\ndrop\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8d2797c18261ac73c76de693da7cae13","fields":[{"name":"title","value":"Passing Properties to a Component","type":"string"},{"name":"url","value":"/components/passing-properties-to-a-component/","type":"enum"},{"name":"body","value":"Components are isolated from their surroundings, so any data that the component\nneeds has to be passed in.\n\nFor example, imagine you have a blog-post component that is used to\ndisplay a blog post:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003carticle class=\"blog-post\"\u003e\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n  \u003cp\u003e{{body}}\u003c/p\u003e\n\u003c/article\u003e\n\n\n\nNow imagine we have the following template and route:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.findAll('post');\n  }\n});\n\n\n\nIf we tried to use the component like this:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#each model as |post|}}\n  {{blog-post}}\n{{/each}}\n\n\n\nThe following HTML would be rendered:\n\n  1\n2\n3\n4\n\n  \u003carticle class=\"blog-post\"\u003e\n  \u003ch1\u003e\u003c/h1\u003e\n  \u003cp\u003e\u003c/p\u003e\n\u003c/article\u003e\n\n\n\nIn order to make a property available to a component, you must pass it\nin like this:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#each model as |post|}}\n  {{blog-post title=post.title body=post.body}}\n{{/each}}\n\n\n\nIt is important to note that these properties stay in sync (technically\nknown as being \"bound\"). That is, if the value of componentProperty\nchanges in the component, outerProperty will be updated to reflect that\nchange. The reverse is true as well.\nPositional Params\nIn addition to passing parameters in by name, you can pass them in by position.\nIn other words, you can invoke the above component example like this:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#each model as |post|}}\n  {{blog-post post.title post.body}}\n{{/each}}\n\n\n\nTo set the component up to receive parameters this way, you need\nset the positionalParams attribute in your component class.\n\n  \n    \n      app/components/blog-post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  const BlogPostComponent = Ember.Component.extend({});\n\nBlogPostComponent.reopenClass({\n  positionalParams: ['title', 'body']\n});\n\nexport default BlogPostComponent;\n\n\n\nThen you can use the attributes in the component exactly as if they had been\npassed in like {{blog-post title=post.title body=post.body}}.\n\nNotice that the positionalParams property is added to the class as a\nstatic variable via reopenClass. Positional params are always declared on\nthe component class and cannot be changed while an application runs.\n\nAlternatively, you can accept have an arbitrary number of parameters by\nsetting positionalParams to a string, e.g. positionalParams: 'params'. This\nwill allow you to access those params as an array like so:\n\n  \n    \n      app/components/blog-post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  const BlogPostComponent = Ember.Component.extend({\n  title: Ember.computed('params.[]', function(){\n    return this.get('params')[0];\n  }),\n  body: Ember.computed('params.[]', function(){\n    return this.get('params')[1];\n  })\n});\n\nBlogPostComponent.reopenClass({\n  positionalParams: 'params'\n});\n\nexport default BlogPostComponent;\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"da48347254745eff0030f6c69abac8a0","fields":[{"name":"title","value":"Triggering Changes with Actions","type":"string"},{"name":"url","value":"/components/triggering-changes-with-actions/","type":"enum"},{"name":"body","value":"You can think of a component as a black box of UI functionality.\nSo far, you've learned how parent components can pass attributes in to a\nchild component, and how that component can use those attributes from\nboth JavaScript and its template.\n\nBut what about the opposite direction? How does data flow back out of\nthe component to the parent? In Ember, components use actions to\ncommunicate events and changes.\n\nLet's look at a simple example of how a component can use an action to\ncommunicate with its parent.\n\nImagine we're building an application where users can have accounts. We\nneed to build the UI for users to delete their account. Because we don't\nwant users to accidentally delete their accounts, we'll build a button\nthat requires the user to confirm in order to trigger some\naction.\n\nOnce we create this \"button with confirmation\"\ncomponent, we want to be able to reuse it all over our application.\nCreating the Component\nLet's call our component button-with-confirmation. We can create it by\ntyping:\n\n  1\n\n  ember generate component button-with-confirmation\n\n\n\nWe'll plan to use the component in a template something like this:\n\n  \n    \n      app/templates/components/user-profile.hbs\n    \n  \n\n  1\n\n  {{button-with-confirmation text=\"Click OK to delete your account.\"}}\n\n\n\nWe'll also want to use the component elsewhere, perhaps like this:\n\n  \n    \n      app/templates/components/send-message.hbs\n    \n  \n\n  1\n\n  {{button-with-confirmation text=\"Click OK to send your message.\"}}\n\n\nDesigning the Action\nWhen implementing an action on a component, you need to break it down into two steps:\n\n\nIn the parent component, decide how you want to react to the action.\nHere, we want to have the action delete the user's account in one place, and\nsend a message in another place.\nIn the component, determine when something has happened, and when to tell the\noutside world. Here, we want to trigger the outside action (deleting the\naccount or sending the message) after the user clicks the button and then\nconfirms.\n\n\nLet's take it step by step.\nImplementing the Action\nIn the parent component, let's first define what we want to happen when the\nuser clicks the button and then confirms. In this case, we'll find the user's\naccount and delete it.\n\nFirst, we'll define what we want to happen when the user double clicks\nthe button. In this case, we'll find the user's account and delete it.\n\nIn Ember, each component can\nhave a property called actions, where you put functions that can be\ninvoked by the user interacting with the component\nitself, or by child components.\n\nLet's look at the parent component's JavaScript file. In this example,\nimagine we have a parent component called user-profile that shows the\nuser's profile to them.\n\nWe'll implement an action on the parent component called\nuserDidDeleteAccount() that, when called, gets a hypothetical login\nservice and calls the service's\ndeleteUser() method.\n\n  \n    \n      app/components/user-profile.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Component.extend({\n  login: Ember.inject.service(),\n\n  actions: {\n    userDidDeleteAccount() {\n      this.get('login').deleteUser();\n    }\n  }\n});\n\n\n\nNow we've implemented our action, but we have not told Ember when we\nwant this action to be triggered, which is the next step.\nDesigning the Child Component\nNext, let's implement the logic to confirm that the user wants to take\nthe action from the component:\n\n  \n    \n      app/components/button-with-confirmation.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Component.extend({\n  tagName: 'button',\n  click() {\n    if (confirm(this.get('text'))) {\n      // trigger action on parent component\n    }\n  }\n});\n\n\nPassing the Action to the Component\nNow we just need to make it so that the onConfirm() event in the\nbutton-with-confirmation() component triggers the\nuserDidDeleteAccount() action in the user-profile component.\nOne important thing to know about actions is that they're just\nfunctions you can call, like any other method on your component.\nSo they can be passed from one component to another like this:\n\n  \n    \n      app/components/user-profile.hbs\n    \n  \n\n  1\n\n  {{button-with-confirmation text=\"Click here to delete your account.\" onConfirm=(action 'userDidDeleteAccount')}}\n\n\n\nThis snippet says \"take the userDidDeleteAccount action from the\nparent and make it available on the child component as\nonConfirm.\"\n\nWe can do a similar thing for our send-message component:\n\n  \n    \n      app/templates/components/send-message.hbs\n    \n  \n\n  1\n\n  {{button-with-confirmation text=\"Click to send your message.\" onConfirm=(action 'sendMessage')}}\n\n\n\nNow, we can use onConfirm in the child component to invoke the action on the\nparent:\n\n  \n    \n      app/components/button-with-confirmation.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Component.extend({\n  tagName: 'button',\n  click() {\n    if (confirm(this.get('text'))) {\n      this.get('onConfirm')();\n    }\n  }\n});\n\n\n\nthis.get('onConfirm') will return the function passed from the parent as the\nvalue of onConfirm, and the following () will invoke the function.\n\nLike normal attributes, actions can be a property on the component; the\nonly difference is that the property is set to a function that knows how\nto trigger behavior.\n\nThat makes it easy to remember how to add an action to a component. It's\njust like passing an attribute, but you use the action helper to pass\na function instead.\n\nActions in components allow you to\ndecouple an event happening from how it's handled, leading to modular,\nmore reusable components.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e9763ebaa18b58c8fafed5531d19eb14","fields":[{"name":"title","value":"Wrapping Content in a Component","type":"string"},{"name":"url","value":"/components/wrapping-content-in-a-component/","type":"enum"},{"name":"body","value":"Sometimes, you may want to define a component that wraps content\nprovided by other templates.\n\nFor example, imagine we are building a blog-post component that we can\nuse in our application to display a blog post:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003cdiv class=\"body\"\u003e{{body}}\u003c/div\u003e\n\n\n\nNow, we can use the {{blog-post}} component and pass it properties\nin another template:\n\n  1\n\n  {{blog-post title=title body=body}}\n\n\n\n(See Passing Properties to a\nComponent for\nmore.)\n\nIn this case, the content we wanted to display came from the model. But\nwhat if we want the developer using our component to be able to provide custom\nHTML content?\n\nIn addition to the simple form you've learned so far, components also\nsupport being used in block form. In block form, components can be\npassed a Handlebars template that is rendered inside the component's\ntemplate wherever the {{yield}} expression appears.\n\nTo use the block form, add a # character to the\nbeginning of the component name, then make sure to add a closing tag.\n(See the Handlebars documentation on block expressions for more.)\n\nIn that case, we can use the {{blog-post}} component in block form\nand tell Ember where the block content should be rendered using the\n{{yield}} helper. To update the example above, we'll first change the component's\ntemplate:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003cdiv class=\"body\"\u003e{{yield}}\u003c/div\u003e\n\n\n\nYou can see that we've replaced {{body}} with {{yield}}. This tells\nEmber that this content will be provided when the component is used.\n\nNext, we'll update the template using the component to use the block\nform:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  {{#blog-post title=title}}\n  \u003cp class=\"author\"\u003eby {{author}}\u003c/p\u003e\n  {{body}}\n{{/blog-post}}\n\n\n\nIt's important to note that the template scope inside the component\nblock is the same as outside. If a property is available in the template\noutside the component, it is also available inside the component block.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"db767f9b7794259fc51adf628e889728","fields":[{"name":"title","value":"Configuring Ember CLI","type":"string"},{"name":"url","value":"/configuring-ember/configuring-ember-cli/","type":"enum"},{"name":"body","value":"In addition to configuring your app itself, you can also configure Ember CLI.\nThese configurations can be made by adding them to the .ember-cli file in your application's root. Many can also be made by passing them as arguments to the command line program.\n\nFor example, a common desire is to change the port that Ember CLI serves the app from. It's possible to pass the port number from the command line with ember server --port 8080. To make this configuration permanent, edit your .ember-cli file like so:\n\n  1\n2\n3\n\n  {\n  \"port\": 8080\n}\n\n\n\nFor a full list of command line options, run ember help.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"5cb0b70fe7060908328e2e6a94be38dd","fields":[{"name":"title","value":"Configuring Your App","type":"string"},{"name":"url","value":"/configuring-ember/configuring-your-app/","type":"enum"},{"name":"body","value":"Ember CLI ships with support for managing your application's environment. Ember CLI will setup a default environment config file at config/environment. Here, you can define an ENV object for each environment, which are currently limited to three: development, test, and production.\n\nThe ENV object contains three important keys:\n\n\nEmberENV can be used to define Ember feature flags (see the Feature Flags guide).\nAPP can be used to pass flags/options to your application instance.\nenvironment contains the name of the current enviroment (development,production or test).\n\n\nYou can access these environment variables in your application code by importing from your-application-name/config/environment.\n\nFor example:\n\n  1\n2\n3\n4\n5\n\n  import ENV from 'your-application-name/config/environment';\n\nif (ENV.environment === 'development') {\n  // ...\n}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0ab82a1cf8a75d333dc8fe48ccdda4be","fields":[{"name":"title","value":"Debugging","type":"string"},{"name":"url","value":"/configuring-ember/debugging/","type":"enum"},{"name":"body","value":"Ember provides several configuration options that can help you debug problems\nwith your application.\nRoutingLog router transitions\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Application.extend({\n  // Basic logging, e.g. \"Transitioned into 'post'\"\n  LOG_TRANSITIONS: true,\n\n  // Extremely detailed logging, highlighting every internal\n  // step made while transitioning into a route, including\n  // `beforeModel`, `model`, and `afterModel` hooks, and\n  // information about redirects and aborted transitions\n  LOG_TRANSITIONS_INTERNAL: true\n});\n\n\nViews / TemplatesLog view lookups\n  \n    \n      config/environment.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_VIEW_LOOKUPS = true;\n\n\n\n  1\n\n  Ember.keys(Ember.TEMPLATES)\n\n\nControllersLog generated controller\n  \n    \n      config/environment.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_ACTIVE_GENERATION = true;\n\n\nObservers / BindingSee all observers for a object, key\n  1\n\n  Ember.observersFor(comments, keyName);\n\n\nLog object bindings\n  \n    \n      config/environments.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_BINDINGS = true\n\n\nMiscellaneousTurn on resolver resolution logging\nThis option logs all the lookups that are done to the console. Custom objects\nyou've created yourself have a tick, and Ember generated ones don't.\n\nIt's useful for understanding which objects Ember is finding when it does a lookup\nand which it is generating automatically for you.\n\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Application.extend({\n  LOG_RESOLVER: true\n});\n\n\nDealing with deprecations\n  1\n2\n\n  Ember.ENV.RAISE_ON_DEPRECATION = true\nEmber.ENV.LOG_STACKTRACE_ON_DEPRECATION = true\n\n\nImplement an Ember.onerror hook to log all errors in production\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Ember.onerror = function(error) {\n  Ember.$.ajax('/error-notification', {\n    type: 'POST',\n    data: {\n      stack: error.stack,\n      otherInformation: 'exception message'\n    }\n  });\n}\n\n\nImport the console\nIf you are using imports with Ember, be sure to import the console:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  Ember = {\n  imports: {\n    Handlebars: Handlebars,\n    jQuery: $,\n    console: window.console\n  }\n};\n\n\nErrors within an RSVP.Promise\nThere are times when dealing with promises that it seems like any errors\nare being 'swallowed', and not properly raised. This makes it extremely\ndifficult to track down where a given issue is coming from. Thankfully,\nRSVP has a solution for this problem built in.\n\nYou can provide an onerror function that will be called with the error\ndetails if any errors occur within your promise. This function can be anything\nbut a common practice is to call console.assert to dump the error to the\nconsole.\n\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n\n  Ember.RSVP.on('error', function(error) {\n  Ember.Logger.assert(false, error);\n});\n\n\nErrors within Ember.run.later (Backburner.js)\nBackburner has support for stitching the stacktraces together so that you can\ntrack down where an erroring Ember.run.later is being initiated from. Unfortunately,\nthis is quite slow and is not appropriate for production or even normal development.\n\nTo enable this mode you can set:\n\n  1\n\n  Ember.run.backburner.DEBUG = true;\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"62986c9e6cbee2077f1bd848372a19dc","fields":[{"name":"title","value":"Disabling Prototype Extensions","type":"string"},{"name":"url","value":"/configuring-ember/disabling-prototype-extensions/","type":"enum"},{"name":"body","value":"By default, Ember.js will extend the prototypes of native JavaScript\nobjects in the following ways:\n\n\nArray is extended to implement the Ember.Enumerable,\nEmber.MutableEnumerable, Ember.MutableArray and Ember.Array\ninterfaces. This polyfills ECMAScript 5 array methods in browsers that\ndo not implement them, adds convenience methods and properties to\nbuilt-in arrays, and makes array mutations observable.\nString is extended to add convenience methods, such as\ncamelize() and w(). You can find a list of these methods with the\nEmber.String documentation.\nFunction is extended with methods to annotate functions as\ncomputed properties, via the property() method, and as observers,\nvia the observes() or observesBefore() methods. Use of these methods\nis now discouraged and not covered in recent versions of the Guides.\n\n\nThis is the extent to which Ember.js enhances native prototypes. We have\ncarefully weighed the tradeoffs involved with changing these prototypes,\nand recommend that most Ember.js developers use them. These extensions\nsignificantly reduce the amount of boilerplate code that must be typed.\n\nHowever, we understand that there are cases where your Ember.js\napplication may be embedded in an environment beyond your control. The\nmost common scenarios are when authoring third-party JavaScript that is\nembedded directly in other pages, or when transitioning an application\npiecemeal to a more modern Ember.js architecture.\n\nIn those cases, where you can't or don't want to modify native\nprototypes, Ember.js allows you to completely disable the extensions\ndescribed above.\n\nTo do so, simply set the EmberENV.EXTEND_PROTOTYPES flag to false:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  ENV = {\n  EmberENV: {\n    EXTEND_PROTOTYPES: false\n  }\n}\n\n\n\nYou can configure which classes to include prototype extensions\nfor in your application's configuration like so:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  ENV = {\n  EmberENV: {\n    EXTEND_PROTOTYPES: {\n      String: false,\n      Array: true\n    }\n  }\n}\n\n\nLife Without Prototype Extension\nIn order for your application to behave correctly, you will need to\nmanually extend or create the objects that the native objects were\ncreating before.\nArrays\nNative arrays will no longer implement the functionality needed to\nobserve them. If you disable prototype extension and attempt to use\nnative arrays with things like a template's {{#each}} helper, Ember.js\nwill have no way to detect changes to the array and the template will\nnot update as the underlying array changes.\n\nAdditionally, if you try to set the model of an\nEmber.ArrayController to a plain native array, it will raise an\nexception since it no longer implements the Ember.Array interface.\n\nYou can manually coerce a native array into an array that implements the\nrequired interfaces using the convenience method Ember.A:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var islands = ['Oahu', 'Kauai'];\nislands.contains('Oahu');\n//=\u003e TypeError: Object Oahu,Kauai has no method 'contains'\n\n// Convert `islands` to an array that implements the\n// Ember enumerable and array interfaces\nEmber.A(islands);\n\nislands.contains('Oahu');\n//=\u003e true\n\n\nStrings\nStrings will no longer have the convenience methods described in the\nEmber.String API reference.. Instead,\nyou can use the similarly-named methods of the Ember.String object and\npass the string to use as the first parameter:\n\n  1\n2\n3\n4\n5\n\n  \"my_cool_class\".camelize();\n//=\u003e TypeError: Object my_cool_class has no method 'camelize'\n\nEmber.String.camelize(\"my_cool_class\");\n//=\u003e \"myCoolClass\"\n\n\nFunctions\nThe Object Model section of the Guides describes\nhow to write computed properties, observers, and bindings without\nprototype extensions. Below you can learn about how to convert existing\ncode to the format now encouraged.\n\nTo annotate computed properties, use the Ember.computed() method to\nwrap the function:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  // This won't work:\nfullName: function() {\n  return `${this.get('firstName')} ${this.get('lastName')}`;\n}.property('firstName', 'lastName')\n\n\n// Instead, do this:\nfullName: Ember.computed('firstName', 'lastName', function() {\n  return `${this.get('firstName')} ${this.get('lastName')}`;\n})\n\n\n\nObservers are annotated using Ember.observer():\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  // This won't work:\nfullNameDidChange: function() {\n  console.log('Full name changed');\n}.observes('fullName')\n\n\n// Instead, do this:\nfullNameDidChange: Ember.observer('fullName', function() {\n  console.log('Full name changed');\n})\n\n\n\nEvented functions are annotated using Ember.on():\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  // This won't work:\ndoStuffWhenInserted: function() {\n  /* awesome sauce */\n}.on('didInsertElement');\n\n// Instead, do this:\ndoStuffWhenInserted: Ember.on('didInsertElement', function() {\n  /* awesome sauce */\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"479923146262192b72f2b6cd4e92d83b","fields":[{"name":"title","value":"Embedding Applications","type":"string"},{"name":"url","value":"/configuring-ember/embedding-applications/","type":"enum"},{"name":"body","value":"In most cases, your application's entire UI will be created by templates\nthat are managed by the router.\n\nBut what if you have an Ember.js app that you need to embed into an\nexisting page, or run alongside other JavaScript frameworks, or serve from the\nsame domain as another app?\nChanging the Root Element\nBy default, your application will render the application template\nand attach it to the document's body element.\n\nYou can tell the application to append the application template to a\ndifferent element by specifying its rootElement property:\n\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Application.extend({\n  rootElement: '#app'\n});\n\n\n\nThis property can be specified as either an element or a\njQuery-compatible selector\nstring.\nDisabling URL Management\nYou can prevent Ember from making changes to the URL by changing the\nrouter's location to\nnone:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n\n  var ENV = {\n  locationType: 'none'\n};\n\n\nSpecifying a Root URL\nIf your Ember application is one of multiple web applications served from the same domain, it may be necessary to indicate to the router what the root URL for your Ember application is. By default, Ember will assume it is served from the root of your domain.\n\nFor example, if you wanted to serve your blogging application from http://emberjs.com/blog/, it would be necessary to specify a root URL of /blog/.\n\nThis can be achieved by setting the rootURL on the router:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Ember.Router.extend({\n  rootURL: '/blog/'\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"32ec1a30c836c88e234758571f01a21e","fields":[{"name":"title","value":"Feature Flags","type":"string"},{"name":"url","value":"/configuring-ember/feature-flags/","type":"enum"},{"name":"body","value":"New features are added to Ember.js within conditional statements.\n\nCode behind these flags can be conditionally enabled\n(or completely removed) based on your project's configuration. This\nallows newly developed features to be selectively released when the\nEmber.js community considers them ready for production use.\nFeature Life-Cycle\nA newly-flagged feature is only available in canary builds and can be enabled\nat runtime through your project's configuration file.\n\nAt the start of a beta cycle the Ember core team evaluates each new feature.\nFeatures deemed stable are made available in the next beta and enabled by default.\n\nBeta features that receive negative feedback from the community are disabled in the next beta point\nrelease, and are not included in the next stable release. They may still be included\nin the next beta cycle if the issues/concerns are resolved.\n\nOnce the beta cycle has completed the next stable release will include any features that\nwere enabled during the beta cycle. At this point the feature flags will be removed from\nthe canary and future beta branches and the feature becomes of the framework.\nFlagging Details\nThe flag status in the generated build is controlled by the features.json\nfile in the root of the Ember.js project. This file lists all new features and their current status.\n\nA feature can have one of a three flags:\n\n\ntrue - The feature is present and enabled: the code behind the flag is always enabled in\nthe generated build.\nnull - The feature is present but disabled in the build output. It must be enabled at\nruntime.\nfalse - The feature is entirely disabled: the code behind the flag is not present in\nthe generated build.\n\n\nThe process of removing the feature flags from the resulting build output is\nhandled by defeatureify.\nFeature Listing (FEATURES.md)\nWhen a developer adds a new feature canary channel (i.e. the master branch on github), they\nalso add an entry to FEATURES.md\nexplaining what the feature does and linking to their originating pull request.\nThis list is kept current, and reflects what is available in each channel\n(stable, beta, and master).\nEnabling At Runtime\nWhen using the Ember.js canary or beta builds you can enable any \"present but disabled\"\nby setting its flag value to true before your application boots:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  var ENV = {\n  EmberENV: {\n    FEATURES: {\n      'link-to': true\n    }\n  }\n};\n\n\n\nFor the truly ambitious developer, setting ENV.EmberENV.ENABLE_ALL_FEATURES to true will enable all\nexperimental features.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ca2af5aa71dc7d2dc0629dcb1d5641cd","fields":[{"name":"title","value":"Specifying the URL Type","type":"string"},{"name":"url","value":"/configuring-ember/specifying-url-type/","type":"enum"},{"name":"body","value":"The Ember router has four options to manage your application's URL:  history,\nwhich uses the HTML5 History API; hash, which uses anchor-based URLs; auto,\nwhich uses history if supported by the user's browser, and falls back to\nhash otherwise; and none, which doesn't update the URL. By default, Ember\nCLI configures the router to use auto. You can change this option in\nconfig/environment.js under ENV.locationType.\nhistory\nWhen using history, Ember uses the browser's\nhistory API to produce URLs with a structure like\n/posts/new.\n\nGiven the following router, entering /posts/new will take you to the posts.new\nroute.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', function() {\n    this.route('new');\n  });\n});\n\n\n\nKeep in mind that your server must serve the Ember app from all the URLs defined in your\nRouter.map function. In other words, if your user directly navigates to\n/posts/new, your server must be configured to serve your Ember app in\nresponse.\nhash\nThe hash option uses the URL's anchor to load the starting state of your\napplication and will keep it in sync as you move around. At present, this relies\non a hashchange event existing in the browser.\n\nIn the router example above, entering /#/posts/new will take you to the posts.new\nroute.\nnone\nFinally, if you don't want the browser's URL to interact with your application\nat all, you can disable the location API entirely by setting ENV.locationType\nto none. This is useful for\ntesting, or when you don't want Ember to muck with the URL (for example when you embed your\napplication in a larger page).\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3cddcc7a01c23b72f74ea3eceaaada93","fields":[{"name":"title","value":"Adding New Features","type":"string"},{"name":"url","value":"/contributing/adding-new-features/","type":"enum"},{"name":"body","value":"In general, new feature development should be done on master.\n\nBugfixes should not introduce new APIs or break existing APIs, and do\nnot need feature flags.\n\nFeatures can introduce new APIs, and need feature flags. They should not\nbe applied to the release or beta branches, since SemVer requires\nbumping the minor version to introduce new features.\n\nSecurity fixes should not introduce new APIs, but may, if strictly\nnecessary, break existing APIs. Such breakages should be as limited as\npossible.\nBug FixesUrgent Bug Fixes\nUrgent bugfixes are bugfixes that need to be applied to the existing\nrelease branch. If possible, they should be made on master and prefixed\nwith [BUGFIX release].\nBeta Bug Fixes\nBeta bugfixes are bugfixes that need to be applied to the beta branch.\nIf possible, they should be made on master and tagged with [BUGFIX\nbeta].\nSecurity Fixes\nSecurity fixes need to be applied to the beta branch, the current\nrelease branch, and the previous tag. If possible, they should be made\non master and tagged with [SECURITY].\nFeatures\nFeatures must always be wrapped in a feature flag. Tests for the feature\nmust also be wrapped in a feature flag.\n\nBecause the build-tools will process feature-flags, flags must use\nprecisely this format. We are choosing conditionals rather than a block\nform because functions change the surrounding scope and may introduce\nproblems with early return.\n\n  1\n2\n3\n\n  if (Ember.FEATURES.isEnabled(\"feature\")) {\n  // implementation\n}\n\n\n\nTests will always run with all features on, so make sure that any tests\nfor the feature are passing against the current state of the feature.\nCommits\nCommits related to a specific feature should include  a prefix like\n[FEATURE htmlbars]. This will allow us to quickly identify all commits\nfor a specific feature in the future. Features will never be applied to\nbeta or release branches. Once a beta or release branch has been cut, it\ncontains all of the new features it will ever have.\n\nIf a feature has made it into beta or release, and you make a commit to\nmaster that fixes a bug in the feature, treat it like a bugfix as\ndescribed above.\nFeature Naming Conventions\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n\n  Ember.FEATURES['\u003cpackageName\u003e-\u003cfeature\u003e'] // if package specific\nEmber.FEATURES['container-factory-injections']\nEmber.FEATURES['htmlbars']\n\n\nBuilds\nThe Canary build, which is based off master, will include all features,\nguarded by the conditionals in the original source. This means that\nusers of the canary build can enable whatever features they want by\nenabling them before creating their Ember.Application.\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  module.exports = function(environment) {\n  var ENV = {\n    EmberENV: {\n      FEATURES: {\n        htmlbars: true\n      }\n    },\n  }\n}\n\n\nfeatures.json\nThe root of the repository will contain a features.json file, which will\ncontain a list of features that should be enabled for beta or release\nbuilds.\n\nThis file is populated when branching, and may not gain additional\nfeatures after the original branch. It may remove features.\n\n  1\n2\n3\n\n  {\n  \"htmlbars\": true\n}\n\n\n\nThe build process will remove any features not included in the list, and\nremove the conditionals for features in the list.\nTravis Testing\nFor a new PR:\n\n\nTravis will test against master with all feature flags on.\nIf a commit is tagged with [BUGFIX beta], Travis will also\ncherry-pick the commit into beta, and run the tests on that\nbranch. If the commit doesn't apply cleanly or the tests fail, the\ntests will fail.\nIf a commit is tagged with [BUGFIX release], Travis will also cherry-pick\nthe commit into release, and run the test on that branch. If the commit\ndoesn't apply cleanly or the tests fail, the tests will fail.\n\n\nFor a new commit to master:\n\n\nTravis will run the tests as described above.\nIf the build passes, Travis will cherry-pick the commits into the\nappropriate branches.\n\n\nThe idea is that new commits should be submitted as PRs to ensure they\napply cleanly, and once the merge button is pressed, Travis will apply\nthem to the right branches.\nGo/No-Go Process\nEvery six weeks, the core team goes through the following process.\nBeta Branch\nAll remaining features on the beta branch are vetted for readiness. If\nany feature isn't ready, it is removed from features.json.\n\nOnce this is done, the beta branch is tagged and merged into release.\nMaster Branch\nAll features on the master branch are vetted for readiness. In order for\na feature to be considered \"ready\" at this stage, it must be ready as-is\nwith no blockers. Features are a no-go even if they are close and\nadditional work on the beta branch would make it ready.\n\nBecause this process happens every six weeks, there will be another\nopportunity for a feature to make it soon enough.\n\nOnce this is done, the master branch is merged into beta. A\nfeatures.json file is added with the features that are ready.\nBeta Releases\nEvery week, we repeat the Go/No-Go process for the features that remain\non the beta branch. Any feature that has become unready is removed from\nthe features.json.\n\nOnce this is done, a Beta release is tagged and pushed.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"26d81f9d1949f3951aa7d9505e7280dd","fields":[{"name":"title","value":"Repositories","type":"string"},{"name":"url","value":"/contributing/repositories/","type":"enum"},{"name":"body","value":"Ember is made up of several libraries. If you wish to add a feature or fix a bug please file a pull request against the appropriate repository. Be sure to check the libraries listed below before making changes in the Ember.js repository.\nMain Repositories\nEmber.js - The main repository for Ember.\n\n\nhttps://github.com/emberjs/ember.js\n\n\nEmber Data - A data persistence library for Ember.js.\n\n\nhttps://github.com/emberjs/data\n\n\nEmber Website - Source for http://emberjs.com\n\n\nhttps://github.com/emberjs/website\n\n\nEmber Guides - Source for http://guides.emberjs.com which you are currently reading.\n\n\nhttps://github.com/emberjs/guides\n\nLibraries Used By Ember\nThese libraries are part of the Ember.js source, but development of them takes place in a separate repository.\npackages/ember-metal/lib/vendor/backburner.js\n\nbackburner.js - Implements the Ember run loop.\nhttps://github.com/ebryn/backburner.js\n\npackages/ember-routing/lib/vendor/route-recognizer.js\n\nroute-recognizer.js - A lightweight JavaScript library that matches paths against registered routes.\nhttps://github.com/tildeio/route-recognizer\n\npackages/ember-routing/lib/vendor/router.js\n\nrouter.js - A lightweight JavaScript library that builds on route-recognizer and rsvp to provide an API for handling routes.\nhttps://github.com/tildeio/router.js\n\npackages/metamorph\n\nMetamorph.js - Used by Ember for databinding handlebars templates\nhttps://github.com/tomhuda/metamorph.js\n\npackages/rsvp\n\nRSVP.js - Implementation of the of Promises/A+ spec used by Ember.\nhttps://github.com/tildeio/rsvp.js\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c34d88bfea40594c8c5d1478666d47a7","fields":[{"name":"title","value":"Managing Dependencies Between Controllers","type":"string"},{"name":"url","value":"/controllers/dependencies-between-controllers/","type":"enum"},{"name":"body","value":"Sometimes, especially when nesting resources, we find ourselves needing\nto have some kind of connection between two controllers. Let's take this\nrouter as an example:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('post', { path: '/posts/:post_id' }, function() {\n    this.route('comments', { path: '/comments' });\n  });\n});\n\n\n\nIf we visit a /posts/1/comments URL, our Post model will get\nloaded into a PostController's model, which means it is not directly\naccessible in the CommentsController. However, we might want to display\nsome information about it in the comments template.\n\nTo do this, we inject the PostController into the\nCommentsController (which has the desired Post model).\n\n  \n    \n      app/controllers/comments.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Controller.extend({\n  postController: Ember.inject.controller('post')\n});\n\n\n\nOnce comments has access to the PostController, a read-only alias can be\nused to read the model from that controller. In order to get the\nPost model, we refer to postController.model:\n\n  \n    \n      app/controllers/comments.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  postController: Ember.inject.controller('post'),\n  post: Ember.computed.reads('postController.model')\n});\n\n\n\n  \n    \n      app/templates/comments.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003ch1\u003eComments for {{post.title}}\u003c/h1\u003e\n\n\u003cul\u003e\n  {{#each model as |comment|}}\n    \u003cli\u003e{{comment.text}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nFor more information about aliases, see the API docs for\naliased properties. If you need have more extensive \"data sharing\" needs across your app, see the services page, which largely replaces injected controllers.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f72002399f11df302a9dac49684ae8dc","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/controllers/","type":"enum"},{"name":"body","value":"Controllers\nControllers are very much like components, so much so that in future versions of\nEmber, controllers will be replaced entirely with components. At the moment,\ncomponents cannot be routed to, but when this changes, it will be recommended\nto replace all controllers with components.\n\nBecause of this,\nmodern Ember applications don't often use controllers. When they do, their\nresponsibility is strictly limited to two avenues:\n\n\nControllers maintain state based on the current route. In general, models\nwill have properties that are saved to the server, while controllers will\nhave properties that your app does not need to save to the server.\nUser actions pass through the controller layer when moving from\na component to a route.\n\n\nThe context of templates rendered by a route is a corresponding\ncontroller. Ember's following of \"convention over configuration\" means\nyou should only create a controller if you need one. If not, everything\ncontinues to \"Just Work\".\n\nLet's explore the example of a route displaying a blog post. Presume a\nBlogPost model that is presented in a blog-post template.\n\nThe BlogPost model would have properties like:\n\n\ntitle\nintro\nbody\nauthor\n\n\nYour template would bind to these properties in the blog-post\ntemplate:\n\n  \n    \n      app/templates/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  \u003ch1\u003e{{model.title}}\u003c/h1\u003e\n\u003ch2\u003eby {{model.author}}\u003c/h2\u003e\n\n\u003cdiv class=\"intro\"\u003e\n  {{model.intro}}\n\u003c/div\u003e\n\u003chr\u003e\n\u003cdiv class=\"body\"\u003e\n  {{model.body}}\n\u003c/div\u003e\n\n\n\nIn this simple example, we don't have any display-specific properties\nor actions just yet. For now, our controller's model property just acts as a\npass-through (or \"proxy\") for the model properties. (Remember that\na controller gets the model it represents from its route handler.)\n\nLet's say we wanted to add a feature that would allow the user to\ntoggle the display of the body section. To implement this, we would\nfirst modify our template to show the body only if the value of a\nnew isExpanded property is true.\n\n  \n    \n      app/templates/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  \u003ch1\u003e{{model.title}}\u003c/h1\u003e\n\u003ch2\u003eby {{model.author}}\u003c/h2\u003e\n\n\u003cdiv class='intro'\u003e\n  {{model.intro}}\n\u003c/div\u003e\n\u003chr\u003e\n\n{{#if isExpanded}}\n  \u003cbutton {{action \"toggleBody\"}}\u003eHide Body\u003c/button\u003e\n  \u003cdiv class=\"body\"\u003e\n    {{model.body}}\n  \u003c/div\u003e\n{{else}}\n  \u003cbutton {{action \"toggleBody\"}}\u003eShow Body\u003c/button\u003e\n{{/if}}\n\n\n\nIn the controller, you can then define what the action does within\nthe actions hook, just as you would with a component:\n\n  \n    \n      app/controllers/blog-post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Controller.extend({\n  actions: {\n    toggleBody() {\n      this.toggleProperty('isExpanded');\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a54077923b8a93308baa1922a604275","fields":[{"name":"title","value":"Inspecting Objects via the Container","type":"string"},{"name":"url","value":"/ember-inspector/container/","type":"enum"},{"name":"body","value":"Every Ember application has a container that maintains object instances for you. You can\ninspect these instances using the Container tab. This is useful for objects\nthat don't fall under a dedicated menu, such as services.\n\n\n\nClick on the Container tab, and you will see a list of instances the container is holding. Click on a type to see the list of all instances of that type maintained by the container.\nInspecting Instances\nClick on a row to inspect a given instance using the Object Inspector.\n\n\nFilter and Reload\nYou can reload the container tab by clicking on the reload icon. To search for instances, type a query in the search box.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e43dd675078ff4ac486b57fa13d5c944","fields":[{"name":"title","value":"Data Tab","type":"string"},{"name":"url","value":"/ember-inspector/data/","type":"enum"},{"name":"body","value":"You can inspect your models by clicking on the Data menu. Check out Building a Data Custom Adapter below if you maintain your own persistence library. \n\nWhen you open the Data tab, you will see a list of model types defined\nin your application, along with the number of loaded records.\nThe Inspector displays the loaded records when you click on a model type.\n\n\nInspecting Records\nEach row in the list corresponds to one record. The first four model attributes are shown in the list view. Clicking on the record will open the Object Inspector for that record, and display all attributes.\n\n\nRecord States and Filtering\nThe Data tab is kept in sync with the data loaded in your application.\nAny record additions, deletions, or changes are reflected immediately. If you have unsaved\nrecords, they will be displayed in green by clicking on the New pill.\n\n\n\nClick on the Modified pill to display unsaved record modifications.\n\n\n\nYou can also filter records by entering a query in the search box.\nBuilding a Data Custom Adapter\nYou can use your own data persistence library with the Inspector. Build a data adapter, and you can inspect your models\nusing the Data tab. Use Ember Data's data adapter as an example for how to build your data adapter.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f1bedd99c57f624399a149361ed1ea21","fields":[{"name":"title","value":"Tackling Deprecations","type":"string"},{"name":"url","value":"/ember-inspector/deprecations/","type":"enum"},{"name":"body","value":"As part of making your app upgrades as smooth as possible, the Inspector gathers your deprecations, groups them, and displays them in a\nway that helps you fix them.\n\nTo view the list of deprecations in an app, click on the Deprecations menu.\n\n\n\nYou can see the total number of deprecations next to the Deprecations menu.\nYou can also see the number of occurrences for each deprecation.\nEmber CLI Deprecation Sources\nIf you are using Ember CLI and have source maps enabled, you can see a\nlist of sources for each deprecation. If you are using Chrome or Firefox,\nclicking on the source opens the sources panel and takes you to\nthe code that caused the deprecation message to be displayed.\n\n\n\n\n\nYou can send the deprecation message's stack trace to the\nconsole by clicking on Trace in the console.\nTransition Plans\nClick on the \"Transition Plan\" link for information on how to remove the deprecation warning, and you'll be taken to a helpful deprecation guide on the Ember website.\n\n\nFiltering and Clearing\nYou can filter the deprecations by typing a query in the search box.\nYou can also clear the current deprecations by clicking on the clear icon\nat the top.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4d3cec3ae6d2506e5e756dc6182d88bb","fields":[{"name":"title","value":"Library Info","type":"string"},{"name":"url","value":"/ember-inspector/info/","type":"enum"},{"name":"body","value":"To see a list of libraries used in your application, click on the Info menu. This view displays the libraries used, along with their version.\n\n\nRegistering a Library\nIf you would like to add your own application or library to the list, you can register it using:\n\n  1\n\n  Ember.libraries.register(libraryName, libraryVersion);\n\n\nEmber Cli\nIf you're using the ember-cli-app-version addon, your application's name and version will be added to the list automatically.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6ffdaf430e1066949e727f7e18a926c0","fields":[{"name":"title","value":"Installing the Inspector","type":"string"},{"name":"url","value":"/ember-inspector/installation/","type":"enum"},{"name":"body","value":"The Ember Inspector is a browser add-on designed to help you understand and debug your Ember applications.\n\nYou can install the Inspector on Google Chrome, Firefox, other\nbrowsers (via a bookmarklet), and on mobile devices by following the steps below.\nGoogle Chrome\nYou can install the Inspector on Google Chrome as a new Developer\nTool. To begin, visit the Extension page on the Chrome Web Store.\n\nClick on \"Add To Chrome\":\n\n\n\nOnce installed, go to an Ember application, open the Developer Tools,\nand click on the Ember tab at the far right.\n\n\nFile:// protocol\nTo use the Inspector with the file:// protocol, visit chrome://extensions in Chrome and check the \"Allow access to file URLs\" checkbox:\n\n\nEnable Tomster\nYou can configure a Tomster icon to show up in Chrome's URL bar whenever you are visiting a site that uses Ember.\n\nVisit chrome://extensions, then click on Options.\n\n\n\nMake sure the \"Display the Tomster\" checkbox is checked.\n\n\nFirefox\nVisit the Add-on page on the Mozilla Add-ons\nsite.\n\nClick on \"Add to Firefox\".\n\n\n\nOnce installed, go to an Ember application, open the Developer Tools,\nand click on the Ember tab.\n\n\nEnable Tomster\nTo enable the Tomster icon to show up in the URL bar whenever you are\nvisiting a site that uses Ember visit about:addons.\n\nClick on Extensions -\u003e Preferences.\n\n\n\nThen make sure the \"Display the Tomster icon when a site runs Ember.js\" checkbox is checked.\n\n\nVia Bookmarklet\nIf you are using a browser other than Chrome or Firefox, you can use the\nbookmarklet option to use the Inspector.\n\nAdd the following bookmark:\n\nBookmark Me\n\nTo open the Inspector, just click on the new bookmark. Safari blocks popups by default, so you'll need to enable popups before using the bookmarklet.\nMobile Devices\nIf you want to run the Inspector on a mobile device,\nyou can use the Ember CLI Remote Inspector addon.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9893b6fad8e586504102380a81fea52b","fields":[{"name":"title","value":"Object Inspector","type":"string"},{"name":"url","value":"/ember-inspector/object-inspector/","type":"enum"},{"name":"body","value":"The Inspector includes an panel that allows you to view and interact with your Ember objects. \nTo open it, click on any Ember object. You can then view the object's properties.\nViewing Objects\nHere's what you see when you click on an object:\n\n\n\nThe Inspector displays the parent objects and mixins that are composed into the chosen object, including the inherited properties.\n\nEach property value in this view is bound to your application, so if the value of a \nproperty updates in your app, it will be reflected in the Inspector.\n\nIf a property name is preceded by a calculator icon, that means it is a computed property. If the value of a computed property hasn't yet been computed, you can\nclick on the calculator to compute it.\nExposing Objects to the ConsoleSending from the Inspector to the Console\nYou can expose objects to the console by clicking on the $E button within the Inspector.\nThis will set the global $E variable to the chosen object.\n\n\n\nYou can also expose properties to the console. When you hover over an object's properties, a $E button will appear\nnext to every property. Click on it to expose the property's value to the\nconsole.\n\n\nSending from the Console to the Inspector\nYou can send Ember objects and arrays to the Inspector by using\nEmberInspector.inspect within the console.\n\n  1\n2\n\n  var object = Ember.Object.create();\nEmberInspector.inspect(object);\n\n\n\nMake sure the Inspector is active when you call this method.\nEditing Properties\nYou can edit String, Number, and Boolean properties in the Inspector.\nYour changes will be reflected immediately in your app. Click on a property's value to start editing it.\n\n\n\nEdit the property and press the ENTER key to commit the change, or ESC to cancel.\nNavigating the Inspector\nIn addition to inspecting the properties above, you can inspect properties that hold Ember objects or arrays.\nClick on the property's value to inspect it.\n\n\n\nYou can continue drill into the Inspector as long as properties contain either an\nEmber object or an array.\nIn the image below, we clicked on the model property first, then clicked\non the store property.\n\n\n\nYou can see the path to the current object at the top of the\nInspector. You can go back to the previous object by clicking on the\nleft-facing arrow at the top left.\nCustom Property Grouping\nSome properties are not only grouped by inheritance, but also\nby framework level semantics. For example, if you inspect an Ember Data\nmodel, you can see Attributes, Belongs To, Has Many, and Flags\ngroups.\n\n\n\nLibrary authors can customize how any object will display in the Inspector. \nBy defining a _debugInfo method, an object can tell the Inspector how it should be rendered.\nFor an example on how to customize an object's properties, see Ember Data's\ncustomization.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"586a911ed3096cd96da506f68a4f75ac","fields":[{"name":"title","value":"Debugging Promises","type":"string"},{"name":"url","value":"/ember-inspector/promises/","type":"enum"},{"name":"body","value":"The Inspector provides a way to look at all Promises created\nin your application. Click on the Promises menu to start inspecting them.\n\n\n\nYou can see a hierarchical list of Promises with labels describing each\nPromise, its state, its settled value, and the time it took to\nsettle.\nPromise States and Filtering\nPromises have different colors based on their state.\n\n\n\n\n\n\n\nYou can filter by clicking on the following pills: Rejected, Pending, Fulfilled.\n\n\n\nYou can also search for Promises by typing a query in the search box.\n\nTo clear the currently logged Promises, click on the clear icon on the\ntop left of the tab.\nInspecting Settled Values\nIf the fulfillment value of a Promise is an Ember object or an array, you can click\non that object to open it in the Object Inspector.\n\n\n\nIf the rejection value is an Error object, you can send its stack trace to\nthe console.\n\n\n\nYou can also click on the $E button to send the value to the console.\nTracing\nThe Inspector provides a way to view a Promise's stack trace.\nTracing Promises is disabled by default for performance reasons. To\nenable tracing, check the Trace promise checkbox. You may want to\nreload to trace existing Promises.\n\n\n\nTo trace a Promise, click on the Trace button next to the label,\nwhich will send the Promise stack trace to the console.\n\n\nLabeling Promises\nPromises generated by Ember are all labeled by default.\nYou can also label your own RSVP Promises to find them in the Inspector's Promises tab.\nAll RSVP methods can take a label as the final argument.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  \nvar label = 'Find Posts'\n\nnew RSVP.Promise(method, label);\n\nRSVP.Promise.resolve(value, label);\n\nRSVP.Promise.reject(reason, label);\n\nRSVP.Promise.all(array, label);\n\nRSVP.Promise.hash(hash, label);\n\npromise.then(success, failure, label);\n\npromise.catch(callback, label);\n\npromise.finally(callback, label);\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ed658525bc79f3040009b9bb48c2b542","fields":[{"name":"title","value":"Rendering Performance","type":"string"},{"name":"url","value":"/ember-inspector/render-performance/","type":"enum"},{"name":"body","value":"You can use the Inspector to measure your app's render times. Click on Render Performance to start inspecting render times.\n\n\nAccuracy\nUsing the Inspector adds a delay to your rendering, so the durations you see\nare not an accurate representation of the speed of your production apps. Use these\ntimes to compare durations and debug rendering bottlenecks, but not as\na way to accurately measure rendering times.\nToolbar\nClick on the \"clear\" icon to remove existing render logs.\n\nTo measure components and templates that are rendered on initial application boot,\nclick on the \"Reload\" button at the top. This button ensures that the Inspector starts\nmeasuring render times when your app boots.\n\nTo filter the logs, type a query in the search box.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"055448419ab0ef77beac250a0a5d84ee","fields":[{"name":"title","value":"Inspecting Routes","type":"string"},{"name":"url","value":"/ember-inspector/routes/","type":"enum"},{"name":"body","value":"The Routes tab displays a list of your application's routes.\n\nFor the following code:\n\n  1\n2\n3\n\n  this.route('posts', function() {\n  this.route('new');\n});\n\n\n\nThe Inspector displays these routes:\n\n\n\nAs you can see, the Inspector shows the routes you defined as well as the routes\nautomatically generated by Ember.\nViewing the Current Route\nThe Inspector highlights the currently active routes. However, if your app has grown too large for this to be useful, you can use the Current Route Only\ncheckbox to hide all routes except the currently active ones.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b95f5ae41d7e6c6611080f203e11268c","fields":[{"name":"title","value":"Troubleshooting","type":"string"},{"name":"url","value":"/ember-inspector/troubleshooting/","type":"enum"},{"name":"body","value":"Below are some common issues you may encounter when using the Inspector, along with the\nnecessary steps to solve them. If your issue is not listed below, please submit an\nissue to the Inspector's GitHub repo.\nEmber Application Not Detected\nIf the Inspector cannot detect an Ember application, you will see\nthe following message:\n\n\n\nSome of the reasons this may happen:\n\n\nThis is not an Ember application\nYou are using an old Ember version ( \u003c 1.0 ).\nYou are using a protocol other than http or https. For file:// protocol,\nfollow these steps.\nThe Ember application is inside a sandboxed iframe with no url (if you\nare using JS Bin, follow these steps.\n\nUsing the Inspector with JS Bin\nDue to the way JS Bin uses iframes, the Inspector doesn't work with edit\nmode. To use the Inspector with JS Bin, switch to the \"live preview\" mode by clicking on\nthe arrow circled below.\n\n\nApplication is not Detected Without Reload\nIf you always have to reload your application after you open the Inspector, that may mean\nthe application's booted state is corrupt. This happens if you call advanceReadiness or\ndeferReadiness after the application has already booted.\nData Adapter Not Detected\nWhen you click on the Data tab, and see this message:\n\n\n\nIt means that the data persistence library you're using does not support the Inspector.\nIf you are the library's author, see this section on how to add Inspector support to your library.\nPromises Not Detected\nYou click on the Promises tab, and see this message:\n\n\n\nThis happens if you are using a version of Ember \u003c 1.3.\nMissing Promises\nIf the Promises tab is working, but there are Promises you can't find,\nit's probably because these Promises were created before the\nInspector was activated. To detect Promises the moment the app boots, click on the Reload button below:\n\n\nInspector Version Old on Firefox\nFirefox addons need to go through a review process with each update, so the Inspector is usually one version behind.\n\nUnfortunately we don't have control over the Firefox review process, so if you need\nthe latest Inspector version, download and install it manually from\nGitHub.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a9ffd50c1c93761a22ac9b6feb6362a5","fields":[{"name":"title","value":"The View Tree","type":"string"},{"name":"url","value":"/ember-inspector/view-tree/","type":"enum"},{"name":"body","value":"You can use the View Tree to inspect your application's current state.\nThe View Tree shows you the currently rendered templates, models, controllers, and components, in a tree format. Click on the View Tree menu on the left to see these.\n\n\n\nUse the tips described in Object Inspector to inspect models and controllers. See below for templates and components.\nInspecting Templates\nTo see how a template was rendered by Ember, click on the template in the View Tree. If \nyou're using Chrome or Firefox, you'll be sent to the Elements panel with that DOM element selected.\n\n\n\n\nComponents and Inline Views\nThe View Tree ignores components and inline views by default. To load these into the View Tree check the Components and All Views checkboxes.\n\n\n\nYou can then inspect components using the Object Inspector.\nHighlighting TemplatesHovering over the View Tree\nWhen you hover over the items in the View Tree, the related templates will be\nhighlighted in your app. For every highlighted template, you can see the\ntemplate name, and its associated objects.\n\n\nHovering over the app\nIf you want to highlight a template or component directly within your app, click on the magnifying glass in the Inspector, then hover over the app.\nAs your our mouse passes over it, the related template or component will be\nhighlighted.\n\n\n\nIf you click on a highlighted template or component, the Inspector will select it. You can then\nclick on the backing objects to send them to the object inspector.\n\n\n\nClick on the X button to unselect a template.\nDuration\nThe Duration column displays the render time for a given template, including the template's children.\n\n\n\nBy measuring the render time, the Inspector adds a slight delay to the rendering process. As such, the duration is not an exact representation of expected rendering time for a production application. Thus, the rendering duration is more useful to compare times than as an absolute measure of performance.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2921955846de516e46f41f11de521501","fields":[{"name":"title","value":"Core Concepts","type":"string"},{"name":"url","value":"/getting-started/core-concepts/","type":"enum"},{"name":"body","value":"To get started with Ember.js, there are a few core concepts you\nshould understand.\nTemplates\nTemplates, written in the Handlebars language, describe the user interface of\nyour application. In addition to plain HTML, templates can contain expressions,\nlike {{title}} or {{author}}, which take information from a component or\ncontroller and put it into HTML. They can also contain helpers, such as\n{{#if isAdmin}}30 people have viewed your blog today.{{/if}}. Finally, they\ncan contain components such as a template listing blog posts rendering a\ncomponent for each post.\nComponents\nComponents are the primary way user interfaces are organized in Ember. They\nconsist of two parts: a template, and a source file written in JavaScript that\ndefines the component's behavior. For example, a blog application might have a\ncomponent for displaying a list of blog posts called all-posts, and another\ncomponent for displaying an individual post called view-post. If users can\nupvote a post, the view-post component might define a behavior like when the\nuser clicks the upvote button, increase the vote property's value by 1.\nControllers\nControllers are very much like components, so much so that in future versions of\nEmber, controllers will be replaced entirely with components. At the moment,\ncomponents cannot be routed to (see below), but when this changes, it will be\nrecommended to replace all controllers with components.\nModels\nModels represent persistent state. For example, a blog application would want\nto save the content of a blog post when a user publishes it, and so the blog\npost would have a model defining it, perhaps called the Post model. A model\ntypically persists information to a server, although models can be configured to\nsave to anywhere else, such as the browser's Local Storage.\nRoutes\nRoutes load a controller and a template. They can also load one or more models\nto provide data to the controller that can then be displayed by the template.\nFor example, an all-posts route might load all the blog posts from the Post\nmodel, load the all-posts controller, and render the all-posts template.\nSimilarly, a view-post route might load the model for the blog post to be\nshown, load the view-post controller, and render the view-post template.\nThe Router\nThe router maps a URL to a route. For example, when a user visits the /posts\nURL, the router might load the all-posts route. The router can also load\nnested routes. For example, if our blogging app had a list of blog posts on the\nleft of the screen and then showed the current blog post on the right, we'd say\nthat the view-post route was nested inside the all-posts route.\n\nPerhaps the most important thing to remember about Ember is that the URL drives\nthe state of the application. The URL determines what route to load, which in\nturn determines what model, controller, and template to load.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9062fa0a8a2361f3f0dda5edfaa94669","fields":[{"name":"title","value":"Your First Ember App","type":"string"},{"name":"url","value":"/getting-started/first-app/","type":"enum"},{"name":"body","value":"Now that you have Ember CLI installed, you can create your first Ember app by\nrunning:\n\n  1\n\n  ember new my-new-app\n\n\n\nThis will create a new my-new-app directory with your new Ember app inside.\n\nOnce the process finishes, launch the Ember development server:\n\n  1\n2\n\n  cd my-new-app\nember server\n\n\n\nNavigate to http://localhost:4200 to see your app in action.\n\nThe Ember CLI development server\nprovides features like rebuilding your app every time a file changes, and a\nmock server for setting up fake data when testing your app.\n\nIn a production environment, you'll\nwant to build an optimized version of your website assets that can be copied to a\nserver. To build your app for production, run:\n\n  1\n\n  ember build --environment=production\n\n\n\nWhen this finishes the dist/ directory will contain a version of your\napplication suitable for production use. Copy the contents of\nthis folder to your production server. Alternatively you can, explore the\nember-cli-deploy addon for\nmore advanced functionality.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"59427847e14331e01de43a097e3ee4cb","fields":[{"name":"title","value":"Installing Ember","type":"string"},{"name":"url","value":"/getting-started/","type":"enum"},{"name":"body","value":"Getting started with Ember.js is easy. Ember.js projects are created and managed\nthrough our command line build tool Ember CLI.\nThis tool provides:\n\n\nModern application asset management (including concatenation, minifying, and versioning)\nGenerators to help you create components, routes, and more\nA conventional project layout, so approaching existing Ember.js applications is easy\nSupport for ES2015/ES6 JavaScript via the Babel\nproject. This includes support for JavaScript modules, which are used\nthroughout this guide.\nA complete QUnit test harness\nThe ability to consume a growing ecosystem of Ember Addons\n\nDependenciesNode.js and npm\nEmber CLI is built with JavaScript, and expects the Node.js\nruntime. It also requires dependencies fetched via npm. npm is packaged with Node.js, so if your computer has Node.js\ninstalled you are ready to go.\n\nEmber requires Node.js 0.12 or higher and npm 2.7 or higher.\nIf you're not sure whether you have Node.js, run this on your\ncommand line:\n\n  1\n\n  node --version\n\n\n\nThe output should give a version number. If it gives a \"command not found\" error instead:\n\n\nWindows or Mac users can download and run this Node.js installer.\nMac users often prefer to install Node using Homebrew. After\ninstalling Homebrew, run brew install node to install Node.js.\nLinux users can use this guide for Node.js installation on Linux.\n\n\nOnce you've got Node.js installed, re-run node --version to verify your\ncomputer's setup.\nGit\nEmber requires Git to manage many of its dependencies. Git comes with Mac OS\nX and most Linux distributions. Windows users can\ndownload and run this Git installer.\nWatchman (optional)\nOn Mac and Linux, you can improve file watching performance by installing Watchman.\nInstallation\nInstall Ember using npm:\n\n  1\n\n  npm install -g ember-cli\n\n\n\nWhile you're at it we recommend you also install PhantomJS to run tests from\nthe command line (without the need for a browser to be open):\n\n  1\n\n  npm install -g phantomjs2\n\n\n\nTo verify that your installation was successful, run:\n\n  1\n\n  ember -v\n\n\n\nIf the result is something like version: 1.13.0, you're ready to go.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6666cd76f96956469e7be39d750cc7d9","fields":[{"name":"title","value":"Ember.js Guides","type":"string"},{"name":"url","value":"/","type":"enum"},{"name":"body","value":"Welcome to the Ember.js Guides! This documentation will take you from\ntotal beginner to Ember expert.\n\nOn the left side of each page in the Guides is a table of contents,\norganized into sections that can be expanded to show the topics\nthey cover. Both the sections and the topics within each section are\nordered from the most basic concepts to more advanced.\n\nThe Guides are intended to contain practical explanations of how to\nbuild Ember apps, focusing on the most widely-used features of Ember.js.\nFor exhaustive documentation of every Ember feature and API, see the\nEmber.js API documentation.\n\nThese guides are written in Markdown and are\navailable on GitHub.\nIf there is something missing, or you find a typo or\nmistake, please help us by filing an issue or submitting a pull\nrequest. You can easily jump to Github's editor for any page by\nclicking the pencil icon in the upper right corner.\n\nGood luck!\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"dcff186751ba7af99e321b5fe8d3f4dc","fields":[{"name":"title","value":"Creating, Updating and Deleting","type":"string"},{"name":"url","value":"/models/creating-updating-and-deleting-records/","type":"enum"},{"name":"body","value":"Creating Records\nYou can create records by calling the createRecord method on the store.\n\n  1\n2\n3\n4\n\n  store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\n\n\nThe store object is available in controllers and routes using this.store.\n\nAlthough createRecord is fairly straightforward, the only thing to watch out for\nis that you cannot assign a promise as a relationship, currently.\n\nFor example, if you want to set the author property of a post, this would not work\nif the user with id isn't already loaded into the store:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var store = this.store;\n\nstore.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum',\n  author: store.findRecord('user', 1)\n});\n\n\n\nHowever, you can easily set the relationship after the promise has fulfilled:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var store = this.store;\n\nvar post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nstore.findRecord('user', 1).then(function(user) {\n  post.set('author', user);\n});\n\n\nUpdating Records\nMaking changes to Ember Data records is as simple as setting the attribute you\nwant to change:\n\n  1\n2\n3\n4\n\n  this.store.findRecord('person', 1).then(function(tyrion) {\n  // ...after the record has loaded\n  tyrion.set('firstName', \"Yollo\");\n});\n\n\n\nAll of the Ember.js conveniences are available for\nmodifying attributes. For example, you can use Ember.Object's\nincrementProperty helper:\n\n  1\n\n  person.incrementProperty('age'); // Happy birthday!\n\n\nPersisting Records\nRecords in Ember Data are persisted on a per-instance basis.\nCall save() on any instance of DS.Model and it will make a network request.\n\nEmber Data takes care of tracking the state of each record for\nyou. This allows Ember Data to treat newly created records differently\nfrom existing records when saving.\n\nBy default, Ember Data will POST newly created records to their type url.\n\n  1\n2\n3\n4\n5\n6\n\n  var post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\npost.save(); // =\u003e POST to '/posts'\n\n\n\nRecords that already exist on the backend are updated using the HTTP PATCH verb.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  store.findRecord('post', 1).then(function(post) {\n  post.get('title'); // =\u003e \"Rails is Omakase\"\n\n  post.set('title', 'A new post');\n\n  post.save(); // =\u003e PUT to '/posts/1'\n});\n\n\n\nYou can tell if a record has outstanding changes that have not yet been\nsaved by checking its hasDirtyAttributes property. You can also see what parts of\nthe record were changed and what the original value was using the\nchangedAttributes function.  changedAttributes returns an object,\nwhose keys are the changed properties and values are an array of values\n[oldValue, newValue].\n\n  1\n2\n3\n4\n5\n\n  person.get('isAdmin');            //=\u003e false\nperson.get('hasDirtyAttributes'); //=\u003e false\nperson.set('isAdmin', true);\nperson.get('hasDirtyAttributes'); //=\u003e true\nperson.changedAttributes();       //=\u003e { isAdmin: [false, true] }\n\n\n\nAt this point, you can either persist your changes via save() or you\ncan rollback your changes. Calling rollbackAttributes() reverts all the\nchangedAttributes to their original value.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  person.get('hasDirtyAttributes'); //=\u003e true\nperson.changedAttributes();       //=\u003e { isAdmin: [false, true] }\n\nperson.rollbackAttributes();\n\nperson.get('hasDirtyAttributes'); //=\u003e false\nperson.get('isAdmin');            //=\u003e false\nperson.changedAttributes();       //=\u003e {}\n\n\nPromises\nsave() returns a promise, which makes easy to asynchronously handle\n success and failure scenarios.  Here's a common pattern:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  var post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nvar self = this;\n\nfunction transitionToPost(post) {\n  self.transitionToRoute('posts.show', post);\n}\n\nfunction failure(reason) {\n  // handle the error\n}\n\npost.save().then(transitionToPost).catch(failure);\n\n// =\u003e POST to '/posts'\n// =\u003e transitioning to posts.show route\n\n\nDeleting Records\nDeleting records is just as straightforward as creating records. Just\ncall deleteRecord() on any instance of DS.Model. This flags the\nrecord as isDeleted. The deletion can then be persisted using\nsave().  Alternatively, you can use the destroyRecord method to\ndelete and persist at the same time.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  store.findRecord('post', 1).then(function(post) {\n  post.deleteRecord();\n  post.get('isDeleted'); // =\u003e true\n  post.save(); // =\u003e DELETE to /posts/1\n});\n\n// OR\nstore.findRecord('post', 2).then(function(post) {\n  post.destroyRecord(); // =\u003e DELETE to /posts/2\n});\n\n\n\nDeleted records will still show up in RecordArrays returned by\nstore.peekAll and hasMany relationships until they have been\nsuccessfully saved.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c789ddb5644abcf443cde5398de5f989","fields":[{"name":"title","value":"Customizing Adapters","type":"string"},{"name":"url","value":"/models/customizing-adapters/","type":"enum"},{"name":"body","value":"In Ember Data, the Adapter determines how data is persisted to a\nbackend data store, such as the URL format and headers for a REST API.\n(The format of the data itself is determined by the\nserializer.)\nEmber Data's default Adapter has some built-in\nassumptions of how a REST API should look. If\nyour backend conventions differ from these assumptions Ember Data\nmakes it easy to change its functionality by swapping out or extending\nthe default Adapter.\n\nSome reasons for customizing an Adapter include using\nunderscores_case in your urls, using a medium other than REST to\ncommunicate with your backend API or even using a\nlocal storage backend.\n\nExtending Adapters is a natural process in Ember Data. Ember takes the\nposition that you should extend an adapter to add different\nfunctionality. This results in code that is\nmore testable, easier to understand and reduces bloat for people who\nmay want to subclass your adapter.\n\nIf your backend has some consistent rules you can define an\nadapter:application. The adapter:application will get priority over\nthe default Adapter, however it will still be superseded by model\nspecific Adapters.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.JSONAPIAdapter.extend({\n  // Application specific overrides go here\n});\n\n\n\nIf you have one model that has exceptional rules for communicating\nwith its backend than the others you can create a Model specific\nAdapter by running the command ember generate adapter adapter-name\".\nFor example, running ember generate adapter post will create the\nfollowing file:\n\n  \n    \n      app/adapters/post.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.JSONAPIAdapter.extend({\n  namespace: 'api/v1'\n});\n\n\n\nBy default Ember Data comes with several builtin adapters. Feel free\nto use these adapters as a starting point for creating your own custom\nadapter.\n\n\nDS.Adapter is the basic adapter\nwith no functionality. It is generally a good starting point if you\nwant to create an adapter that is radically different from the other\nEmber adapters.\nDS.JSONAPIAdapter\nThe JSONAdapter is the default adapter and follows JSON API\nconventions to communicate with an HTTP server by transmitting JSON\nvia XHR.\nDS.RESTAdapter\nThe RESTAdapter allows your store to communicate with an HTTP server\nby transmitting JSON via XHR. Before Ember Data 2.0 this adapter was the default.\n\nCustomizing the JSONAPIAdapter\nThe\nDS.JSONAPIAdapter\nhas a handful of hooks that are commonly used to extend it to work\nwith non-standard backends.\nURL Conventions\nThe JSONAPIAdapter is smart enough to determine the URLs it\ncommunicates with based on the name of the model. For example, if you\nask for a Post by ID:\n\n  1\n2\n\n  store.find('post', 1).then(function(post) {\n});\n\n\n\nThe JSON API adapter will automatically send a GET request to /posts/1.\n\nThe actions you can take on a record map onto the following URLs in the\nJSON API adapter:\n\n\n  \n    ActionHTTP VerbURL\n  \n  \n    FindGET/posts/123\n    Find AllGET/posts\n    UpdatePATCH/posts/123\n    CreatePOST/posts\n    DeleteDELETE/posts/123\n  \n\nPluralization Customization\nTo facilitate pluralizing model names when generating route urls Ember\nData comes bundled with\nEmber Inflector, a\nActiveSupport::Inflector compatible library for inflecting words\nbetween plural and singular forms. Irregular or uncountable\npluralizations can be specified via Ember.Inflector.inflector:\n\n  1\n2\n3\n4\n\n  var inflector = Ember.Inflector.inflector;\n\ninflector.irregular('formula', 'formulae');\ninflector.uncountable('advice');\n\n\n\nThis will tell the JSON API adapter that requests for formula\nshould go to /formulae/1 instead of /formulas/1.\nEndpoint Path Customization\nThe namespace property can be used to prefix requests with a\nspecific url namespace.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.JSONAPIAdapter.extend({\n  namespace: 'api/1'\n});\n\n\n\nRequests for person would now target http://emberjs.com/api/1/people/1.\nHost Customization\nBy default the adapter will target the current domain. If you would\nlike to specify a new domain you can do so by setting the host\nproperty on the adapter.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.JSONAPIAdapter.extend({\n  host: 'https://api.example.com'\n});\n\n\n\nRequests for person would now target https://api.example.com/people/1.\nPath Customization\nBy default the JSONAPIAdapter will attempt to pluralize and dasherize\nthe model name to generate the path name. If this convention does not\nconform to your backend you can override the pathForType method.\n\nFor example, if you did not want to pluralize model names and needed\nunderscore_case instead of camelCase you could override the\npathForType method like this:\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.JSONAPIAdapter.extend({\n  pathForType: function(type) {\n    return Ember.String.underscore(type);\n  }\n});\n\n\n\nRequests for person would now target /person/1.\nRequests for user-profile would now target /user_profile/1.\nHeaders customization\nSome APIs require HTTP headers, e.g. to provide an API key. Arbitrary\nheaders can be set as key/value pairs on the JSONAPIAdapter's headers\nobject and Ember Data will send them along with each ajax request.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default DS.JSONAPIAdapter.extend({\n  headers: {\n    'API_KEY': 'secret key',\n    'ANOTHER_HEADER': 'Some header value'\n  }\n});\n\n\n\nheaders can also be used as a computed property to support dynamic\nheaders. In the example below, the session object has been\ninjected into an adapter by Ember's container.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default DS.JSONAPIAdapter.extend({\n  session: Ember.inject.service('session'),\n  headers: Ember.computed('session.authToken', function() {\n    return {\n      'API_KEY': this.get('session.authToken'),\n      'ANOTHER_HEADER': 'Some header value'\n    };\n  })\n});\n\n\n\nIn some cases, your dynamic headers may require data from some\nobject outside of Ember's observer system (for example\ndocument.cookie). You can use the\nvolatile\nfunction to set the property into a non-cached mode causing the headers to\nbe recomputed with every request.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default DS.JSONAPIAdapter.extend({\n  headers: Ember.computed(function() {\n    return {\n      'API_KEY': Ember.get(document.cookie.match(/apiKey\\=([^;]*)/), '1'),\n      'ANOTHER_HEADER': 'Some header value'\n    };\n  }).volatile()\n});\n\n\nAuthoring Adapters\nThe defaultSerializer property can be used to specify the serializer\nthat will be used by this adapter. This is only used when a model\nspecific serializer or serializer:application are not defined.\n\nIn an application, it is often easier to specify an\nserializer:application. However, if you are the author of a\ncommunity adapter it is important to remember to set this property to\nensure Ember does the right thing in the case a user of your adapter\ndoes not specify an serializer:application.\n\n  \n    \n      app/adapters/my-custom-adapter.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.JSONAPIAdapter.extend({\n  defaultSerializer: '-default'\n});\n\n\nCommunity Adapters\nIf none of the builtin Ember Data Adapters work for your backend,\nbe sure to check out some of the community maintained Ember Data\nAdapters. Some good places to look for Ember Data Adapters include:\n\n\nEmber Observer\nGitHub\nBower\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8ccdb38204bead9bd7201fad99ebdf90","fields":[{"name":"title","value":"Customizing Serializers","type":"string"},{"name":"url","value":"/models/customizing-serializers/","type":"enum"},{"name":"body","value":"In Ember Data, serializers format the data sent to and recieved from\nthe backend store. By default, Ember Data serializes data using the\nJSON API format. If your backend uses a different\nformat, Ember Data allows you to customize the serializer or use a\ndifferent serializer entirely.\n\nEmber Data ships with 3 Serializers. The\nJSONAPISerializer is the default serializer and works with JSON API\nbackends. The JSONSerializer is a simple serializer for working with\nsingle json object or arrays of records. The RESTSerializer is a\nmore complex serializer that supports sideloading and was the default\nserializer before 2.0.\nJSONAPISerializer Conventions\nWhen requesting a record, the JSONAPISerializer expects your server\nto return a JSON representation of the record that conforms to the\nfollowing conventions.\nJSON API Document\nThe JSONAPI serializer expects the backend to return a JSON API\nDocument that follows the JSON API specification and the conventions\nof the examples found on http://jsonapi.org/format/. This means all\ntype names should be pluralized and attribute and relationship names\nshould be dash-cased. For example, if you request a record from\n/people/123, the response should looks like this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  {\n  \"data\": {\n    \"type\": \"people\",\n    \"id\": \"123\",\n    \"attributes\": {\n      \"first-name\": \"Jeff\",\n      \"last-name\": \"Atwood\"\n    }\n  }\n}\n\n\n\nA response that contains multiple records may have an array in its\ndata property.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  {\n  \"data\": [{\n    \"type\": \"people\",\n    \"id\": \"123\",\n    \"attributes\": {\n      \"first-name\": \"Jeff\",\n      \"last-name\": \"Atwood\"\n    }\n  }, {\n    \"type\": \"people\",\n    \"id\": \"124\",\n    \"attributes\": {\n      \"first-name\": \"Yehuda\",\n      \"last-name\": \"Katz\"\n    }\n  }]\n}\n\n\nSideloaded Data\nData that is not a part of the primary request but includes linked\nrelationships should be placed in an array under the included\nkey. For example if you /people/1 and the backend also returned any\ncomments associated with that relationship the response should look\nlike this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n  {\n  \"data\": {\n    \"type\": \"articles\",\n    \"id\": \"1\",\n    \"attributes\": {\n      \"title\": \"JSON API paints my bikeshed!\"\n    },\n    \"links\": {\n      \"self\": \"http://example.com/articles/1\"\n    },\n    \"relationships\": {\n      \"comments\": {\n        \"data\": [\n          { \"type\": \"comments\", \"id\": \"5\" },\n          { \"type\": \"comments\", \"id\": \"12\" }\n        ]\n      }\n    }\n  }],\n  \"included\": [{\n    \"type\": \"comments\",\n    \"id\": \"5\",\n    \"attributes\": {\n      \"body\": \"First!\"\n    },\n    \"links\": {\n      \"self\": \"http://example.com/comments/5\"\n    }\n  }, {\n    \"type\": \"comments\",\n    \"id\": \"12\",\n    \"attributes\": {\n      \"body\": \"I like XML better\"\n    },\n    \"links\": {\n      \"self\": \"http://example.com/comments/12\"\n    }\n  }]\n}\n\n\nCustomizing Serializers\nEmber Data uses the JSONAPISerializer by default, but you can\noverride this default by defining a custom serializer. There are two\nways to define a custom serializer. First, you can define a custom\nserializer for you entire application by defining an \"application\"\nserializer.\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n\n  import DS from 'ember-data';\n\nexport default DS.JSONSerializer.extend({});\n\n\n\nYou can also define serializer for a specific model. For example if\nyou had a post model you could also define a post serializer:\n\n  \n    \n      app/serializers/post.js\n    \n  \n\n  1\n2\n3\n\n  import DS from 'ember-data';\n\nexport default DS.JSONSerializer.extend({});\n\n\n\nTo change the format of the data that is sent to the backend store, you can use\nthe serialize hook. Let's say that we have this JSON API response from Ember\nData:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  {\n  \"data\": {\n    \"attributes\": {\n      \"id\": \"1\",\n      \"name\": \"My Product\",\n      \"amount\": 100,\n      \"currency\": \"SEK\"\n    },\n    \"type\": \"product\"\n  }\n}\n\n\n\nBut our server expects data in this format:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  {\n  \"data\": {\n    \"attributes\": {\n      \"id\": \"1\",\n      \"name\": \"My Product\",\n      \"cost\": {\n        \"amount\": 100,\n        \"currency\": \"SEK\"\n      }\n    },\n    \"type\": \"product\"\n  }\n}\n\n\n\nHere's how you can change the data:\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  import DS from 'ember-data';\n\nexport default DS.JSONSerializer.extend({\n  serialize(snapshot, options) {\n    var json = this._super(...arguments);\n\n    json.data.attributes.cost = {\n      amount: json.data.attributes.amount,\n      currency: json.data.attributes.currency\n    };\n\n    delete json.data.attributes.amount;\n    delete json.data.attributes.currency;\n\n    return json;\n  },\n});\n\n\n\nSimilarly, if your backend store provides data in a format other than JSON API,\nyou can use the normalizeResponse hook. Using the same example as above, if\nthe server provides data that looks like:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  {\n  \"data\": {\n    \"attributes\": {\n      \"id\": \"1\",\n      \"name\": \"My Product\",\n      \"cost\": {\n        \"amount\": 100,\n        \"currency\": \"SEK\"\n      }\n    },\n    \"type\": \"product\"\n  }\n}\n\n\n\nAnd so we need to change it to look like:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  {\n  \"data\": {\n    \"attributes\": {\n      \"id\": \"1\",\n      \"name\": \"My Product\",\n      \"amount\": 100,\n      \"currency\": \"SEK\"\n    },\n    \"type\": \"product\"\n  }\n}\n\n\n\nHere's how we could do it:\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  import DS from 'ember-data';\n\nexport default DS.JSONSerializer.extend({\n  normalizeResponse(store, primaryModelClass, payload, id, requestType) {\n    payload.data.attributes.amount = payload.data.attributes.cost.amount;\n    payload.data.attributes.amount = payload.data.attributes.cost.currency;\n\n    delete payload.data.attributes.cost;\n\n    return this._super(...arguments);\n  },\n});\n\n\n\nTo normalize only a single model, you can use the normalize hook similarly.\n\nFor more hooks to customize the serializer with, see the Ember Data serializer\nAPI documentation.\nIDs\nIn order to keep track of unique records in the store Ember Data\nexpects every record to have an id property in the payload. Ids\nshould be unique for every unique record of a specific type. If your\nbackend used a different key other then id you can use the\nserializer's primaryKey property to correctly transform the id\nproperty to id when serializing and deserializing data.\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.JSONSerializer.extend({\n  primaryKey: '_id'\n});\n\n\nAttribute Names\nIn Ember Data the convention is to camelize attribute names on a\nmodel. For example:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default DS.Model.extend({\n  firstName: DS.attr('string'),\n  lastName:  DS.attr('string'),\n\n  isPersonOfTheYear: DS.attr('boolean')\n});\n\n\n\nHowever, the JSONAPISerializer expects attributes to be dasherized\nin the document payload returned by your server:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  {\n  \"data\": {\n    \"id\": \"44\",\n    \"type\": \"people\",\n    \"attributes\": {\n      \"first-name\": \"Barack\",\n      \"last-name\": \"Obama\",\n      \"is-person-of-the-year\": true\n    }\n  }\n}\n\n\n\nIf the attributes returned by your server use a different convention\nyou can use the serializer's keyForAttribute method to convert an\nattribute name in your model to a key in your JSON payload. For\nexample, if your backend returned attributes that are under_scored\ninstead of dash-cased you could override the keyForAttribute\nmethod like this.\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.JSONAPISerializer.extend({\n  keyForAttribute: function(attr) {\n    return Ember.String.underscore(attr);\n  }\n});\n\n\n\nIrregular keys can be mapped with a custom serializer. The attrs\nobject can be used to declare a simple mapping between property names\non DS.Model records and payload keys in the serialized JSON object\nrepresenting the record. An object with the property key can also be\nused to designate the attribute's key on the response payload.\n\nIf the JSON for person has a key of lastNameOfPerson, and the\ndesired attribute name is simply lastName, then create a custom\nSerializer for the model and override the attrs property.\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  lastName: DS.attr('string')\n});\n\n\n\n  \n    \n      app/serializers/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.JSONAPISerializer.extend({\n  attrs: {\n    lastName: 'lastNameOfPerson',\n  }\n});\n\n\nRelationships\nReferences to other records should be done by ID. For example, if you\nhave a model with a hasMany relationship:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  comments: DS.hasMany('comment', { async: true })\n});\n\n\n\nThe JSON should encode the relationship as an array of IDs and types:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  {\n  \"data\": {\n    \"type\": \"posts\",\n    \"id\": \"1\",\n    \"relationships\": {\n      \"comments\": {\n        \"data\": [\n          { \"type\": \"comments\", \"id\": \"5\" },\n          { \"type\": \"comments\", \"id\": \"12\" }\n        ]\n      }\n    }\n  }\n}\n\n\n\nComments for a post can be loaded by post.get('comments'). The\nJSON API adapter will send 3 GET request to /comments/1/,\n/comments/2/ and /comments/3/.\n\nAny belongsTo relationships in the JSON representation should be the\ndasherized version of the property's name. For example, if you have\na model:\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  originalPost: DS.belongsTo('post')\n});\n\n\n\nThe JSON should encode the relationship as an ID to another record:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  {\n  \"data\": {\n    \"type\": \"comment\",\n    \"id\": \"1\",\n    \"relationships\": {\n      \"original-post\": {\n        \"data\": { \"type\": \"post\", \"id\": \"5\" },\n      }\n    }\n  }\n}\n\n\n\nIf needed these naming conventions can be overwritten by implementing\nthe keyForRelationship method.\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.JSONAPISerializer.extend({\n  keyForRelationship: function(key, relationship) {\n    return key + 'Ids';\n  }\n});\n\n\nCreating Custom Transformations\nIn some circumstances, the built in attribute types of string,\nnumber, boolean, and date may be inadequate. For example, a\nserver may return a non-standard date format.\n\nEmber Data can have new JSON transforms\nregistered for use as attributes:\n\n  \n    \n      app/transforms/coordinate-point.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default DS.Transform.extend({\n  serialize: function(value) {\n    return [value.get('x'), value.get('y')];\n  },\n  deserialize: function(value) {\n    return Ember.create({ x: value[0], y: value[1] });\n  }\n});\n\n\n\n  \n    \n      app/models/cursor.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  position: DS.attr('coordinate-point')\n});\n\n\n\nWhen coordinatePoint is received from the API, it is\nexpected to be an array:\n\n  1\n2\n3\n4\n5\n\n  {\n  cursor: {\n    position: [4,9]\n  }\n}\n\n\n\nBut once loaded on a model instance, it will behave as an object:\n\n  1\n2\n3\n\n  var cursor = store.findRecord('cursor', 1);\ncursor.get('position.x'); //=\u003e 4\ncursor.get('position.y'); //=\u003e 9\n\n\n\nIf position is modified and saved, it will pass through the\nserialize function in the transform and again be presented as\nan array in JSON.\nJSONSerializer\nNot all APIs follow the conventions that the JSONAPISerializer uses\nwith a data namespace and sideloaded relationship records. Some\nlegacy APIs may return a simple JSON payload that is just the resource\nrequest or an array of serialized records. The JSONSerializer is a\nserializer that ships with Ember Data that can be used along side the\nRESTAdapter to serialize these simpler APIs.\n\nTo use it in your application you will need to define an\nadapter:application that extends the JSONSerializer.\n\n  \n    \n      app/serializer/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.JSONSerializer.extend({\n  // ...\n});\n\n\n\nFor requests that are only expected to return 1 record\n(e.g. store.findRecord('post', 1)) the JSONSerializer expects the response\nto be a JSON object that looks similar to this:\n\n  1\n2\n3\n4\n5\n6\n\n  {\n    \"id\": \"1\",\n    \"title\": \"Rails is omakase\",\n    \"tag\": \"rails\",\n    \"comments\": [\"1\", \"2\"]\n}\n\n\n\nFor requests that are only expected to return 0 or more records\n(e.g. store.findAll('post') or store.query('post', { filter: { status: 'draft' } }))\nthe JSONSerializer expects the response to be a JSON array that\nlooks similar to this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  [{\n  \"id\": \"1\",\n  \"title\": \"Rails is omakase\",\n  \"tag\": \"rails\",\n  \"comments\": [\"1\", \"2\"]\n}, {\n  \"id\": \"2\",\n  \"title\": \"I'm Running to Reform the W3C's Tag\",\n  \"tag\": \"w3c\",\n  \"comments\": [\"3\"]\n}]\n\n\n\nThe JSONAPISerializer is built on top of the JSONSerializer so they share\nmany of the same hooks for customizing the behavior of the\nserialization process. Be sure to check out the\nAPI docs\nfor a full list of methods and properties.\nEmbeddedRecordMixin\nAlthough Ember Data encourages you to sideload your relationships,\nsometimes when working with legacy APIs you may discover you need to\ndeal with JSON that contains relationships embedded inside other\nrecords. The EmbeddedRecordsMixin is meant to help with this problem.\n\nTo set up embedded records, include the mixin when extending a\nserializer then define and configure embedded relationships.\n\nFor example if your post model contained an embedded author record\nthat looks similar to this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  {\n    \"id\": \"1\",\n    \"title\": \"Rails is omakase\",\n    \"tag\": \"rails\",\n    \"authors\": [\n        {\n            \"id\": \"2\",\n            \"name\": \"Steve\"\n        }\n    ]\n}\n\n\n\nYou would define your relationship like this:\n\n  \n    \n      app/serializers/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default DS.JSONSerializer.extend(DS.EmbeddedRecordsMixin, {\n  attrs: {\n    author: {\n      serialize: 'records',\n      deserialize: 'records'\n    }\n  }\n});\n\n\n\nIf you find yourself needing to both serialize and deserialize the\nembedded relationship you can use the shorthand option of { embedded:\n'always' }. The following example and the one above are equivalent.\n\n  \n    \n      app/serializers/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.JSONSerializer.extend(DS.EmbeddedRecordsMixin, {\n  attrs: {\n    author: { embedded: 'always' }\n  }\n});\n\n\n\nThe serialize and deserialize keys support 3 options.\n- records is uses to signal that the entire record is expected\n- ids is uses to signal that only the id of the record is expected\n- false is uses to signal that the record is not expected\n\nFor example you may find that you want to read an embedded record when\nextracting a JSON payload but only include the relationship's id when\nserializing the record. This is possible by using the serialize:\n'ids' option. You can also opt out of serializing a relationship by\nsetting serialize: false.\n\n  \n    \n      app/serializers/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default DS.JSONSerializer.extend(DS.EmbeddedRecordsMixin, {\n  attrs: {\n    author: {\n      serialize: false,\n      deserialize: 'records'\n    },\n    comments: {\n      deserialize: 'records',\n      serialize: 'ids'\n    }\n  }\n});\n\n\nEmbeddedRecordsMixin Defaults\nIf you do not overwrite attrs for a specific relationship, the\nEmbeddedRecordsMixin will behave in the following way:\n\nBelongsTo: { serialize: 'id', deserialize: 'id' }\nHasMany:   { serialize: false, deserialize: 'ids' }\n\nThere is an option of not embedding JSON in the serialized payload by\nusing serialize: 'ids'. If you do not want the relationship sent at\nall, you can use serialize: false.\nAuthoring Serializers\nIf you would like to create a custom serializer its recommend that you\nstart with the JSONAPISerializer or JSONSerializer and extend one of\nthose to match your needs. However, if your payload is extremely\ndifferent from one of these serializers you can create your own by\nextending the DS.Serializer base class. There are 3 methods that\nmust be implemented on a serializer.\n\n\nnormalizeResponse\nserialize\nnormalize\n\n\nIts also important to know about the normalized JSON form that Ember\nData expects as an argument to store.push().\n\nstore.push accepts a JSON API document. However, unlike the\nJSONAPISerializer store.push does not do any transformation of the\nrecord's type name or attributes. It is important to make sure that\nthe type name matches the name of the file where it is defined\nexactly. Also attribute and relationship names in the JSON API\ndocument should match the name an casing of the attribute and\nrelationship properites on the Model.\n\nFor Example: given this post model.\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default DS.Model.extend({\n  title: DS.attr('string'),\n  tag: DS.attr('string'),\n  comments: hasMany('comment', { async: false }),\n  relatedPosts: hasMany('post')\n});\n\n\n\nstore.push would accept an object that looked like this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  {\n  data: {\n    id: \"1\",\n    type: 'post',\n    attributes: {\n      title: \"Rails is omakase\",\n      tag: \"rails\",\n    },\n    relationships: {\n      comments: {\n        data: [{ id: \"1\", type: 'comment' },\n               { id: \"2\", type: 'comment' }],\n      },\n      relatedPosts: {\n        data: {\n          related: \"/api/v1/posts/1/related-posts/\"\n        }\n      }\n    }\n}\n\n\n\nEvery serialized record must follow this format for it to be correctly\nconverted into an Ember Data record.\n\nProperties that are defined on the model but are omitted in the\nnormalized JSON API document object will not be updated. Properties\nthat are included in the normalized JSON API document object but not\ndefined on the Model will be ignored.\nCommunity Serializers\nIf none of the builtin Ember Data Serializers work for your backend,\nbe sure to check out some of the community maintained Ember Data\nAdapters and serializers. Some good places to look for Ember Data\nSerializers include:\n\n\nEmber Observer\nGitHub\nBower\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"03e86bc5333f6f64b9e95b540f952f9d","fields":[{"name":"title","value":"Defining Models","type":"string"},{"name":"url","value":"/models/defining-models/","type":"enum"},{"name":"body","value":"A model is a class that defines the properties and behavior of the\ndata that you present to the user. Anything that the user expects to see\nif they leave your app and come back later (or if they refresh the page)\nshould be represented by a model.\n\nWhen you want a new model for your application you need to create a new file\nunder the models folder and extend from DS.Model. This is more conveniently\ndone by using one of Ember CLI's generator commands. For instance, let's create\na person model:\n\n  1\n\n  ember generate model person\n\n\n\nThis will generate the following file:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n\n  export default DS.Model.extend({\n});\n\n\n\nAfter you have defined a model class, you can start finding\nand working with records of that type.\nDefining Attributes\nThe person model we generated earlier didn't have any attributes. Let's\nadd first and last name, as well as the birthday, using DS.attr:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.Model.extend({\n  firstName: DS.attr(),\n  lastName: DS.attr(),\n  birthday: DS.attr()\n});\n\n\n\nAttributes are used when turning the JSON payload returned from your\nserver into a record, and when serializing a record to save back to the\nserver after it has been modified.\n\nYou can use attributes just like any other property, including as part of a\ncomputed property. Frequently, you will want to define computed\nproperties that combine or transform primitive attributes.\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default DS.Model.extend({\n  firstName: DS.attr(),\n  lastName: DS.attr(),\n\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return `${this.get('firstName')} ${this.get('lastName')}`;\n  })\n});\n\n\n\nFor more about adding computed properties to your classes, see Computed\nProperties.\nTransforms\nYou may find the type of an attribute returned by the server does not\nmatch the type you would like to use in your JavaScript code. Ember\nData allows you to define simple serialization and deserialization\nmethods for attribute types called transforms. You can specify that\nyou would like a transform to run for an attribute by providing the\ntransform name as the first argument to the DS.attr method.\n\nFor example if you would like to transform an\nISO 8601 string to a\nJavaScript date object you would define your attribute like this:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  birthday: DS.attr('date')\n});\n\n\n\nEmber Data supports attribute types of string, number, boolean,\nand date. Which coerce the value to the JavaScript type that matches\nits name.\n\nTransforms are not required. If you do not specify a transform name\nEmber Data will do no additional processing of the value.\nOptions\nDS.attr can also take a hash of options as a second parameter. At the moment\nthe only option available is defaultValue, which can use a string or a\nfunction to set the default value of the attribute if one is not supplied.\n\nIn the following example we define that verified has a default value of\nfalse and createdAt defaults to the current date at the time of the model's\ncreation:\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default DS.Model.extend({\n  username: DS.attr('string'),\n  email: DS.attr('string'),\n  verified: DS.attr('boolean', { defaultValue: false }),\n  createdAt: DS.attr('string', {\n    defaultValue() { return new Date(); }\n  })\n});\n\n\nDefining Relationships\nEmber Data includes several built-in relationship types to help you\ndefine how your models relate to each other.\nOne-to-One\nTo declare a one-to-one relationship between two models, use\nDS.belongsTo:\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  profile: DS.belongsTo('profile')\n});\n\n\n\n  \n    \n      app/models/profile.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  user: DS.belongsTo('user')\n});\n\n\nOne-to-Many\nTo declare a one-to-many relationship between two models, use\nDS.belongsTo in combination with DS.hasMany, like this:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  comments: DS.hasMany('comment')\n});\n\n\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  post: DS.belongsTo('post')\n});\n\n\nMany-to-Many\nTo declare a many-to-many relationship between two models, use\nDS.hasMany:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  tags: DS.hasMany('tag')\n});\n\n\n\n  \n    \n      app/models/tag.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  posts: DS.hasMany('post')\n});\n\n\nExplicit Inverses\nEmber Data will do its best to discover which relationships map to one\nanother. In the one-to-many code above, for example, Ember Data can figure out that\nchanging the comments relationship should update the post\nrelationship on the inverse because post is the only relationship to\nthat model.\n\nHowever, sometimes you may have multiple belongsTo/hasManys for\nthe same type. You can specify which property on the related model is\nthe inverse using DS.belongsTo or DS.hasMany's inverse\noption. Relationships without an inverse can be indicated as such by\nincluding { inverse: null }.\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default DS.Model.extend({\n  onePost: DS.belongsTo('post', { inverse: null }),\n  twoPost: DS.belongsTo('post'),\n  redPost: DS.belongsTo('post'),\n  bluePost: DS.belongsTo('post')\n});\n\n\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.Model.extend({\n  comments: DS.hasMany('comment', {\n    inverse: 'redPost'\n  })\n});\n\n\nReflexive Relations\nWhen you want to define a reflexive relation (a model that has a relationship to\nitself), you must explicitly define the inverse relationship. If there\nis no inverse relationship then you can set the inverse to null.\n\nHere's an example of a one-to-many reflexive relationship:\n\n  \n    \n      app/models/folder.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default DS.Model.extend({\n  children: DS.hasMany('folder', { inverse: 'parent' }),\n  parent: DS.belongsTo('folder', { inverse: 'children' })\n});\n\n\n\nHere's an example of a one-to-one reflexive relationship:\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default DS.Model.extend({\n  name: DS.attr('string'),\n  bestFriend: DS.belongsTo('user', { inverse: 'bestFriend' }),\n});\n\n\n\nYou can also define a reflexive relationship that doesn't have an inverse:\n\n  \n    \n      app/models/folder.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  parent: DS.belongsTo('folder', { inverse: null })\n});\n\n\nReadonly Nested Data\nSome models may have properties that are deeply nested objects of\nreadonly data. The naive solution would be to define models for each\nnested object and use hasMany and belongsTo to recreate the nested\nrelationship. However, since readonly data will never need to be\nupdated and saved this often results in the creation of a great deal\nof code for very little benefit. An alternate approch is to define\nthese relationships using an attribute with no transform\n(DS.attr()). This makes it easy to access readonly values in\ncomputed properties and templates without the overhead of defining\nextraneous models.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"54352571d5fd6e786972f119be9dcf80","fields":[{"name":"title","value":"Finding Records","type":"string"},{"name":"url","value":"/models/finding-records/","type":"enum"},{"name":"body","value":"The Ember Data store provides an interface for retrieving records of a single\ntype.\nRetrieving a Single Record\nUse store.findRecord() to retrieve a record by its type and ID. This will\nreturn a promise that fulfills with the requested record:\n\n  1\n\n  var post = this.store.findRecord('post', 1); // =\u003e GET /posts/1\n\n\n\nUse store.peekRecord() to retrieve a record by its type and ID, without making\na network request. This will return the record only if it is already present in\nthe store:\n\n  1\n\n  var post = this.store.peekRecord('post', 1); // =\u003e no network request\n\n\nRetrieving Multiple Records\nUse store.findAll() to retrieve all of the records for a given type:\n\n  1\n\n  var posts = this.store.findAll('post'); // =\u003e GET /posts\n\n\n\nUse store.peekAll() to retrieve all of the records for a given type that are\nalready loaded into the store, without making a network request:\n\n  1\n\n  var posts = this.store.peekAll('post'); // =\u003e no network request\n\n\n\nstore.findAll() returns a DS.PromiseArray that fulfills to a\nDS.RecordArray and store.peekAll directly returns a DS.RecordArray.\n\nIt's important to note that DS.RecordArray is not a JavaScript array.  It is\nan object that implements Ember.Enumerable. This is important because,\nfor example, if you want to retrieve records by index, the [] notation will\nnot work--you'll have to use objectAt(index) instead.\nQuerying for Multiple Records\nEmber Data provides the ability to query for records that meet certain criteria. Calling store.query()\nwill make a GET request with the passed object serialized as query params. This method returns\nDS.PromiseArray in the same way as find.\n\nFor example, we could search for all person models who have the name of\nPeter:\n\n  1\n2\n3\n4\n\n  // GET to /persons?filter[name]=Peter\nthis.store.query('person', { filter: { name: 'Peter' } }).then(function(peters) {\n  // Do something with `peters`\n});\n\n\nQuerying for A Single Record\nIf you know your query will return only one result Ember Data provides\na convenience method that will return a promise that resolves with a\nsingle record. Calling store.queryRecord() will make a GET request\nwith the passed object serialized as query params.\n\nFor example, if we know that an email uniquely identifies a person, we could search for a person model that has an email address of\ntomster@example.com:\n\n  1\n2\n3\n4\n\n  // GET to /persons?filter[email]=tomster@example.com\nthis.store.queryRecord('person', { filter: { email: 'tomster@example.com' } }).then(function(tomster) {\n  // do something with `tomster`\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"aaa673b0a07a7fad8549b3be79862344","fields":[{"name":"title","value":"Handling Metadata","type":"string"},{"name":"url","value":"/models/handling-metadata/","type":"enum"},{"name":"body","value":"Along with the records returned from your store, you'll likely need to handle some kind of metadata. Metadata is data that goes along with a specific model or type instead of a record.\n\nPagination is a common example of using metadata. Imagine a blog with far more posts than you can display at once. You might query it like so:\n\n  1\n2\n3\n4\n\n  let result = this.store.query('post', {\n  limit: 10,\n  offset: 0\n});\n\n\n\nTo get different pages of data, you'd simply change your offset in increments of 10. So far, so good. But how do you know how many pages of data you have? Your server would need to return the total number of records as a piece of metadata.\n\nEach serializer will expect the metadata to be returned differently. For example, Ember Data's JSON deserializer looks for a meta key:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  {\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Progressive Enhancement is Dead\",\n    \"comments\": [\"1\", \"2\"],\n    \"links\": {\n      \"user\": \"/people/tomdale\"\n    },\n    // ...\n  },\n\n  \"meta\": {\n    \"total\": 100\n  }\n}\n\n\n\nRegardless of the serializer used, this metadata is extracted from the response. You can then read it with .get('meta').\n\nThis can be done on the result of a store.query() call:\n\n  1\n2\n3\n\n  store.query('post').then((result) =\u003e {\n  let meta = result.get('meta');\n})\n\n\n\nOn a belongsTo relationship:\n\n  1\n2\n3\n4\n5\n\n  let post = store.peekRecord('post', 1);\n\npost.get('author').then((author) =\u003e {\n  let meta = author.get('meta');\n});\n\n\n\nOr on a hasMany relationship:\n\n  1\n2\n3\n4\n5\n\n  let post = store.peekRecord('post', 1);\n\npost.get('comments').then((comments) =\u003e {\n  let meta = comments.get('meta');\n});\n\n\n\nAfter reading it, meta.total can be used to calculate how many pages of posts you'll have.\n\nTo customize metadata extraction, check out the documentation for your serializer.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f6824ed2e6c9f37fc0a6d7f987afee17","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/models/","type":"enum"},{"name":"body","value":"Models are objects that represent the underlying data that your\napplication presents to the user. Different apps will have very\ndifferent models, depending on what problems they're trying to solve.\n\nFor example, a photo sharing application might have a Photo\nmodel to represent a particular photo, and a PhotoAlbum that\nrepresents a group of photos. In contrast, an online shopping app would\nprobably have different models, like ShoppingCart, Invoice, or\nLineItem.\n\nModels tend to be persistent. That means the user does not expect\nmodel data to be lost when they close their browser window. To make sure\nno data is lost, if the user makes changes to a model, you need to store\nthe model data somewhere that it will not be lost.\n\nTypically, most models are loaded from and saved to a server that uses a\ndatabase to store data. Usually you will send JSON representations of\nmodels back and forth to an HTTP server that you have written. However,\nEmber makes it easy to use other durable storage, such as saving to the\nuser's hard disk with IndexedDB, or hosted storage solutions that let you\navoid writing and hosting your own servers.\n\nOnce you've loaded your models from storage, components know how to\ntranslate model data into a UI that your user can interact with.  For\nmore information about how components get model data, see the\nSpecifying a Route's Model\nguide.\n\nEmber Data, included by default when you create a new application, is a\nlibrary that integrates tightly with Ember to make it easy to retrieve\nmodels from your server as JSON, save updates back to the server, and\ncreate new models in the browser.\n\nThanks to its use of the adapter pattern, Ember Data can be configured\nto work with many different kinds of backends. There is an entire\necosystem of adapters that allow your Ember app to talk to different\ntypes of servers without you writing any networking code.\n\nIf you need to integrate your Ember.js app with a server that does not\nhave an adapter available (for example, you hand-rolled an API server\nthat does not adhere to any JSON specification), Ember Data is designed\nto be configurable to work with whatever data your server returns.\n\nEmber Data is also designed to work with streaming servers, like those\npowered by WebSockets. You can open a socket to your server and push\nchanges into Ember Data whenever they occur, giving your app a real-time\nuser interface that is always up-to-date.\n\nAt first, using Ember Data may feel different than the way you're used\nto writing JavaScript applications. Many developers are familiar with\nusing AJAX to fetch raw JSON data from an endpoint, which may appear\neasy at first. Over time, however, complexity leaks out into your\napplication code, making it hard to maintain.\n\nWith Ember Data, managing models as your application grows becomes both\nsimple and easy.\n\nOnce you have an understanding of Ember Data, you will have a much\nbetter way to manage the complexity of data loading in your application.\nThis will allow your code to evolve without becoming a mess.\nThe Store and a Single Source of Truth\nOne common way of building web applications is to tightly couple user\ninterface elements to data fetching. For example, imagine you are\nwriting the admin section of a blogging app, which has a feature that\nlists the drafts for the currently logged in user.\n\nYou might be tempted to make the component responsible for fetching that\ndata and storing it:\n\n  \n    \n      app/components/list-of-drafts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  willRender() {\n    $.getJSON('/drafts').then(data =\u003e {\n      this.set('drafts', data);\n    });\n  }\n});\n\n\n\nYou could then show the list of drafts in your component's template like\nthis:\n\n  \n    \n      app/templates/components/list-of-drafts.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each drafts key=\"id\" as |draft|}}\n    \u003cli\u003e{{draft.title}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nThis works great for the list-of-drafts component. However, you app\nis likely made up of many different components. On another page you\nmay want a component to display the number of drafts. You may be\ntempted to copy and paste your existing willRender code into the new\ncomponent.\n\n  \n    \n      app/components/drafts-button.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  willRender() {\n    $.getJSON('/drafts').then(data =\u003e {\n      this.set('drafts', data);\n    });\n  }\n});\n\n\n\n  \n    \n      app/templates/components/drafts-button.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#link-to 'drafts' tagName=\"button\"}}\nDrafts ({{drafts.length}})\n{{/link-to}}\n\n\n\nUnfortunately, the app will now make two separate requests for the\nsame information. Not only is the redundant data fetching costly in\nterms of wasted bandwidth and affecting the perceived speed of your\napp, it's easy for the two values to get out-of-sync. You yourself\nhave probably used a web application where the list of items gets out\nof sync with the counter in a toolbar, leading to a frustrating and\ninconsistent experience.\n\nThere is also a tight coupling between your application's UI and the\nnetwork code. If the url or the format of the JSON payload changes, it\nis likely to break all of your UI components in ways that are hard to\ntrack down.\n\nThe SOLID principles of good design tell us that objects should have a\nsingle responsibility. The responsibility of a component should be\npresenting model data to the user, not fetching the model.\n\nGood Ember apps take a different approach. Ember Data gives you a single\nstore that is the central repository of models in your application.\nComponents and routes can ask the store for models, and the store is\nresponsible for knowing how to fetch them.\n\nIt also means that the store can detect that two different components\nare asking for the same model, allowing your app to only fetch the data\nfrom the server once. You can think of the store as a read-through cache\nfor your app's models. Both your components and routes have access to\nthis shared store; when they need to display or modify a model, they\nfirst ask the store for it.\nConvention Over Configuration with JSON API\nYou can significantly reduce the amount of code you need to write and\nmaintain by relying on Ember's conventions. By adopting these\nconventions, you won't just write less code; your code will be much\neasier to maintain and be understood by other developers on your team.\n\nRather than create an arbitrary set of conventions, Ember Data is\ndesigned to work out of the box with JSON API. JSON API is a\nformal specification for building conventional, robust, and performant\nAPIs that allow clients and servers to communicate model data.\n\nJSON API standardizes how JavaScript applications talk to servers, so\nyou decrease the coupling between your frontend and backend, and have\nmore freedom to change pieces of your stack.\n\nAs an analogy, JSON API is to JavaScript apps and API servers what SQL is\nto server-side frameworks and databases. Popular frameworks like Ruby on\nRails, Laravel, Django, Spring and more work out of the box with many\ndifferent databases, like MySQL, PostgreSQL, SQL Server, and more.\n\nFrameworks (or apps built on those frameworks) don't need to write\nlots of custom code to add support for a new database; as long as that\ndatabase supports SQL, adding support for it is relatively easy.\n\nSo too with JSON API. By using JSON API to interop between your Ember\napp and your server, you can entirely change your backend stack without\nbreaking your frontend. And as you add apps for other platforms, such as\niOS and Android, you will be able to leverage JSON API libraries for\nthose platforms to easily consume the same API your Ember app uses.\nModels\nIn Ember Data, each model is represented by a subclass of Model that\ndefines the attributes, relationships, and behavior of the data that you\npresent to the user.\n\nModels define the type of data that will be provided by your server. For\nexample, a Person model might have a firstName attribute that is a\nstring, and a birthday attribute that is a date:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default DS.Model.extend({\n  firstName: DS.attr('string'),\n  birthday:  DS.attr('date')\n});\n\n\n\nA model also describes its relationships with other objects. For\nexample, an order may have many line-items, and a\nline-item may belong to a particular order.\n\n  \n    \n      app/models/order.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  lineItems: DS.hasMany('line-item')\n});\n\n\n\n  \n    \n      app/models/line-item.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  order: DS.belongsTo('order')\n});\n\n\n\nModels don't have any data themselves; they just define the attributes,\nrelationships and behavior of specific instances, which are called\nrecords.\nRecords\nA record is an instance of a model that contains data loaded from a\nserver. Your application can also create new records and save them back\nto the server.\n\nA record is uniquely identified by its model type and ID.\n\nFor example, if you were writing a contact management app, you might\nhave a Person model. An individual record in your app might\nhave a type of person and an ID of 1 or steve-buscemi.\n\n  1\n\n  this.store.findRecord('person', 1); // =\u003e { id: 1, name: 'steve-buscemi' }\n\n\n\nAn ID is usually assigned to a record by the server when you save it for\nthe first time, but you can also generate IDs client-side.\nAdapter\nAn adapter is an object that translates requests from Ember (such as\n\"find the user with an ID of 123\") into a requests to a server.\n\nFor example, if your application asks for a Person with an ID of\n123, how should Ember load it? Over HTTP or a WebSocket?  If\nit's HTTP, is the URL /person/1 or /resources/people/1?\n\nThe adapter is responsible for answering all of these questions.\nWhenever your app asks the store for a record that it doesn't have\ncached, it will ask the adapter for it. If you change a record and save\nit, the store will hand the record to the adapter to send the\nappropriate data to your server and confirm that the save was\nsuccessful.\n\nAdapters let you completely change how your API is implemented without\nimpacting your Ember application code.\nCaching\nThe store will automatically cache records for you. If a record had already\nbeen loaded, asking for it a second time will always return the same\nobject instance. This minimizes the number of round-trips to the\nserver, and allows your application to render its UI to the user as fast as\npossible.\n\nFor example, the first time your application asks the store for a\nperson record with an ID of 1, it will fetch that information from\nyour server.\n\nHowever, the next time your app asks for a person with ID 1, the\nstore will notice that it had already retrieved and cached that\ninformation from the server. Instead of sending another request for the\nsame information, it will give your application the same record it had\nprovided it the first time.  This featurealways returning the same\nrecord object, no matter how many times you look it upis sometimes\ncalled an identity map.\n\nUsing an identity map is important because it ensures that changes you\nmake in one part of your UI are propagated to other parts of the UI. It\nalso means that you don't have to manually keep records in syncyou can\nask for a record by ID and not have to worry about whether other parts\nof your application have already asked for and loaded it.\n\nOne downside to returning a cached record is you may find the state of\nthe data has changed since it was first loaded into the store's\nidentity map. In order to prevent this stale data from being a problem\nfor long, Ember Data will automatically make a request in the\nbackground each time a cached record is returned from the store. When\nthe new data comes in, the record is updated, and if there have been\nchanges to the record since the initial render, the template is\nre-rendered with the new information.\nArchitecture Overview\nThe first time your application asks the store for a record, the store\nsees that it doesn't have a local copy and requests it from your\nadapter. Your adapter will go and retrieve the record from your\npersistence layer; typically, this will be a JSON representation of the\nrecord served from an HTTP server.\n\n\n\nAs illustrated in the diagram above, the adapter cannot always return the\nrequested record immediately. In this case, the adapter must make an\nasynchronous request to the server, and only when that request finishes\nloading can the record be created with its backing data.\n\nBecause of this asynchronicity, the store immediately returns a\npromise from the find() method. Similarly, any requests that the\nstore makes to the adapter also return promises.\n\nOnce the request to the server returns with a JSON payload for the\nrequested record, the adapter resolves the promise it returned to the\nstore with the JSON.\n\nThe store then takes that JSON, initializes the record with the\nJSON data, and resolves the promise returned to your application\nwith the newly-loaded record.\n\n\n\nLet's look at what happens if you request a record that the store\nalready has in its cache.\n\n\n\nIn this case, because the store already knew about the record, it\nreturns a promise that it resolves with the record immediately. It does\nnot need to ask the adapter (and, therefore, the server) for a copy\nsince it already has it saved locally.\n\n\n\nModels, records, adapters and the store are the core concepts you\nshould understand to get the most out of Ember Data. The following\nsections go into more depth about each of these concepts, and how to\nuse them together.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0638f122b19f3ca7e20eca12d526a2e6","fields":[{"name":"title","value":"Pushing Records into the Store","type":"string"},{"name":"url","value":"/models/pushing-records-into-the-store/","type":"enum"},{"name":"body","value":"One way to think about the store is as a cache of all of the records\nthat have been loaded by your application. If a route or a controller in\nyour app asks for a record, the store can return it immediately if it is\nin the cache. Otherwise, the store must ask the adapter to load it,\nwhich usually means a trip over the network to retrieve it from the\nserver.\n\nInstead of waiting for the app to request a record, however, you can\npush records into the store's cache ahead of time.\n\nThis is useful if you have a good sense of what records the user\nwill need next. When they click on a link, instead of waiting for a\nnetwork request to finish, Ember.js can render the new template\nimmediately. It feels instantaneous.\n\nAnother use case for pushing in records is if your application has a\nstreaming connection to a backend. If a record is created or modified,\nyou want to update the UI immediately.\nPushing Records\nTo push a record into the store, call the store's push() method.\n\nFor example, imagine we want to preload some data into the store when\nthe application boots for the first time.\n\nWe can use the route:application to do so. The route:application is\nthe top-most route in the route hierarchy, and its model hook gets\ncalled once when the app starts up.\n\n  \n    \n      app/models/album.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.Model.extend({\n  title: DS.attr(),\n  artist: DS.attr(),\n  songCount: DS.attr()\n});\n\n\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n  export default Ember.Route.extend({\n  model() {\n    this.store.push({\n      data: [{\n        id: 1,\n        type: 'album',\n        attributes: {\n          title: 'Fewer Moving Parts',\n          artist: 'David Bazan',\n          songCount: 10\n        },\n        relationships: {}\n      }, {\n        id: 2,\n        type: 'album',\n        attributes: {\n          title: 'Calgary b/w I Can\\'t Make You Love Me/Nick Of Time',\n          artist: 'Bon Iver',\n          songCount: 2\n        },\n        relationships: {}\n      }]\n    });\n  }\n});\n\n\n\nThe store's push() method is a low level API which accepts a JSON\nAPI document with a few important differences from the JSON API\ndocument that the JSONAPISerializer accepts. The type name in the JSON\nAPI document must match the type name of the model exactly (In the\nexample above the type is album because the model is defined in\napp/models/album.js). Attributes and relationship names must match\nthe casing of the properties defined on the Model class.\n\nIf you would like to the data to be normalized by the serializer\nbefore pushing it into the store you can use the store.pushPayload\nmethod.\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n  export default Ember.Route.extend({\n  model() {\n    this.store.pushPayload({\n      data: [{\n        id: 1,\n        type: 'albums',\n        attributes: {\n          title: 'Fewer Moving Parts',\n          artist: 'David Bazan',\n          song-count: 10\n        },\n        relationships: {}\n      }, {\n        id: 2,\n        type: 'albums',\n        attributes: {\n          title: 'Calgary b/w I Can\\'t Make You Love Me/Nick Of Time',\n          artist: 'Bon Iver',\n          song-count: 2\n        },\n        relationships: {}\n      }]\n    });\n  }\n});\n\n\n\nThe push() method is also important when working with complex\nendpoints. You may find your application has an endpoint that performs\nsome business logic then creates several records. This likely does not\nmap cleanly to Ember Data's existing save() API which is structured\naround persisting a single record. Instead you should make your own\ncustom AJAX request and push the resulting model data into the store\nso it can be accessed by other parts of your application.\n\n  \n    \n      app/routes/confirm-payment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export default Ember.Route.extend({\n  actions: {\n    confirm: function(data) {\n      $.ajax({\n        data: data,\n        method: 'POST',\n        url: 'process-payment'\n      }).then((digitalInventory) =\u003e {\n        this.store.pushPayload(digitalInventory);\n        this.transitionTo('thank-you');\n      });\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d76e35a33acad2074b0c1ec27833b3bf","fields":[{"name":"title","value":"Working with Relationships","type":"string"},{"name":"url","value":"/models/working-with-relationships/","type":"enum"},{"name":"body","value":"Creating Records\nLet's assume that we have a post and a comment model, which are related to each other as follows:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  comments: DS.hasMany('comment')\n});\n\n\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  post: DS.belongsTo('post')\n});\n\n\n\nWhen a user comments on a post, we need to create a relationship between the two records. We can simply set the belongsTo relationship in our new comment:\n\n  1\n2\n3\n4\n5\n\n  let post = this.store.peekRecord('post', 1);\nlet comment = this.store.createRecord('comment', {\n  post: post\n});\ncomment.save();\n\n\n\nThis will create a new comment record and save it to the server. Ember Data will also update the post to include our newly created comment in its comments relationship.\n\nWe could have also linked the two records together by updating the post's hasMany relationship:\n\n  1\n2\n3\n4\n5\n\n  let post = this.store.peekRecord('post', 1);\nlet comment = this.store.createRecord('comment', {\n});\npost.get('comments').pushObject(comment);\ncomment.save();\n\n\n\nIn this case the new comment's belongsTo relationship will be set to the parent post.\nUpdating Existing Records\nSometimes we want to set relationships on already existing records. We can simply set a belongsTo relationship:\n\n  1\n2\n3\n4\n\n  let post = this.store.peekRecord('post', 1);\nlet comment = this.store.peekRecord('comment', 1);\ncomment.set('post', post);\ncomment.save();\n\n\n\nAlternatively, we could update the hasMany relationship by pushing a record into the relationship:\n\n  1\n2\n3\n4\n\n  let post = this.store.peekRecord('post', 1);\nlet comment = this.store.peekRecord('comment', 1);\npost.get('comments').pushObject(comment);\npost.save();\n\n\nRemoving Relationships\nTo remove a belongsTo relationship, we can just set it to null, which will also remove it from the hasMany side:\n\n  1\n2\n3\n\n  let comment = this.store.peekRecord('comment', 1);\ncomment.set('post', null);\ncomment.save();\n\n\n\nIt is also possible to remove a record from a hasMany relationship:\n\n  1\n2\n3\n4\n\n  let post = this.store.peekRecord('post', 1);\nlet comment = this.store.peekRecord('comment', 1);\npost.get('comments').removeObject(comment);\npost.save();\n\n\n\nAs in the earlier examples, the comment's belongsTo relationship will also be cleared by Ember Data.\nRelationships as Promises\nWhile working with relationships it is important to remember that they return promises.\n\nFor example, if we were to work on a post's asynchronous comments, we would have to wait until the promise has fulfilled:\n\n  1\n2\n3\n4\n5\n\n  let post = this.store.peekRecord('post', 1);\n\npost.get('comments').then((comments) =\u003e {\n  // now we can work with the comments\n});\n\n\n\nThe same applies to belongsTo relationships:\n\n  1\n2\n3\n4\n5\n\n  let comment = this.store.peekRecord('comment', 1);\n\ncomment.get('post').then((post) =\u003e {\n  // the post is available here\n});\n\n\n\nHandlebars templates will automatically be updated to reflect a resolved promise. We can display a list of comments in a post like so:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each post.comments as |comment|}}\n    \u003cli\u003e{{comment.id}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nEmber Data will query the server for the appropriate records and re-render the template once the data is received.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"7bdaf101518cf52ad2c7b8a7eb71a128","fields":[{"name":"title","value":"Bindings","type":"string"},{"name":"url","value":"/object-model/bindings/","type":"enum"},{"name":"body","value":"Unlike most other frameworks that include some sort of binding implementation,\nbindings in Ember.js can be used with any object. That said, bindings are most\noften used within the Ember framework itself, and for most problems Ember app\ndevelopers face, computed properties are the appropriate solution.\n\nThe easiest way to create a two-way binding is to use a computed alias, that\nspecifies the path to another object.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  wife = Ember.Object.create({\n  householdIncome: 80000\n});\n\nHusband = Ember.Object.extend({\n  householdIncome: Ember.computed.alias('wife.householdIncome')\n});\n\nhusband = Husband.create({\n  wife: wife\n});\n\nhusband.get('householdIncome'); // 80000\n\n// Someone gets raise.\nwife.set('householdIncome', 90000);\nhusband.get('householdIncome'); // 90000\n\n\n\nNote that bindings don't update immediately. Ember waits until all of your\napplication code has finished running before synchronizing changes, so you can\nchange a bound property as many times as you'd like without worrying about the\noverhead of syncing bindings when values are transient.\nOne-Way Bindings\nA one-way binding only propagates changes in one direction. Often, one-way\nbindings are just a performance optimization and you can safely use a two-way binding\n(as, of course, two-way bindings are de facto one-way bindings if you only ever change\none side). Sometimes one-way bindings are useful to achieve specific behaviour such\nas a default that is the same as another property but can be overridden (e.g. a\nshipping address that starts the same as a billing address but can later be changed)\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n  user = Ember.Object.create({\n  fullName: 'Kara Gates'\n});\n\nUserComponent = Ember.Component.extend({\n  userName: Ember.computed.oneWay('user.fullName')\n});\n\nuserComponent = UserComponent.create({\n  user: user\n});\n\n// Changing the name of the user object changes\n// the value on the view.\nuser.set('fullName', 'Krang Gates');\n// userComponent.userName will become \"Krang Gates\"\n\n// ...but changes to the view don't make it back to\n// the object.\nuserComponent.set('userName', 'Truckasaurus Gates');\nuser.get('fullName'); // \"Krang Gates\"\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4eb2fcd4e32d72e009d1c1d9fdceee41","fields":[{"name":"title","value":"Classes and Instances","type":"string"},{"name":"url","value":"/object-model/classes-and-instances/","type":"enum"},{"name":"body","value":"As you learn about Ember, you'll see code like Ember.Component.extend() and\nDS.Model.extend(). Here, you'll learn about this extend() method, as well\nas other major features of the Ember object model.\nDefining Classes\nTo define a new Ember class, call the extend() method on\nEmber.Object:\n\n  1\n2\n3\n4\n5\n\n  Person = Ember.Object.extend({\n  say(thing) {\n    alert(thing);\n  }\n});\n\n\n\nThis defines a new Person class with a say() method.\n\nYou can also create a subclass from any existing class by calling\nits extend() method. For example, you might want to create a subclass\nof Ember's built-in Ember.Component class:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isUrgent'],\n  isUrgent: true\n});\n\n\n\nWhen defining a subclass, you can override methods but still access the\nimplementation of your parent class by calling the special _super()\nmethod:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  Person = Ember.Object.extend({\n  say(thing) {\n    var name = this.get('name');\n    alert(`${name} says: ${thing}`);\n  }\n});\n\nSoldier = Person.extend({\n  say(thing) {\n    // this will call the method in the parent class (Person#say), appending\n    // the string ', sir!' to the variable `thing` passed in\n    this._super(thing + ', sir!');\n  }\n});\n\nvar yehuda = Soldier.create({\n  name: 'Yehuda Katz'\n});\n\nyehuda.say('Yes'); // alerts \"Yehuda Katz says: Yes, sir!\"\n\n\nCreating Instances\nOnce you have defined a class, you can create new instances of that\nclass by calling its create() method. Any methods, properties and\ncomputed properties you defined on the class will be available to\ninstances:\n\n  1\n2\n\n  var person = Person.create();\nperson.say('Hello'); // alerts \" says: Hello\"\n\n\n\nWhen creating an instance, you can initialize the values of its properties\nby passing an optional hash to the create() method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  Person = Ember.Object.extend({\n  helloWorld() {\n    alert('Hi, my name is ' + this.get('name'));\n  }\n});\n\nvar tom = Person.create({\n  name: 'Tom Dale'\n});\n\ntom.helloWorld(); // alerts \"Hi, my name is Tom Dale\"\n\n\n\nFor performance reasons, note that you cannot redefine an instance's\ncomputed properties or methods when calling create(), nor can you\ndefine new ones. You should only set simple properties when calling\ncreate(). If you need to define or redefine methods or computed\nproperties, create a new subclass and instantiate that.\n\nBy convention, properties or variables that hold classes are\nPascalCased, while instances are not. So, for example, the variable\nPerson would point to a class, while person would point to an instance\n(usually of the Person class). You should stick to these naming\nconventions in your Ember applications.\nInitializing Instances\nWhen a new instance is created, its init method is invoked\nautomatically. This is the ideal place to implement setup required on new\ninstances:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  Person = Ember.Object.extend({\n  init() {\n    var name = this.get('name');\n    alert(name + ', reporting for duty!');\n  }\n});\n\nPerson.create({\n  name: 'Stefan Penner'\n});\n\n// alerts \"Stefan Penner, reporting for duty!\"\n\n\n\nIf you are subclassing a framework class, like Ember.Component, and you\noverride the init method, make sure you call this._super(...arguments)! If you don't,\na parent class may not have an opportunity to do important setup work, and you'll\nsee strange behavior in your application.\nAccessing Object Properties\nWhen accessing the properties of an object, use the get\nand set accessor methods:\n\n  1\n2\n3\n4\n\n  var person = Person.create();\n\nvar name = person.get('name');\nperson.set('name', 'Tobias Fnke');\n\n\n\nMake sure to use these accessor methods; otherwise, computed properties won't\nrecalculate, observers won't fire, and templates won't update.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e959824557e508bda4cb824e0466f1ac","fields":[{"name":"title","value":"Computed Properties and Aggregate Data","type":"string"},{"name":"url","value":"/object-model/computed-properties-and-aggregate-data/","type":"enum"},{"name":"body","value":"Sometimes you have a computed property whose value depends on the properties of \nitems in an array. For example, you may have an array of todo items, and want\nto calculate how many remain incomplete based on their isDone property.\n\nTo facilitate this, Ember provides the @each key illustrated below:\n\n  \n    \n      app/components/todos.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Component.extend({\n  todos: [\n    Ember.Object.create({ isDone: true }),\n    Ember.Object.create({ isDone: false }),\n    Ember.Object.create({ isDone: true })\n  ],\n\n  remaining: Ember.computed('todos.@each.isDone', function() {\n    var todos = this.get('todos');\n    return todos.filterBy('isDone', false).get('length');\n  })\n});\n\n\n\nHere, the dependent key todos.@each.isDone instructs Ember.js to update bindings \nand fire observers when any of the following events occurs: \n\n\nThe isDone property of any of the objects in the todos array changes.\nAn item is added to the todos array.\nAn item is removed from the todos array.\nThe todos property of the component is changed to a different array.\n\n\nIn the example above, the remaining count is 1:\n\n  1\n2\n3\n4\n5\n\n  import TodosComponent from 'app/components/todos';\n\nlet todosComponent = TodosComponent.create();\ntodosComponent.get('remaining');\n// 1\n\n\n\nIf we change the todo's isDone property, the remaining property is updated\nautomatically:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  let todos = todosComponent.get('todos');\nlet todo = todos.objectAt(1);\ntodo.set('isDone', true);\n\ntodosComponent.get('remaining');\n// 0\n\ntodo = Ember.Object.create({ isDone: false });\ntodos.pushObject(todo);\n\ntodosComponent.get('remaining');\n// 1\n\n\n\nNote that @each only works one level deep. You cannot use nested forms like\ntodos.@each.owner.name or todos.@each.owner.@each.name.\n\nSometimes you don't care if properties of individual array items change. In this\ncase use the [] key instead of @each. Computed properties dependent on an array\nusing the [] key will only update if items are added to or removed from the array,\nor if the array property is set to a different array. For example:\n\n  \n    \n      app/components/todos.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Component.extend({\n  todos: [\n    Ember.Object.create({ isDone: true }),\n    Ember.Object.create({ isDone: false }),\n    Ember.Object.create({ isDone: true })\n  ],\n\n  selectedTodo: null,\n  indexOfSelectedTodo: Ember.computed('selectedTodo', 'todos.[]', function() {\n    return this.get('todos').indexOf(this.get('selectedTodo'));\n  })\n});\n\n\n\nHere, indexOfSelectedTodo depends on todos.[], so it will update if we add an item\nto todos, but won't update if the value of isDone on a todo changes.\n\nSeveral of the Ember.computed macros \nutilize the [] key to implement common use-cases. For instance, to\ncreate a computed property that mapped properties from an array, you could use \nEmber.computed.map\nor build the computed property yourself:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  const Hamster = Ember.Object.extend({\n  excitingChores: Ember.computed('chores.[]', function() {\n    return this.get('chores').map(function(chore, index) {\n      return `CHORE ${index}: ${chore.toUpperCase()}!`;\n    });\n  })\n});\n\nconst hamster = Hamster.create({\n  chores: ['clean', 'write more unit tests']\n});\n\nhamster.get('excitingChores'); // ['CHORE 1: CLEAN!', 'CHORE 2: WRITE MORE UNIT TESTS!']\nhamster.get('chores').pushObject('review code');\nhamster.get('excitingChores'); // ['CHORE 1: CLEAN!', 'CHORE 2: WRITE MORE UNIT TESTS!', 'CHORE 3: REVIEW CODE!']\n\n\n\nBy comparison, using the computed macro abstracts some of this away:\n\n  1\n2\n3\n4\n5\n\n  const Hamster = Ember.Object.extend({\n  excitingChores: Ember.computed.map('chores', function(chore, index) {\n    return `CHORE ${index}: ${chore.toUpperCase()}!`;\n  })\n});\n\n\n\nThe computed macros expect you to use an array, so there is no need to use the\n[] key in these cases. However, building your own custom computed property\nrequires you to tell Ember.js that it is watching for array changes, which is\nwhere the [] key comes in handy.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a26ec310640ced8b722a53a9ac4a703a","fields":[{"name":"title","value":"Computed Properties","type":"string"},{"name":"url","value":"/object-model/computed-properties/","type":"enum"},{"name":"body","value":"What are Computed Properties?\nIn a nutshell, computed properties let you declare functions as properties. You create one by defining a computed property as a function, which Ember will automatically call when you ask for the property. You can then use it the same way you would any normal, static property.\n\nIt's super handy for taking one or more normal properties and transforming or manipulating their data to create a new value.\nComputed properties in action\nWe'll start with a simple example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  Person = Ember.Object.extend({\n  // these will be supplied by `create`\n  firstName: null,\n  lastName: null,\n\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return `${this.get('firstName')} ${this.get('lastName')}`;\n  })\n});\n\nvar ironMan = Person.create({\n  firstName: 'Tony',\n  lastName:  'Stark'\n});\n\nironMan.get('fullName'); // \"Tony Stark\"\n\n\n\nThis declares the function to be a computed property, and the arguments tell Ember that it depends on the firstName and lastName attributes.\n\nWhenever you access the fullName property, this function gets called, and it returns the value of the function, which simply calls firstName + lastName.\nChaining computed properties\nYou can use computed properties as values to create new computed properties. Let's add a description computed property to the previous example, and use the existing fullName property and add in some other properties:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  Person = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n  age: null,\n  country: null,\n\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return `${this.get('firstName')} ${this.get('lastName')}`;\n  }),\n\n  description: Ember.computed('fullName', 'age', 'country', function() {\n    return `${this.get('fullName')}; Age: ${this.get('age')}; Country: ${this.get('country')}`;\n  })\n});\n\nvar captainAmerica = Person.create({\n  firstName: 'Steve',\n  lastName: 'Rogers',\n  age: 80,\n  country: 'USA'\n});\n\ncaptainAmerica.get('description'); // \"Steve Rogers; Age: 80; Country: USA\"\n\n\nDynamic updating\nComputed properties, by default, observe any changes made to the properties they depend on and are dynamically updated when they're called. Let's use computed properties to dynamically update.\n\n  1\n2\n3\n\n  captainAmerica.set('firstName', 'William');\n\ncaptainAmerica.get('description'); // \"William Rogers; Age: 80; Country: USA\"\n\n\n\nSo this change to firstName was observed by fullName computed property, which was itself observed by the description property.\n\nSetting any dependent property will propagate changes through any computed properties that depend on them, all the way down the chain of computed properties you've created.\nSetting Computed Properties\nYou can also define what Ember should do when setting a computed property. If you try to set a computed property, it will be invoked with the key (property name), and the value you want to set it to.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n  Person = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n\n  fullName: Ember.computed('firstName', 'lastName', {\n    get(key) {\n      return `${this.get('firstName')} ${this.get('lastName')}`;\n    },\n    set(key, value) {\n      var [firstName, lastName] = value.split(/\\s+/);\n      this.set('firstName', firstName);\n      this.set('lastName',  lastName);\n      return value;\n    }\n  })\n});\n\n\nvar captainAmerica = Person.create();\ncaptainAmerica.set('fullName', 'William Burnside');\ncaptainAmerica.get('firstName'); // William\ncaptainAmerica.get('lastName'); // Burnside\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"27baf1b906842ce32a37f5fd551f1e91","fields":[{"name":"title","value":"Enumerables","type":"string"},{"name":"url","value":"/object-model/enumerables/","type":"enum"},{"name":"body","value":"In Ember.js, an enumerable is any object that contains a number of child\nobjects, and which allows you to work with those children using the\nEmber.Enumerable API. The most common\nenumerable in the majority of apps is the native JavaScript array, which\nEmber.js extends to conform to the enumerable interface.\n\nBy providing a standardized interface for dealing with enumerables,\nEmber.js allows you to completely change the way your underlying data is\nstored without having to modify the other parts of your application that\naccess it.\n\nThe enumerable API follows ECMAScript specifications as much as\npossible. This minimizes incompatibility with other libraries, and\nallows Ember.js to use the native browser implementations in arrays\nwhere available.\nUse of Observable Methods and Properties\nIn order for Ember to observe when you make a change to an enumerable, you need\nto use special methods that Ember.Enumerable provides. For example, if you add\nan element to an array using the standard JavaScript method push, Ember will\nnot be able to observe the change, but if you use the enumerable method\npushObject, the change will propagate throughout your application.\n\nHere is a list of standard JavaScript array methods and their observable\nenumerable equivalents:\n\n\n  \n    Standard MethodObservable Equivalent\n  \n  \n    poppopObject\n    pushpushObject\n    reversereverseObjects\n    shiftshiftObject\n    unshiftunshiftObject\n  \n\n\nAdditionally, to retrieve the first and last objects in an array\nin an observable fashion, you should use myArray.get('firstObject') and\nmyArray.get('lastObject'), respectively.\nAPI Overview\nIn the rest of this guide, we'll explore some of the most common enumerable\nconveniences. For the full list, please see the Ember.Enumerable API\nreference documentation.\nIterating Over an Enumerable\nTo enumerate all the values of an enumerable object, use the forEach method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var food = ['Poi', 'Ono', 'Adobo Chicken'];\n\nfood.forEach(function(item, index) {\n  console.log(`Menu Item ${index+1}: ${item}`);\n});\n\n// Menu Item 1: Poi\n// Menu Item 2: Ono\n// Menu Item 3: Adobo Chicken\n\n\nFirst and Last Objects\nAll enumerables expose firstObject and lastObject properties\nthat you can bind to.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var animals = ['rooster', 'pig'];\n\nanimals.get('lastObject');\n//=\u003e \"pig\"\n\nanimals.pushObject('peacock');\n\nanimals.get('lastObject');\n//=\u003e \"peacock\"\n\n\nMap\nYou can easily transform each item in an enumerable using the\nmap() method, which creates a new array with results of calling a\nfunction on each item in the enumerable.\n\n  1\n2\n3\n4\n5\n6\n\n  var words = ['goodbye', 'cruel', 'world'];\n\nvar emphaticWords = words.map(function(item) {\n  return item + '!';\n});\n// [\"goodbye!\", \"cruel!\", \"world!\"]\n\n\n\nIf your enumerable is composed of objects, there is a mapBy()\nmethod that will extract the named property from each of those objects\nin turn and return a new array:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  var hawaii = Ember.Object.create({\n  capital: 'Honolulu'\n});\n\nvar california = Ember.Object.create({\n  capital: 'Sacramento'\n});\n\nvar states = [hawaii, california];\n\nstates.mapBy('capital');\n//=\u003e [\"Honolulu\", \"Sacramento\"]\n\n\nFiltering\nAnother common task to perform on an enumerable is to take the\nenumerable as input, and return an Array after filtering it based on\nsome criteria.\n\nFor arbitrary filtering, use the filter method.  The filter method\nexpects the callback to return true if Ember should include it in the\nfinal Array, and false or undefined if Ember should not.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var arr = [1,2,3,4,5];\n\narr.filter(function(item, index, self) {\n  return item \u003c 4;\n})\n\n// returns [1,2,3]\n\n\n\nWhen working with a collection of Ember objects, you will often want to filter a set of objects based upon the value of some property. The filterBy method provides a shortcut.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  Todo = Ember.Object.extend({\n  title: null,\n  isDone: false\n});\n\ntodos = [\n  Todo.create({ title: 'Write code', isDone: true }),\n  Todo.create({ title: 'Go to sleep' })\n];\n\ntodos.filterBy('isDone', true);\n\n// returns an Array containing only items with `isDone == true`\n\n\n\nIf you want to return just the first matched value, rather than an Array containing all of the matched values, you can use find and findBy, which work just like filter and filterBy, but return only one item.\nAggregate Information (Every or Any)\nTo find out whether every item in an enumerable matches some condition, you can use the every method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  Person = Ember.Object.extend({\n  name: null,\n  isHappy: false\n});\n\nvar people = [\n  Person.create({ name: 'Yehuda', isHappy: true }),\n  Person.create({ name: 'Majd', isHappy: false })\n];\n\npeople.every(function(person, index, self) {\n  return person.get('isHappy');\n});\n\n// returns false\n\n\n\nTo find out whether at least one item in an enumerable matches some condition, you can use the any method:\n\n  1\n2\n3\n4\n5\n\n  people.any(function(person, index, self) {\n  return person.get('isHappy');\n});\n\n// returns true\n\n\n\nJust like the filtering methods, the every and any methods have analogous isEvery and isAny methods.\n\n  1\n2\n\n  people.isEvery('isHappy', true) // false\npeople.isAny('isHappy', true)  // true\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"37d5aab7c9ab79a19b719afbe3ad536b","fields":[{"name":"title","value":"Objects in Ember","type":"string"},{"name":"url","value":"/object-model/","type":"enum"},{"name":"body","value":"You'll notice standard JavaScript class patterns and the new ES2015\nclasses aren't widely used in Ember. Plain objects can still be found,\nand sometimes they're referred to as \"hashes\".\n\nJavaScript objects don't support the observation of property value changes.\nConsequently, if an object is going to participate in Ember's binding\nsystem you may see an Ember.Object instead of a plain object.\n\nEmber.Object also provides a class system, supporting features like mixins\nand constructor methods. Some features in Ember's object model are not present in\nJavaScript classes or common patterns, but all are aligned as much as possible\nwith the language and proposed additions.\n\nEmber also extends the JavaScript Array prototype with its\nEmber.Enumerable interface to provide change observation for arrays.\n\nFinally, Ember extends the String prototype with a few formatting and\nlocalization methods.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2899adf50b491f36747129255557b93d","fields":[{"name":"title","value":"Observers","type":"string"},{"name":"url","value":"/object-model/observers/","type":"enum"},{"name":"body","value":"Ember supports observing any property, including computed properties.\n\nObservers should contain behavior that reacts to changes in another property.\nObservers are especially useful when you need to perform some behavior after a\nbinding has finished synchronizing.\n\nObservers are often over-used by new Ember developers. Observers are used\nheavily within the Ember framework itself, but for most problems Ember app\ndevelopers face, computed properties are the appropriate solution.\n\nYou can set up an observer on an object by using Ember.observer:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  Person = Ember.Object.extend({\n  // these will be supplied by `create`\n  firstName: null,\n  lastName: null,\n\n  fullName: Ember.computed('firstName', 'lastName', function() {\n    return `${this.get('firstName')} ${this.get('lastName')}`;\n  }),\n\n  fullNameChanged: Ember.observer('fullName', function() {\n    // deal with the change\n  })\n});\n\nvar person = Person.create({\n  firstName: 'Yehuda',\n  lastName: 'Katz'\n});\n\nperson.set('firstName', 'Brohuda'); // observer will fire\n\n\n\nBecause the fullName computed property depends on firstName,\nupdating firstName will fire observers on fullName as well.\nObservers and asynchrony\nObservers in Ember are currently synchronous. This means that they will fire\nas soon as one of the properties they observe changes. Because of this, it\nis easy to introduce bugs where properties are not yet synchronized:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Person.reopen({\n  lastNameChanged: Ember.observer('lastName', function() {\n    // The observer depends on lastName and so does fullName. Because observers\n    // are synchronous, when this function is called the value of fullName is\n    // not updated yet so this will log the old value of fullName\n    console.log(this.get('fullName'));\n  })\n});\n\n\n\nThis synchronous behavior can also lead to observers being fired multiple\ntimes when observing multiple properties:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Person.reopen({\n  partOfNameChanged: Ember.observer('firstName', 'lastName', function() {\n    // Because both firstName and lastName were set, this observer will fire twice.\n  })\n});\n\nperson.set('firstName', 'John');\nperson.set('lastName', 'Smith');\n\n\n\nTo get around these problems, you should make use of Ember.run.once. This will\nensure that any processing you need to do only happens once, and happens in the\nnext run loop once all bindings are synchronized:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  Person.reopen({\n  partOfNameChanged: Ember.observer('firstName', 'lastName', function() {\n    Ember.run.once(this, 'processFullName');\n  }),\n\n  processFullName: Ember.observer('fullName', function() {\n    // This will only fire once if you set two properties at the same time, and\n    // will also happen in the next run loop once all properties are synchronized\n    console.log(this.get('fullName'));\n  })\n});\n\nperson.set('firstName', 'John');\nperson.set('lastName', 'Smith');\n\n\nObservers and object initialization\nObservers never fire until after the initialization of an object is complete.\n\nIf you need an observer to fire as part of the initialization process, you\ncannot rely on the side effect of set. Instead, specify that the observer\nshould also run after init by using Ember.on():\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Person = Ember.Object.extend({\n  init() {\n    this.set('salutation', 'Mr/Ms');\n  },\n\n  salutationDidChange: Ember.on('init', Ember.observer('salutation', function() {\n    // some side effect of salutation changing\n  }))\n});\n\n\nUnconsumed Computed Properties Do Not Trigger Observers\nIf you never get a computed property, its observers will not fire even if\nits dependent keys change. You can think of the value changing from one unknown\nvalue to another.\n\nThis doesn't usually affect application code because computed properties are\nalmost always observed at the same time as they are fetched. For example, you get\nthe value of a computed property, put it in DOM (or draw it with D3), and then\nobserve it so you can update the DOM once the property changes.\n\nIf you need to observe a computed property but aren't currently retrieving it,\njust get it in your init method.\nOutside of class definitions\nYou can also add observers to an object outside of a class definition\nusing addObserver:\n\n  1\n2\n3\n\n  person.addObserver('fullName', function() {\n  // deal with the change\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f8ecff8837ebc62045275db96d37ff19","fields":[{"name":"title","value":"Reopening Classes and Instances","type":"string"},{"name":"url","value":"/object-model/reopening-classes-and-instances/","type":"enum"},{"name":"body","value":"You don't need to define a class all at once. You can reopen a class and\ndefine new properties using the reopen method.\n\n  1\n2\n3\n4\n5\n\n  Person.reopen({\n  isPerson: true\n});\n\nPerson.create().get('isPerson') // true\n\n\n\nWhen using reopen, you can also override existing methods and\ncall this._super.\n\n  1\n2\n3\n4\n5\n6\n\n  Person.reopen({\n  // override `say` to add an ! at the end\n  say(thing) {\n    this._super(thing + '!');\n  }\n});\n\n\n\nreopen is used to add instance methods and properties that are shared across all instances of a class. It does not add\nmethods and properties to a particular instance of a class as in vanilla JavaScript (without using prototype).\n\nBut when you need to add static methods or static properties to the class itself you can use reopenClass.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  // add static property to class\nPerson.reopenClass({\n  isPerson: false\n});\n// override property of Person instance\nPerson.reopen({\n  isPerson: true\n});\n\nPerson.isPerson; // false - because it is static property created by `reopenClass`\nPerson.create().get('isPerson'); // true\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2e1967ab300f10bb0db8e074948cdccf","fields":[{"name":"title","value":"Asynchronous Routing","type":"string"},{"name":"url","value":"/routing/asynchronous-routing/","type":"enum"},{"name":"body","value":"This section covers some more advanced features of the router and its\ncapability for handling complex async logic within your app.\nA Word on Promises...\nEmber's approach to handling asynchronous logic in the router makes\nheavy use of the concept of Promises. In short, promises are objects that\nrepresent an eventual value. A promise can either fulfill\n(successfully resolve the value) or reject (fail to resolve the\nvalue). The way to retrieve this eventual value, or handle the cases\nwhen the promise rejects, is via the promise's then method, which\naccepts two optional callbacks, one for fulfillment and one for\nrejection. If the promise fulfills, the fulfillment handler gets called\nwith the fulfilled value as its sole argument, and if the promise rejects,\nthe rejection handler gets called with a reason for the rejection as its\nsole argument. For example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  var promise = fetchTheAnswer();\n\npromise.then(fulfill, reject);\n\nfunction fulfill(answer) {\n  console.log('The answer is ' + answer);\n}\n\nfunction reject(reason) {\n  console.log(`Couldn't get the answer! Reason: ${reason}`);\n}\n\n\n\nMuch of the power of promises comes from the fact that they can be\nchained together to perform sequential asynchronous operations:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  // Note: jQuery AJAX methods return promises\nvar usernamesPromise = Ember.$.getJSON('/usernames.json');\n\nusernamesPromise.then(fetchPhotosOfUsers)\n                .then(applyInstagramFilters)\n                .then(uploadTrendyPhotoAlbum)\n                .then(displaySuccessMessage, handleErrors);\n\n\n\nIn the above example, if any of the methods\nfetchPhotosOfUsers, applyInstagramFilters, or\nuploadTrendyPhotoAlbum returns a promise that rejects,\nhandleErrors will be called with\nthe reason for the failure. In this manner, promises approximate an\nasynchronous form of try-catch statements that prevent the rightward\nflow of nested callback after nested callback and facilitate a saner\napproach to managing complex asynchronous logic in your applications.\n\nThis guide doesn't intend to fully delve into all the different ways\npromises can be used, but if you'd like a more thorough introduction,\ntake a look at the readme for RSVP,\nthe promise library that Ember uses.\nThe Router Pauses for Promises\nWhen transitioning between routes, the Ember router collects all of the\nmodels (via the model hook) that will be passed to the route's\ncontrollers at the end of the transition. If the model hook (or the related\nbeforeModel or afterModel hooks) return normal (non-promise) objects or\narrays, the transition will complete immediately. But if the model hook\n(or the related beforeModel or afterModel hooks) returns a promise (or\nif a promise was provided as an argument to transitionTo), the transition\nwill pause until that promise fulfills or rejects.\n\nThe router considers any object with a then method\ndefined on it to be a promise.\n\nIf the promise fulfills, the transition will pick up where it left off and\nbegin resolving the next (child) route's model, pausing if it too is a\npromise, and so on, until all destination route models have been\nresolved. The values passed to the setupController hook for each route\nwill be the fulfilled values from the promises.\n\nA basic example:\n\n  \n    \n      app/routes/tardy.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.Route.extend({\n  model() {\n    return new Ember.RSVP.Promise(function(resolve) {\n      Ember.run.later(function() {\n        resolve({ msg: 'Hold Your Horses' });\n      }, 3000);\n    });\n  },\n\n  setupController(controller, model) {\n    console.log(model.msg); // \"Hold Your Horses\"\n  }\n});\n\n\n\nWhen transitioning into route:tardy, the model hook will be called and\nreturn a promise that won't resolve until 3 seconds later, during which time\nthe router will be paused in mid-transition. When the promise eventually\nfulfills, the router will continue transitioning and eventually call\nroute:tardy's setupController hook with the resolved object.\n\nThis pause-on-promise behavior is extremely valuable for when you need\nto guarantee that a route's data has fully loaded before displaying a\nnew template.\nWhen Promises Reject...\nWe've covered the case when a model promise fulfills, but what if it rejects?\n\nBy default, if a model promise rejects during a transition, the transition is\naborted, no new destination route templates are rendered, and an error\nis logged to the console.\n\nYou can configure this error-handling logic via the error handler on\nthe route's actions hash. When a promise rejects, an error event\nwill be fired on that route and bubble up to route:application's\ndefault error handler unless it is handled by a custom error handler\nalong the way, e.g.:\n\n  \n    \n      app/routes/good-for-nothing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  export default Ember.Route.extend({\n  model() {\n    return Ember.RSVP.reject(\"FAIL\");\n  },\n\n  actions: {\n    error(reason) {\n      alert(reason); // \"FAIL\"\n\n      // Can transition to another route here, e.g.\n      // this.transitionTo('index');\n\n      // Uncomment the line below to bubble this error event:\n      // return true;\n    }\n  }\n});\n\n\n\nIn the above example, the error event would stop right at\nroute:good-for-nothing's error handler and not continue to bubble. To\nmake the event continue bubbling up to route:application, you can\nreturn true from the error handler.\nRecovering from Rejection\nRejected model promises halt transitions, but because promises are chainable,\nyou can catch promise rejects within the model hook itself and convert\nthem into fulfills that won't halt the transition.\n\n  \n    \n      app/routes/funky.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Route.extend({\n  model() {\n    return iHopeThisWorks().then(null, function() {\n      // Promise rejected, fulfill with some default value to\n      // use as the route's model and continue on with the transition\n      return { msg: 'Recovered from rejected promise' };\n    });\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"bc0bfb567fedd41ba7b17f66df025608","fields":[{"name":"title","value":"Defining Your Routes","type":"string"},{"name":"url","value":"/routing/defining-your-routes/","type":"enum"},{"name":"body","value":"When your application starts, the router matches the current URL to the routes\nthat you've defined. The routes, in turn, are responsible for displaying\ntemplates, loading data, and otherwise setting up application state.\nBasic Routes\nThe map method\nof your Ember application's router can be invoked to define URL mappings. When\ncalling map, you should pass a function that will be invoked with the value\nthis set to an object which you can use to create routes.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('about', { path: '/about' });\n  this.route('favorites', { path: '/favs' });\n});\n\n\n\nNow, when the user visits /about, Ember.js will render the about\ntemplate. Visiting /favs will render the favorites template.\n\nYou can leave off the path if it is the same as the route\nname. In this case, the following is equivalent to the above example:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('about');\n  this.route('favorites', { path: '/favs' });\n});\n\n\n\nInside your templates, you can use {{link-to}} to navigate between\nroutes, using the name that you provided to the route method.\n\n  1\n2\n3\n4\n5\n6\n\n  {{#link-to \"index\"}}\u003cimg class=\"logo\"\u003e{{/link-to}}\n\n\u003cnav\u003e\n  {{#link-to \"about\"}}About{{/link-to}}\n  {{#link-to \"favorites\"}}Favorites{{/link-to}}\n\u003c/nav\u003e\n\n\n\nThe {{link-to}} helper will also add an active class to the link that\npoints to the currently active route.\nNested Routes\nOften you'll want to have a template that displays inside another template.\nFor example, in a blogging application, instead of going from a list of blog\nposts to creating a new post, you might want to have the post creation page\ndisplay next to the list.\n\nIn these cases, you can use nested routes to display one template inside\nof another.\n\nYou can define nested routes by passing a callback to this.route:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', function() {\n    this.route('new');\n  });\n});\n\n\n\nAnd then add the {{outlet}} helper to your template where you want the nested\ntemplate to display:\n\n  \n    \n      templates/posts.hbs\n    \n  \n\n  1\n2\n3\n\n  \u003ch1\u003ePosts\u003c/h1\u003e\n\u003c!-- Display posts and other content --\u003e\n{{outlet}}\n\n\n\nThis router creates a route for /posts and for /posts/new. When a user\nvisits /posts, they'll simply see the posts.hbs template. (Below, index\nroutes explains an important addition to this.) When the\nuser visits posts/new, they'll see the posts/new.hbs template rendered into\nthe {{outlet}} of the posts template.\n\nA nested route's names includes the names of its ancestors.\nIf you want to transition to a route (either\nvia transitionTo or {{#link-to}}), make sure to use the full route\nname (posts.new, not new).\nThe application route\nThe application is entered when your app first boots up. Just like any\nother route, it will load an application template by default.\nYou should put your header, footer, and any other decorative content\nhere. All other routes will render\ntheir templates into the application.hbs templates's {{outlet}}.\n\nThis route is part of every application, so you don't need to\nspecify it in your app/router.js.\nIndex Routes\nAt every level of nesting (including the top level), Ember.js\nautomatically provides a route for the / path named index.\n\nFor example, if you write a simple router like this:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function(){\n  this.route('favorites');\n});\n\n\n\nIt is the equivalent of:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function(){\n  this.route('index', { path: '/' });\n  this.route('favorites');\n});\n\n\n\nThe index template will be rendered into the {{outlet}} in the\napplication template. If the user navigates to /favorites,\nEmber.js will replace the index template with the favorites\ntemplate.\n\nA nested router like this:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', function() {\n    this.route('favorites');\n  });\n});\n\n\n\nIs the equivalent of:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  Router.map(function(){\n  this.route('index', { path: '/' });\n  this.route('posts', function() {\n    this.route('index', { path: '/' });\n    this.route('favorites');\n  });\n});\n\n\n\nIf the user navigates to /posts, the current route will be\nposts.index, and the posts/index template\nwill be rendered into the {{outlet}} in the posts template.\n\nIf the user then navigates to /posts/favorites, Ember.js will\nreplace the {{outlet}} in the posts template with the\nposts/favorites template.\nDynamic Segments\nOne of the responsibilities of a route is to load a model.\n\nFor example, if we have the route this.route('posts');, our\nroute might load all of the blog posts for the app.\n\nBecause /posts represents a fixed model, we don't need any\nadditional information to know what to retrieve.  However, if we want a route\nto represent a single post, we would not want to have to hardcode every\npossible post into the router.\n\nEnter dynamic segments.\n\nA dynamic segment is a portion of a URL that starts with a : and is\nfollowed by an identifier.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('posts');\n  this.route('post', { path: '/post/:post_id' });\n});\n\n\n\nIf the user navigates to /post/5, the route will then have the post_id of\n5 to use to load the correct post. See Specifying a Route's\nModel for\nmore about how to load a model.\nWildcard / globbing routes\nYou can define wildcard routes that will match multiple URL segments. This could be used, for example,\nif you'd like a catch-all route which is useful when the user enters an incorrect URL not managed\nby your app.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('page-not-found', { path: '/*wildcard' });\n});\n\n\nResetting Nested Route Namespace\nWhen nesting routes, it may be beneficial for a child route to not inherit its ancestors name. This allows you to reference and reuse a given route in multiple route trees as well as keep the class name short.\n\nYou can reset the current \"namespace\" with the aptly named resetNamespace: true option.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Router.map(function() {\n  this.route('post', { path: '/post/:post_id' }, function() {\n    this.route('edit');\n    this.route('comments', { resetNamespace: true }, function() {\n      this.route('new');\n    });\n  });\n});\n\n\n\nJust like before, the comments template will be rendered in the post\ntemplate's {{outlet}}, and all templates under comments (comments/index\nand comments/new) will be rendered in the comments outlet.\n\nHowever, the /post/:id/comments path will load the comments.hbs template,\nrather than the post/comments.hbs template.\nRoute Handlers\nTo have your route do something beyond render a template with the same name, you'll\nneed to create a route handler. The following guides will explore the different\nfeatures of route handlers. For more information on routes, see the API documentation\nfor the router and for route\nhandlers.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e220634be1096dfda0635ee4cccf6449","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/routing/","type":"enum"},{"name":"body","value":"Imagine we are writing a web app for managing a blog. At any given time, we\nshould be able to answer questions like What post are they looking at? and\nAre they editing it? In Ember.js, the answer to these questions is determined\nby the URL.\n\nThe URL can be set in a few ways:\n\n\nThe user loads the app for the first time.\nThe user changes the URL manually, such as by clicking the back button or by\nediting the address bar.\nThe user clicks a link within the app.\nSome other event in the app causes the URL to change.\n\n\nRegardless of how the URL becomes set, the Ember router then maps the current\nURL to one or more route handlers. A route handler can do several things:\n\n\nIt can render a template.\nIt can load a model that is then available to the template.\nIt can redirect to a new route, such as if the user isn't allowed to visit\nthat part of the app.\nIt can handle actions that involve changing a model or transitioning to a new\nroute.\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b73d2dfe086aa008696fa624bef07e0e","fields":[{"name":"title","value":"Loading / Error Substates","type":"string"},{"name":"url","value":"/routing/loading-and-error-substates/","type":"enum"},{"name":"body","value":"The Ember Router allows you to provide feedback that a route is loading, as well\nas when an error occurs in loading a route.\nloading substates\nDuring the beforeModel, model, and afterModel hooks, data may take some\ntime to load. Technically, the router pauses the transition until the promises\nreturned from each hook fulfill.\n\nConsider the following:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('slow-model');\n});\n\n\n\n  \n    \n      app/routes/slow-model.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.findAll('slowModel');\n  }\n});\n\n\n\nIf you navigate to slow-model, in the model hook,\nthe query may take a long time to complete.\nDuring this time, your UI isn't really giving you any feedback as to\nwhat's happening. If you're entering this route after a full page\nrefresh, your UI will be entirely blank, as you have not actually\nfinished fully entering any route and haven't yet displayed any\ntemplates. If you're navigating to slow-model from another\nroute, you'll continue to see the templates from the previous route\nuntil the model finish loading, and then, boom, suddenly all the\ntemplates for slow-model load.\n\nSo, how can we provide some visual feedback during the transition?\n\nSimply define a template called loading (and optionally a corresponding route)\nthat Ember will transition to. The\nintermediate transition into the loading substate happens immediately\n(synchronously), the URL won't be updated, and, unlike other transitions, the\ncurrently active transition won't be aborted.\n\nOnce the main transition into slow-model completes, the loading\nroute will be exited and the transition to slow-model will continue.\n\nFor nested routes, like:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  Router.map(function() {\n  this.route('foo', function() {\n    this.route('bar', function() {\n      this.route('slow-model');\n    });\n  });\n});\n\n\n\nEmber will alternate trying to find a routeName-loading or loading template\nin the hierarchy starting with foo.bar.slow-model-loading:\n\n\nslow-model-loading\nfoo.bar.loading or foo.bar-loading\nfoo.loading or foo-loading\nloading or application-loading\n\n\nIt's important to note that for slow-model itself Ember will not try to find\na slow-model.loading template but for the rest of the hierarchy either\nsyntax is acceptable. This can be useful for creating a custom loading screen\nfor a leaf route like slow-model.\nThe loading event\nIf the various beforeModel/model/afterModel hooks\ndon't immediately resolve, a loading event will be fired on that route.\n\n  \n    \n      app/routes/foo-slow-model.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.findAll('slowModel');\n  },\n  actions: {\n    loading(transition, originRoute) {\n      alert('Sorry this page is taking so long to load!');\n    }\n  }\n});\n\n\n\nIf the loading handler is not defined at the specific route,\nthe event will continue to bubble above a transition's parent\nroute, providing the application route the opportunity to manage it.\nerror substates\nEmber provides an analogous approach to loading substates in\nthe case of errors encountered during a transition.\n\nSimilar to how the default loading event handlers are implemented,\nthe default error handlers will look for an appropriate error substate to\nenter, if one can be found.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('articles', function() {\n    this.route('overview');\n  });\n});\n\n\n\nAs with the loading substate, on a thrown error or rejected promise returned\nfrom the articles.overview route's model hook (or beforeModel or\nafterModel) Ember will look for an error template or route in the following\norder:\n\n\narticles.overview-error\narticles.error or articles-error\nerror or application-error\n\n\nIf one of the above is found, the router will immediately transition into\nthat substate (without updating the URL). The \"reason\" for the error\n(i.e. the exception thrown or the promise reject value) will be passed\nto that error state as its model.\n\nIf no viable error substates can be found, an error message will be\nlogged.\nThe error event\nIf the articles.overview route's model hook returns a promise that rejects\n(for instance the server returned an error, the user isn't logged in,\netc.), an error event will fire from that route and bubble upward.\nThis error event can be handled and used to display an error message,\nredirect to a login page, etc.\n\n  \n    \n      app/routes/articles-overview.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Route.extend({\n  model(params) {\n    return this.store.findAll('nonexistentModel');\n  },\n  actions: {\n    error(error, transition) {\n      if (error \u0026\u0026 error.status === 400) {\n        return this.transitionTo('modelNotFound');\n      }\n    }\n  }\n});\n\n\n\nAnalogous to the loading event, you could manage the error event\nat the application level to avoid writing the same code for multiple routes.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"73217f11fed62d7b09ccc1c4378f49e7","fields":[{"name":"title","value":"Preventing and Retrying Transitions","type":"string"},{"name":"url","value":"/routing/preventing-and-retrying-transitions/","type":"enum"},{"name":"body","value":"During a route transition, the Ember Router passes a transition\nobject to the various hooks on the routes involved in the transition.\nAny hook that has access to this transition object has the ability\nto immediately abort the transition by calling transition.abort(),\nand if the transition object is stored, it can be re-attempted at a\nlater time by calling transition.retry().\nPreventing Transitions via willTransition\nWhen a transition is attempted, whether via {{link-to}}, transitionTo,\nor a URL change, a willTransition action is fired on the currently\nactive routes. This gives each active route, starting with the leaf-most\nroute, the opportunity to decide whether or not the transition should occur.\n\nImagine your app is in a route that's displaying a complex form for the user\nto fill out and the user accidentally navigates backwards. Unless the\ntransition is prevented, the user might lose all of the progress they\nmade on the form, which can make for a pretty frustrating user experience.\n\nHere's one way this situation could be handled:\n\n  \n    \n      app/routes/form.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export default Ember.Route.extend({\n  actions: {\n    willTransition(transition) {\n      if (this.controller.get('userHasEnteredData') \u0026\u0026\n          !confirm('Are you sure you want to abandon progress?')) {\n        transition.abort();\n      } else {\n        // Bubble the `willTransition` action so that\n        // parent routes can decide whether or not to abort.\n        return true;\n      }\n    }\n  }\n});\n\n\n\nWhen the user clicks on a {{link-to}} helper, or when the app initiates a\ntransition by using transitionTo, the transition will be aborted and the URL\nwill remain unchanged. However, if the browser back button is used to\nnavigate away from route:form, or if the user manually changes the URL, the\nnew URL will be navigated to before the willTransition action is\ncalled. This will result in the browser displaying the new URL, even if\nwillTransition calls transition.abort().\nAborting Transitions Within model, beforeModel, afterModel\nThe model, beforeModel, and afterModel hooks described in\nAsynchronous Routing\neach get called with a transition object. This makes it possible for\ndestination routes to abort attempted transitions.\n\n  \n    \n      app/routes/disco.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  beforeModel(transition) {\n    if (new Date() \u003e new Date('January 1, 1980')) {\n      alert('Sorry, you need a time machine to enter this route.');\n      transition.abort();\n    }\n  }\n});\n\n\nStoring and Retrying a Transition\nAborted transitions can be retried at a later time. A common use case\nfor this is having an authenticated route redirect the user to a login\npage, and then redirecting them back to the authenticated route once\nthey've logged in.\n\n  \n    \n      app/routes/some-authenticated.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Route.extend({\n  beforeModel(transition) {\n    if (!this.controllerFor('auth').get('userIsLoggedIn')) {\n      var loginController = this.controllerFor('login');\n      loginController.set('previousTransition', transition);\n      this.transitionTo('login');\n    }\n  }\n});\n\n\n\n  \n    \n      app/controllers/login.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Controller.extend({\n  actions: {\n    login() {\n      // Log the user in, then reattempt previous transition if it exists.\n      var previousTransition = this.get('previousTransition');\n      if (previousTransition) {\n        this.set('previousTransition', null);\n        previousTransition.retry();\n      } else {\n        // Default back to homepage\n        this.transitionToRoute('index');\n      }\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a10da78f7f24528b1e5d721dbc5e424b","fields":[{"name":"title","value":"Query Parameters","type":"string"},{"name":"url","value":"/routing/query-params/","type":"enum"},{"name":"body","value":"Query parameters are optional key-value pairs that appear to the right of\nthe ? in a URL. For example, the following URL has two query params,\nsort and page, with respective values ASC and 2:\n\n  1\n\n  http://example.com/articles?sort=ASC\u0026page=2\n\n\n\nQuery params allow for additional application state to be serialized\ninto the URL that can't otherwise fit into the path of the URL (i.e.\neverything to the left of the ?). Common use cases for query params include\nrepresenting the current page number in a paginated collection, filter criteria, or sorting criteria.\nSpecifying Query Parameters\nQuery params are declared on route-driven controllers. For example, to\nconfigure query params that are active within the articles route,\nthey must be declared on controller:articles.\n\nTo add a category\nquery parameter that will filter out all the articles that haven't\nbeen categorized as popular we'd specify 'category'\nas one of controller:article's queryParams:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  queryParams: ['category'],\n  category: null\n});\n\n\n\nThis sets up a binding between the category query param in the URL,\nand the category property on controller:articles. In other words,\nonce the articles route has been entered, any changes to the\ncategory query param in the URL will update the category property\non controller:articles, and vice versa.\n\nNow we just need to define a computed property of our category-filtered\narray that the articles template will render:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Controller.extend({\n  queryParams: ['category'],\n  category: null,\n\n  filteredArticles: Ember.computed('category', 'model', function() {\n    var category = this.get('category');\n    var articles = this.get('model');\n\n    if (category) {\n      return articles.filterBy('category', category);\n    } else {\n      return articles;\n    }\n  })\n});\n\n\n\nWith this code, we have established the following behaviors:\n\n\nIf the user navigates to /articles, category will be null, so\nthe articles won't be filtered.\nIf the user navigates to /articles?category=recent,\ncategory will be set to \"recent\", so articles will be filtered.\nOnce inside the articles route, any changes to the category\nproperty on controller:articles will cause the URL to update the\nquery param. By default, a query param property change won't cause a\nfull router transition (i.e. it won't call model hooks and\nsetupController, etc.); it will only update the URL.\n\nlink-to Helper\nThe link-to helper supports specifying query params using the\nquery-params subexpression helper.\n\n  1\n2\n3\n4\n5\n\n  // Explicitly set target query params\n{{#link-to \"posts\" (query-params direction=\"asc\")}}Sort{{/link-to}}\n\n// Binding is also supported\n{{#link-to \"posts\" (query-params direction=otherDirection)}}Sort{{/link-to}}\n\n\n\nIn the above examples, direction is presumably a query param property\non the controller:post, but it could also refer to a direction property\non any of the controllers associated with the posts route hierarchy,\nmatching the leaf-most controller with the supplied property name.\n\nThe link-to helper takes into account query parameters when determining\nits \"active\" state, and will set the class appropriately. The active state\nis determined by calculating whether the query params end up the same after\nclicking a link. You don't have to supply all of the current,\nactive query params for this to be true.\ntransitionTo\nRoute#transitionTo and Controller#transitionToRoute\naccept a final argument, which is an object with the key queryParams.\n\n  \n    \n      app/routes/some-route.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  this.transitionTo('post', object, { queryParams: { showDetails: true }});\nthis.transitionTo('posts', { queryParams: { sort: 'title' }});\n\n// if you just want to transition the query parameters without changing the route\nthis.transitionTo({ queryParams: { direction: 'asc' }});\n\n\n\nYou can also add query params to URL transitions:\n\n  \n    \n      app/routes/some-route.js\n    \n  \n\n  1\n\n  this.transitionTo('/posts/1?sort=date\u0026showDetails=true');\n\n\nOpting into a full transition\nArguments provided to transitionTo\nor link-to only correspond to a change in query param values,\nand not a change in the route hierarchy, it is not considered a\nfull transition, which means that hooks like model and\nsetupController won't fire by default, but rather only\ncontroller properties will be updated with new query param values, as\nwill the URL.\n\nBut some query param changes necessitate loading data from the server,\nin which case it is desirable to opt into a full-on transition. To opt\ninto a full transition when a controller query param property changes,\nyou can use the optional queryParams configuration hash on the Route\nassociated with that controller, and set that query param's\nrefreshModel config property to true:\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  export default Ember.Route.extend({\n  queryParams: {\n    category: {\n      refreshModel: true\n    }\n  },\n  model(params) {\n    // This gets called upon entering 'articles' route\n    // for the first time, and we opt into refiring it upon\n    // query param changes by setting `refreshModel:true` above.\n\n    // params has format of { category: \"someValueOrJustNull\" },\n    // which we can just forward to the server.\n    return this.store.query('articles', params);\n  }\n});\n\n\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  queryParams: ['category'],\n  category: null\n});\n\n\nUpdate URL with replaceState instead\nBy default, Ember will use pushState to update the URL in the\naddress bar in response to a controller query param property change, but\nif you would like to use replaceState instead (which prevents an\nadditional item from being added to your browser's history), you can\nspecify this on the Route's queryParams config hash, e.g. (continued\nfrom the example above):\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  queryParams: {\n    category: {\n      replace: true\n    }\n  }\n});\n\n\n\nNote that the name of this config property and its default value of\nfalse is similar to the link-to helper's, which also lets\nyou opt into a replaceState transition via replace=true.\nMap a controller's property to a different query param key\nBy default, specifying foo as a controller query param property will\nbind to a query param whose key is foo, e.g. ?foo=123. You can also map\na controller property to a different query param key using the\nfollowing configuration syntax:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Controller.extend({\n  queryParams: {\n    category: 'articles_category'\n  },\n  category: null\n});\n\n\n\nThis will cause changes to the controller:articles's category\nproperty to update the articles_category query param, and vice versa.\n\nNote that query params that require additional customization can\nbe provided along with strings in the queryParams array.\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Controller.extend({\n  queryParams: ['page', 'filter', {\n    category: 'articles_category'\n  }],\n  category: null,\n  page: 1,\n  filter: 'recent'\n});\n\n\nDefault values and deserialization\nIn the following example, the controller query param property page is\nconsidered to have a default value of 1.\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  queryParams: 'page',\n  page: 1\n});\n\n\n\nThis affects query param behavior in two ways:\n\n\nQuery param values are cast to the same datatype as the default\nvalue, e.g. a URL change from /?page=3 to /?page=2 will set\ncontroller:articles's page property to the number 2, rather than\nthe string \"2\". The same also applies to boolean default values.\nWhen a controller's query param property is currently set to its\ndefault value, this value won't be serialized into the URL. So in the\nabove example, if page is 1, the URL might look like /articles,\nbut once someone sets the controller's page value to 2, the URL\nwill become /articles?page=2.\n\nSticky Query Param Values\nBy default, query param values in Ember are \"sticky\", in that if you\nmake changes to a query param and then leave and re-enter the route, the\nnew value of that query param will be preserved (rather than reset to\nits default). This is a particularly handy default for preserving sort/filter\nparameters as you navigate back and forth between routes.\n\nFurthermore, these sticky query param values are remembered/restored\naccording to the model loaded into the route. So, given a team route\nwith dynamic segment /:team_name and controller query param \"filter\",\nif you navigate to /badgers and filter by \"rookies\", then navigate\nto /bears and filter by \"best\", and then navigate to /potatoes and\nfilter by \"lamest\", then given the following nav bar links,\n\n  1\n2\n3\n\n  {{#link-to \"team\" \"badgers\"}}Badgers{{/link-to}}\n{{#link-to \"team\" \"bears\"}}Bears{{/link-to}}\n{{#link-to \"team\" \"potatoes\"}}Potatoes{{/link-to}}\n\n\n\nthe generated links would be\n\n  1\n2\n3\n\n  \u003ca href=\"/badgers?filter=rookies\"\u003eBadgers\u003c/a\u003e\n\u003ca href=\"/bears?filter=best\"\u003eBears\u003c/a\u003e\n\u003ca href=\"/potatoes?filter=lamest\"\u003ePotatoes\u003c/a\u003e\n\n\n\nThis illustrates that once you change a query param, it is stored and\ntied to the model loaded into the route.\n\nIf you wish to reset a query param, you have two options:\n\n\nexplicitly pass in the default value for that query param into\nlink-to or transitionTo\nuse the Route.resetController hook to set query param values back to\ntheir defaults before exiting the route or changing the route's model\n\n\nIn the following example, the controller's page query param is reset\nto 1, while still scoped to the pre-transition ArticlesRoute model.\nThe result of this is that all links pointing back into the exited route\nwill use the newly reset value 1 as the value for the page query\nparam.\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  resetController(controller, isExiting, transition) {\n    if (isExiting) {\n      // isExiting would be false if only the route's model was changing\n      controller.set('page', 1);\n    }\n  }\n});\n\n\n\nIn some cases, you might not want the sticky query param value to be\nscoped to the route's model but would rather reuse a query param's value\neven as a route's model changes. This can be accomplished by setting the\nscope option to \"controller\" within the controller's queryParams\nconfig hash:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Controller.extend({\n  queryParams: [{\n    showMagnifyingGlass: {\n      scope: 'controller'\n    }\n  }]\n});\n\n\n\nThe following demonstrates how you can override both the scope and the\nquery param URL key of a single controller query param property:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Controller.extend({\n  queryParams: ['page', 'filter',\n    {\n      showMagnifyingGlass: {\n        scope: 'controller',\n        as: 'glass'\n      }\n    }\n  ]\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"088e52d28fa44f8c93ca2f490bad93c3","fields":[{"name":"title","value":"Redirecting","type":"string"},{"name":"url","value":"/routing/redirection/","type":"enum"},{"name":"body","value":"Calling transitionTo from a route or transitionToRoute from a controller\nwill stop any transition currently in progress and start a new one, functioning\nas a redirect. transitionTo behaves exactly like the link-to helper.\n\nIf the new route has dynamic segments, you need to pass either a model or an identifier for each segment.\nPassing a model will skip that segment's model hook (since the model is\nalready loaded).\nTransitioning Before the Model is Known\nIf you want to redirect from one route to another, you can do the transition in\nthe beforeModel hook of your route handler.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('posts');\n});\n\n\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  beforeModel() {\n    this.transitionTo('posts');\n  }\n});\n\n\n\nIf you need to examine some application state to figure out where to redirect,\nyou might use a service.\nTransitioning After the Model is Known\nIf you need information about the current model in order to decide about\nredirection, you can use the afterModel hook.\nIt receives the resolved model as the first parameter and the transition as\nthe second one. For example:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('posts');\n  this.route('post', { path: '/post/:post_id' });\n});\n\n\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  afterModel(model, transition) {\n    if (model.get('length') === 1) {\n      this.transitionTo('post', model.get('firstObject'));\n    }\n  }\n});\n\n\n\nWhen transitioning to the posts route if it turns out that there is only one post,\nthe current transition will be aborted in favor of redirecting to the PostRoute\nwith the single post object being its model.\nChild Routes\nLet's change the router above to used a nested route, like this:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', function() {\n    this.route('post', { path: ':post_id' });\n  });\n});\n\n\n\nIf we redirect to posts.post in the afterModel hook, afterModel\nessentially invalidates the current attempt to enter this route. So the posts\nroute's beforeModel, model, and afterModel hooks will fire again within\nthe new, redirected transition. This is inefficient, since they just fired\nbefore the redirect.\n\nInstead, we can use the redirect hook, which will leave the original\ntransition validated, and not cause the parent route's hooks to fire again:\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  redirect(model, transition) {\n    if (model.get('length') === 1) {\n      this.transitionTo('posts.post', model.get('firstObject'));\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b1db196c912b89d4bb0d82325bb9137c","fields":[{"name":"title","value":"Rendering a Template","type":"string"},{"name":"url","value":"/routing/rendering-a-template/","type":"enum"},{"name":"body","value":"One job of a route handler is rendering the\nappropriate template to the screen.\n\nBy default, a route handler will render the template with the same name as the\nroute. Take this router:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', function() {\n    this.route('new');\n  });\n});\n\n\n\nHere, the posts route will render the posts.hbs template, and\nthe posts.new route will render posts/new.hbs.\n\nEach template will be rendered into the {{outlet}} of its parent route's\ntemplate. For example, the posts.new route will render its template into the\npost.hbs's {{outlet}}, and the posts route will render its template into\nthe application.hbs's {{outlet}}.\n\nIf you want to render a template other than the default one, implement the\nrenderTemplate hook:\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  renderTemplate() {\n    this.render('favoritePosts');\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d94b756c7278f11f9a951d1a47d8640f","fields":[{"name":"title","value":"Specifying a Route's Model","type":"string"},{"name":"url","value":"/routing/specifying-a-routes-model/","type":"enum"},{"name":"body","value":"Often, you'll want a template to display data from a model. Loading the\nappropriate model is one job of a route.\n\nFor example, take this router:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('favoritePosts');\n});\n\n\n\nTo load a model for the favoritePosts route, you would use the model hook in\nthe posts route handler:\n\n  \n    \n      app/routes/favorite-posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model() {\n    return this.store.query('post', { favorite: true });\n  }\n});\n\n\n\nTypically, the model hook should return an Ember Data record,\nbut it can also return any promise object (Ember\nData records are promises), or a plain JavaScript object or array. Ember will\nwait until the data finishes loading (until the promise is resolved) before\nrendering the template.\n\nThe return value from the model hook is then available in your template and\ncontroller with the model property:\n\n  \n    \n      app/templates/favorite-post.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003ch1\u003eFavorite Posts\u003c/h1\u003e\n{{#each model as |post|}}\n  \u003cp\u003e{{post.body}}\u003c/p\u003e\n{{/each}}\n\n\nDynamic Models\nSome routes always display the same model. For example, the /photos\nroute will always display the same list of photos available in the\napplication. If your user leaves this route and comes back later, the\nmodel does not change.\n\nHowever, you will often have a route whose model will change depending\non user interaction. For example, imagine a photo viewer app. The\n/photos route will render the photos template with the list of\nphotos as the model, which never changes. But when the user clicks on a\nparticular photo, we want to display that model with the photo\ntemplate. If the user goes back and clicks on a different photo, we want\nto display the photo template again, this time with a different model.\n\nIn cases like this, it's important that we include some information in\nthe URL about not only which template to display, but also which model.\n\nIn Ember, this is accomplished by defining routes with dynamic\nsegments.\n\nOnce you have defined a route with a dynamic segment,\nEmber will extract the value of the dynamic segment from the URL for\nyou and pass them as a hash to the model hook as the first argument:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('photo', { path: '/photos/:photo_id' });\n});\n\n\n\n  \n    \n      app/routes/photo.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model(params) {\n    return this.store.findRecord('photo', params.photo_id);\n  }\n});\n\n\n\nIn the model hook for routes with dynamic segments, it's your job to\nturn the ID (something like 47 or post-slug) into a model that can\nbe rendered by the route's template. In the above example, we use the\nphoto's ID (params.photo_id) as an argument to Ember Data's findRecord\nmethod.\n\nNote: A route with a dynamic segment will only have its model hook called\nwhen it is entered via the URL. If the route is entered through a transition\n(e.g. when using the link-to Handlebars helper), then a model context is\nalready provided and the hook is not executed. Routes without dynamic segments\nwill always execute the model hook.\nMultiple Models\nMultiple models can be returned through an\nEmber.RSVP.hash.\nThe Ember.RSVP.hash takes\nparameters that return promises, and when all parameter promises resolve, then\nthe Ember.RSVP.hash promise resolves. For example:\n\n  \n    \n      app/routes/songs.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  model() {\n    return Ember.RSVP.hash({\n      songs: this.store.findAll('song'),\n      albums: this.store.findAll('album')\n    });\n  }\n});\n\n\n\nIn the songs template, we can specify both models and use the {{#each}} helper to display\neach record in the song model and album model:\n\n  \n    \n      app/templates/songs.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  \u003ch1\u003ePlaylist\u003c/h1\u003e\n\n\u003cul\u003e\n  {{#each model.songs as |song|}}\n    \u003cli\u003e{{song.name}} by {{song.artist}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\u003ch1\u003eAlbums\u003c/h1\u003e\n\n\u003cul\u003e\n  {{#each model.albums as |album|}}\n    \u003cli\u003e{{album.title}} by {{album.artist}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"1b11151882558c3e878b1c432610d998","fields":[{"name":"title","value":"Actions","type":"string"},{"name":"url","value":"/templates/actions/","type":"enum"},{"name":"body","value":"Your app will often need a way to let users interact with controls that\nchange application state. For example, imagine that you have a template\nthat shows a blog title, and supports expanding the post to show the body.\n\nIf you add the {{action}} helper to an HTML element, when a user\nclicks the element, the named event will be sent to the template's\ncorresponding component or controller.\n\n  \n    \n      app/templates/components/post.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003ch3 {{action \"toggleBody\"}}\u003e{{title}}\u003c/h3\u003e\n{{#if isShowingBody}}\n  \u003cp\u003e{{{body}}}\u003c/p\u003e\n{{/if}}\n\n\n\nIn the component or controller, you can then define what the action does within\nthe actions hook:\n\n  \n    \n      app/components/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  actions: {\n    toggleBody() {\n      this.toggleProperty('isShowingBody');\n    }\n  }\n});\n\n\nAction Parameters\nYou can optionally pass arguments to the action handler. Any values\npassed to the {{action}} helper after the action name will be passed to\nthe handler as arguments.\n\nFor example, if the post argument was passed:\n\n  1\n\n  \u003cp\u003e\u003cbutton {{action \"select\" post}}\u003e\u003c/button\u003e {{post.title}}\u003c/p\u003e\n\n\n\nThe select action handler would be called with a single argument\ncontaining the post model:\n\n  \n    \n      app/components/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  actions: {\n    select(post) {\n      console.log(post.get('title'));\n    }\n  }\n});\n\n\nSpecifying the Type of Event\nBy default, the {{action}} helper listens for click events and triggers\nthe action when the user clicks on the element.\n\nYou can specify an alternative event by using the on option.\n\n  1\n2\n3\n4\n\n  \u003cp\u003e\n  \u003cbutton {{action \"select\" post on=\"mouseUp\"}}\u003e\u003c/button\u003e\n  {{post.title}}\n\u003c/p\u003e\n\n\n\nYou should use the dasherized event names, so two-word names like keypress\nbecome key-press.\nAllowing Modifier Keys\nBy default the {{action}} helper will ignore click events with\npressed modifier keys. You can supply an allowedKeys option\nto specify which keys should not be ignored.\n\n  1\n2\n3\n\n  \u003cbutton {{action \"anActionName\" allowedKeys=\"alt\"}}\u003e\n  click me\n\u003c/button\u003e\n\n\n\nThis way the {{action}} will fire when clicking with the alt key\npressed down.\nAllowing Default Browser Action\nBy default, the {{action}} helper prevents the default browser action of the\nDOM event. If you want to allow the browser action, you can stop Ember from\npreventing it.\n\nFor example, if you have a normal link tag and want the link to bring the user\nto another page in addition to triggering an ember action when clicked, you can\nuse preventDefault=false:\n\n  1\n\n  \u003ca href=\"newPage.htm\" {{action \"logClick\" preventDefault=false}}\u003eGo\u003c/a\u003e\n\n\n\nWithout preventDefault=false, if the user clicked on the link, Ember.js\nwill trigger the action, but the user will remain on the current page.\n\nWith preventDefault=false, if the user clicked on the link, Ember.js\nwill trigger the action and the user will be directed to the new page.\nModifying the action's first parameter\nIf a value option for the {{action}} helper is specified, its value will be\nconsidered a property path that will be read off of the first parameter of the\naction. This comes very handy with event listeners and enables to work with\none-way bindings.\n\n  1\n2\n\n  \u003clabel\u003eWhat's your favorite band?\u003c/label\u003e\n\u003cinput type=\"text\" value={{favoriteBand}} onblur={{action \"bandDidChange\"}}/\u003e\n\n\n\nLet's assume we have an action handler that just prints its first parameter:\n\n  1\n2\n3\n4\n5\n\n  actions: {\n  bandDidChange(newValue) {\n    console.log(newValue);\n  }\n}\n\n\n\nBy default, the action handler receives the first parameter of the event\nlistener, the event object the browser passes to the handler, so\nbandDidChange prints Event {}.\n\nUsing the value option modifies that behavior by extracting that property from\nthe event object:\n\n  1\n2\n\n  \u003clabel\u003eWhat's your favorite band?\u003c/label\u003e\n\u003cinput type=\"text\" value={{favoriteBand}} onblur={{action \"bandDidChange\" value=\"target.value\"}}/\u003e\n\n\n\nThe newValue parameter thus becomes the target.value property of the event\nobject, which is the value of the input field the user typed. (e.g 'Foo Fighters')\nAttaching Actions to Non-Clickable Elements\nNote that actions may be attached to any element of the DOM, but not all\nrespond to the click event. For example, if an action is attached to an a\nlink without an href attribute, or to a div, some browsers won't execute\nthe associated function. If it's really needed to define actions over such\nelements, a CSS workaround exists to make them clickable, cursor: pointer.\nFor example:\n\n  1\n2\n3\n\n  [data-ember-action] {\n  cursor: pointer;\n}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"59c50884dd61207af6fc0a831825eb47","fields":[{"name":"title","value":"Binding Element Attributes","type":"string"},{"name":"url","value":"/templates/binding-element-attributes/","type":"enum"},{"name":"body","value":"In addition to normal text, you may also want to have your templates\ncontain HTML elements whose attributes are bound to the controller.\n\nFor example, imagine your controller has a property that contains a URL\nto an image:\n\n  1\n2\n3\n\n  \u003cdiv id=\"logo\"\u003e\n  \u003cimg src={{logoUrl}} alt=\"Logo\"\u003e\n\u003c/div\u003e\n\n\n\nThis generates the following HTML:\n\n  1\n2\n3\n\n  \u003cdiv id=\"logo\"\u003e\n  \u003cimg src=\"http://www.example.com/images/logo.png\" alt=\"Logo\"\u003e\n\u003c/div\u003e\n\n\n\nIf you use data binding with a Boolean value, it will add or remove\nthe specified attribute. For example, given this template:\n\n  1\n\n  \u003cinput type=\"checkbox\" disabled={{isAdministrator}}\u003e\n\n\n\nIf isAdministrator is true, Handlebars will produce the following\nHTML element:\n\n  1\n\n  \u003cinput type=\"checkbox\" disabled\u003e\n\n\n\nIf isAdministrator is false, Handlebars will produce the following:\n\n  1\n\n  \u003cinput type=\"checkbox\"\u003e\n\n\nAdding Data Attributes\nBy default, view helpers do not accept data attributes. For example\n\n  1\n2\n3\n\n  {{#link-to \"photos\" data-toggle=\"dropdown\"}}Photos{{/link-to}}\n\n{{input type=\"text\" data-toggle=\"tooltip\" data-placement=\"bottom\" title=\"Name\"}}\n\n\n\nrenders the following HTML:\n\n  1\n2\n3\n4\n\n  \u003ca id=\"ember239\" class=\"ember-view\" href=\"#/photos\"\u003ePhotos\u003c/a\u003e\n\n\u003cinput id=\"ember257\" class=\"ember-view ember-text-field\" type=\"text\"\n       title=\"Name\"\u003e\n\n\n\nTo enable support for data attributes an attribute binding must be\nadded to the component, e.g. Ember.LinkComponent or Ember.TextField\nfor the specific attribute:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  Ember.LinkComponent.reopen({\n  attributeBindings: ['data-toggle']\n});\n\nEmber.TextField.reopen({\n  attributeBindings: ['data-toggle', 'data-placement']\n});\n\n\n\nNow the same handlebars code above renders the following HTML:\n\n  1\n2\n3\n4\n\n  \u003ca id=\"ember240\" class=\"ember-view\" href=\"#/photos\" data-toggle=\"dropdown\"\u003ePhotos\u003c/a\u003e\n\n\u003cinput id=\"ember259\" class=\"ember-view ember-text-field\"\n       type=\"text\" data-toggle=\"tooltip\" data-placement=\"bottom\" title=\"Name\"\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"95d724148efe2cc1481ae51952ecf2b7","fields":[{"name":"title","value":"Conditionals","type":"string"},{"name":"url","value":"/templates/conditionals/","type":"enum"},{"name":"body","value":"Statements like if and unless are implemented as built-in helpers. Helpers\ncan be invoked three ways, each of which is illustrated below with conditionals.\n\nThe first style of invocation is inline invocation. This looks similar to\ndisplaying a property, but helpers accept arguments. For example:\n\n  1\n2\n3\n\n  \u003cdiv\u003e\n  {{if isFast \"zoooom\" \"putt-putt-putt\"}}\n\u003c/div\u003e\n\n\n\n{{if}} in this case returns \"zoooom\" when isFast is true and\n\"putt-putt-putt\" when isFast is false. Helpers invoked as inline expressions\nrender a single value, the same way that properties are a single value.\n\nInline helpers don't need to be used inside HTML tags. They can also be used\ninside attribute values:\n\n  1\n2\n\n  \u003cdiv class=\"is-car {{if isFast \"zoooom\" \"putt-putt-putt\"}}\"\u003e\n\u003c/div\u003e\n\n\n\nNested invocation is another way to use a helper. Just like inline helpers,\nnested helpers generate and return a single value. For example, this template\nonly renders \"zoooom\" if both isFast and isFueled are true:\n\n  1\n2\n3\n\n  \u003cdiv\u003e\n  {{if isFast (if isFueled \"zoooom\")}}\n\u003c/div\u003e\n\n\n\nThe nested helper is called first returning \"zoooom\" only if isFueled is\ntrue. Then the inline expression is called, rendering the nested helper's\nvalue (\"zoooom\") only if isFast is true.\n\nThe third form of helper usage is block invocation. Use block helpers\nto render only part of a template. Block invocation of a helper can be\nrecognized by the # before the helper name, and the closing {{/ double\ncurly brace at the end of the invocation.\n\nFor example, this template conditionally shows\nproperties on person only if that it is present:\n\n  1\n2\n3\n\n  {{#if person}}\n  Welcome back, \u003cb\u003e{{person.firstName}} {{person.lastName}}\u003c/b\u003e!\n{{/if}}\n\n\n\n{{if}} checks for truthiness, which means all values except false,\nundefined, null, '', 0  or [] (i.e., any JavaScript falsy value or an\nempty array).\n\nIf a value passed to {{#if}} evaluates to falsy, the {{else}} block\nof that invocation is rendered:\n\n  1\n2\n3\n4\n5\n\n  {{#if person}}\n  Welcome back, \u003cb\u003e{{person.firstName}} {{person.lastName}}\u003c/b\u003e!\n{{else}}\n  Please log in.\n{{/if}}\n\n\n\n{{else}} can chain helper invocation, the most common usecase for this being\n{{else if}}:\n\n  1\n2\n3\n4\n5\n\n  {{#if isAtWork}}\n  Ship that code!\n{{else if isReading}}\n  You can finish War and Peace eventually...\n{{/if}}\n\n\n\nThe inverse of {{if}} is {{unless}}, which can be used in the same three\nstyles of invocation. For example, this template only shows an amount due when the\nuser has not paid:\n\n  1\n2\n3\n\n  {{#unless hasPaid}}\n  You owe: ${{total}}\n{{/unless}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a114533ff2793c31df860c375985bcb","fields":[{"name":"title","value":"Development Helpers","type":"string"},{"name":"url","value":"/templates/development-helpers/","type":"enum"},{"name":"body","value":"Development Helpers\nHandlebars and Ember come with a few helpers that can make developing your\ntemplates a bit easier. These helpers make it simple to output variables into\nyour browser's console, or activate the debugger from your templates.\nLogging\nThe {{log}} helper makes it easy to output variables or expressions in the\ncurrent rendering context into your browser's console:\n\n  1\n\n  {{log 'Name is:' name}}\n\n\n\nThe {{log}} helper also accepts primitive types such as strings or numbers.\nAdding a breakpoint\nThe {{debugger}} helper provides a handlebars equivalent to JavaScript's\ndebugger keyword.  It will halt execution inside the debugger helper and give\nyou the ability to inspect the current rendering context:\n\n  1\n\n  {{debugger}}\n\n\n\nWhen using the debugger helper you will have access to a get function. This\nfunction retrieves values available in the context of the template.\nFor example, if you're wondering why a value {{foo}} isn't rendering as\nexpected within a template, you could place a {{debugger}} statement and,\nwhen the debugger; breakpoint is hit, you can attempt to retrieve this value:\n\n  1\n\n  \u003e get('foo')\n\n\n\nget is also aware of keywords. So in this situation:\n\n  1\n2\n3\n\n  {{#each items as |item|}}\n  {{debugger}}\n{{/each}}\n\n\n\nYou'll be able to get values from the current item:\n\n  1\n\n  \u003e get('item.name')\n\n\n\nYou can also access the context of the view to make sure it is the object that\nyou expect:\n\n  1\n\n  \u003e context\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"94f518795fa706013cfd0ed73c5a9d3c","fields":[{"name":"title","value":"Displaying a List of Items","type":"string"},{"name":"url","value":"/templates/displaying-a-list-of-items/","type":"enum"},{"name":"body","value":"To iterate over a list of items, use the {{#each}} helper. The first\nargument to this helper is the array to be iterated, and the value being\niterated is yielded as a block param. Block params are only available inside\nthe block of their helper.\n\nFor example, this template iterates an array named people that contains\nobjects. Each item in the array is provided as the block param person.\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each people as |person|}}\n    \u003cli\u003eHello, {{person.name}}!\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nBlock params, like function arguments in JavaScript, are positional. person\nis what each item is named in the above template, but human would work just\nas well.\n\nThe template inside of the {{#each}} block will be repeated once for\neach item in the array, with the each item set to the person block param.\n\nGiven an input array like:\n\n  1\n2\n3\n\n  [ {name: 'Yehuda'},\n  {name: 'Tom'   },\n  {name: 'Trek'  } ]\n\n\n\nThe above template will render HTML like this:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003eHello, Yehuda!\u003c/li\u003e\n  \u003cli\u003eHello, Tom!\u003c/li\u003e\n  \u003cli\u003eHello, Trek!\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\nLike other helpers, the {{#each}} helper is bound.  If a new item is added to\nor removed from the iterated array, the DOM will be updated without having to\nwrite any additional code. That said, Ember requires that you use special\nmethods\nto update bound arrays.\nAccessing an item's index\nDuring iteration, the index of each item in an the array is provided as a second\nblock param. Block params are space-seperated, without commas. For example:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each people as |person index|}}\n    \u003cli\u003eHello, {{person.name}}! You're number {{index}} in line\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\nEmpty Lists\nThe {{#each}} helper can have a corresponding {{else}}.\nThe contents of this block will render if the array passed to {{#each}} is\nis empty:\n\n  1\n2\n3\n4\n5\n\n  {{#each people as |person|}}\n  Hello, {{person.name}}!\n{{else}}\n  Sorry, nobody is here.\n{{/each}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e4a18275d9d8f6f71670bfc8e9f84a14","fields":[{"name":"title","value":"Displaying the Keys in an Object","type":"string"},{"name":"url","value":"/templates/displaying-the-keys-in-an-object/","type":"enum"},{"name":"body","value":"If you need to display all of the keys or values of a\nJavaScript object in your template, you can use the {{#each-in}}\nhelper:\n\n  \n    \n      /app/components/store-categories.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Component.extend({\n  willRender() {\n    // Set the \"categories\" property to a JavaScript object\n    // with the category name as the key and the value a list\n    // of products.\n    this.set('categories', {\n      'Bourbons': ['Bulleit', 'Four Roses', 'Woodford Reserve'],\n      'Ryes': ['WhistlePig', 'High West']\n    });\n  }\n});\n\n\n\n  \n    \n      /app/templates/components/store-categories.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  \u003cul\u003e\n  {{#each-in categories as |category products|}}\n    \u003cli\u003e{{category}}\n      \u003col\u003e\n        {{#each products key=\"@item\" as |product|}}\n          \u003cli\u003e{{product}}\u003c/li\u003e\n        {{/each}}\n      \u003c/ol\u003e\n    \u003c/li\u003e\n  {{/each-in}}\n\u003c/ul\u003e\n\n\n\nThe template inside of the {{#each-in}} block is repeated once for\neach key in the passed object. The first block parameter (category in\nthe above example) is the key for this iteration, while the second block\nparameter (product) is the actual value of that key.\n\nThe above example will print a list like this:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  \u003cul\u003e\n  \u003cli\u003eBourbons\n    \u003col\u003e\n      \u003cli\u003eBulleit\u003c/li\u003e\n      \u003cli\u003eFour Roses\u003c/li\u003e\n      \u003cli\u003eWoodford Reserve\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003eRyes\n    \u003col\u003e\n      \u003cli\u003eWhistlePig\u003c/li\u003e\n      \u003cli\u003eHigh West\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\nRe-rendering\nThe {{#each-in}} helper does not observe property\nchanges to the object passed into it. In the above example, if you were\nto add a key to the component's categories property after the\ncomponent had rendered, the template would not automatically update.\n\n  \n    \n      /app/components/store-categories.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  export default Ember.Component.extend({\n  willRender() {\n    this.set('categories', {\n      'Bourbons': ['Bulleit', 'Four Roses', 'Woodford Reserve'],\n      'Ryes': ['WhistlePig', 'High West']\n    });\n  },\n\n  actions: {\n    addCategory(category) {\n      // This won't work!\n      let categories = this.get('categories');\n      categories[category] = [];\n    }\n  }\n});\n\n\n\nIn order to cause a component to re-render after you have added,\nremoved or changed a property from an object, you need to either set() the\nproperty on the component again, or manually trigger a re-render of the\ncomponent via rerender():\n\n  \n    \n      /app/components/store-categories.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  export default Ember.Component.extend({\n  willRender() {\n    this.set('categories', {\n      'Bourbons': ['Bulleit', 'Four Roses', 'Woodford Reserve'],\n      'Ryes': ['WhistlePig', 'High West']\n    });\n  },\n\n  actions: {\n    addCategory(category) {\n      let categories = this.get('categories');\n      categories[category] = [];\n\n      // A manual re-render causes the DOM to be updated\n      this.rerender();\n    }\n  }\n});\n\n\nOrdering\nAn object's keys will be listed in the same order as the array returned\nfrom calling Object.keys on that object. If you want a different sort\norder, you should use Object.keys to get an array, sort that array\nwith the built-in JavaScript tools, and use the {{#each}} helper\ninstead.\nEmpty Lists\nThe {{#each-in}} helper can have a matching {{else}}.\nThe contents of this block will render if the object is empty, null, or\nundefined:\n\n  1\n2\n3\n4\n5\n\n  {{#each-in people as |name person|}}\n  Hello, {{name}}! You are {{person.age}} years old.\n{{else}}\n  Sorry, nobody is here.\n{{/each-in}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"619a7f1e4091d5852889772b71be63d0","fields":[{"name":"title","value":"Handlebars Basics","type":"string"},{"name":"url","value":"/templates/handlebars-basics/","type":"enum"},{"name":"body","value":"Ember.js uses the Handlebars templating library\nto power your app's user interface. Handlebars templates contain static HTML and\ndynamic content inside Handlebars expressions, which are invoked with double\ncurly braces: {{}}.\n\nDynamic content inside a Handlebars expression is rendered with data-binding. This means if\nyou update a property, your usage of that property in a template will be\nautomatically updated to the latest value.\nDisplaying Properties\nTemplates are backed with a context. A context is an object from which\nHandlebars expressions read their properties. In Ember this is often a component. For\ntemplates rendered by a route (like application.hbs), the context is a\ncontroller.\n\nFor example, this application.hbs template will render a first and last name:\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n\n  Hello, \u003cstrong\u003e{{firstName}} {{lastName}}\u003c/strong\u003e!\n\n\n\nThe firstName and lastName properties are read from the\ncontext (the application controller in this case), and rendered inside the\n\u003cstrong\u003e HTML tag.\n\nTo provide a firstName and lastName to the above template, properties\nmust be added to the application controller. If you are following along with\nan Ember CLI application, you may need to create this file:\n\n  \n    \n      app/controllers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  import Ember from 'ember';\n\nexport default Ember.Controller.extend({\n  firstName: 'Trek',\n  lastName: 'Glowacki'\n});\n\n\n\nThe above template and controller render as the following HTML:\n\n  1\n\n  Hello, \u003cstrong\u003eTrek Glowacki\u003c/strong\u003e!\n\n\n\nRemember that {{firstName}} and {{lastName}} are bound data. That means\nif the value of one of those properties changes, the DOM will be updated\nautomatically.\n\nAs an application grows in size, it will have many templates backed by\ncontrollers and components.\nHelpers\nHelpers bring a minimum of logic into Ember templating. Ember ships with several\nbuilt-in helpers, which are explained in the following guides, and also allows\nyou to write your own helpers.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"cbc42197752a02e932444274327e4808","fields":[{"name":"title","value":"Input Helpers","type":"string"},{"name":"url","value":"/templates/input-helpers/","type":"enum"},{"name":"body","value":"Input Helpers\nThe {{input}} and {{textarea}} helpers in Ember.js are the easiest way to\ncreate common form controls. The {{input}} helper wraps the built-in\nEmber.TextField and Ember.Checkbox views, while {{textarea}} wraps\nEmber.TextArea. Using these helpers, you can create these views with\ndeclarations almost identical to how you'd create a traditional \u003cinput\u003e or\n\u003ctextarea\u003e element.\nText fields\n  1\n\n  {{input value=\"http://www.facebook.com\"}}\n\n\n\nWill become:\n\n  1\n\n  \u003cinput type=\"text\" value=\"http://www.facebook.com\"/\u003e\n\n\n\nYou can pass the following standard \u003cinput\u003e attributes within the input\nhelper:\n\n\n  `readonly``required``autofocus`\n  `value``placeholder``disabled`\n  `size``tabindex``maxlength`\n  `name``min``max`\n  `pattern``accept``autocomplete`\n  `autosave``formaction``formenctype`\n  `formmethod``formnovalidate``formtarget`\n  `height``inputmode``multiple`\n  `step``width``form`\n  `selectionDirection``spellcheck`\n\n\nIf these attributes are set to a quoted string, their values will be set\ndirectly on the element, as in the previous example. However, when left\nunquoted, these values will be bound to a property on the template's current\nrendering context. For example:\n\n  1\n\n  {{input type=\"text\" value=firstName disabled=entryNotAllowed size=\"50\"}}\n\n\n\nWill bind the disabled attribute to the value of entryNotAllowed in the\ncurrent context.\nActions\nTo dispatch an action on specific events, such as enter or key-press, use the following\n\n  1\n\n  {{input value=firstName key-press=\"updateFirstName\"}}\n\n\n\nEvent Names must be dasherized.\nCheckboxes\nYou can also use the {{input}} helper to create a checkbox by setting its\ntype:\n\n  1\n\n  {{input type=\"checkbox\" name=\"isAdmin\" checked=isAdmin}}\n\n\n\nCheckboxes support the following properties:\n\n\nchecked\ndisabled\ntabindex\nindeterminate\nname\nautofocus\nform\n\n\nWhich can be bound or set as described in the previous section.\nText Areas\n  1\n\n  {{textarea value=name cols=\"80\" rows=\"6\"}}\n\n\n\nWill bind the value of the text area to name on the current context.\n\n{{textarea}} supports binding and/or setting the following properties:\n\n\nvalue\nname\nrows\ncols\nplaceholder\ndisabled\nmaxlength\ntabindex\nselectionEnd\nselectionStart\nselectionDirection\nwrap\nreadonly\nautofocus\nform\nspellcheck\nrequired\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a3506f82f88ccbc90b445c4c8d73f39a","fields":[{"name":"title","value":"Links","type":"string"},{"name":"url","value":"/templates/links/","type":"enum"},{"name":"body","value":"The {{link-to}} Helper\nYou create a link to a route using the {{link-to}} helper.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('photos', function(){\n    this.route('edit', { path: '/:photo_id' });\n  });\n});\n\n\n\n  \n    \n      app/templates/photos.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each photos as |photo|}}\n    \u003cli\u003e{{#link-to \"photos.edit\" photo}}{{photo.title}}{{/link-to}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nIf the model for the photos template is a list of three photos, the\nrendered HTML would look something like this:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003e\u003ca href=\"/photos/1\"\u003eHappy Kittens\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/2\"\u003ePuppy Running\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/3\"\u003eMountain Landscape\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\nThe {{link-to}} helper takes one or two arguments:\n\n\nThe name of a route. In this example, it would be index, photos, or\nphotos.edit.\nAt most one model for each dynamic segment.\nBy default, Ember.js will replace each segment with the value of the corresponding object's id property.\nIn the example above, the second argument is each photo object, and the id property is used to fill in\nthe dynamic segment with either 1, 2, or 3. If there is no model to pass to the helper, you can provide\nan explicit value instead:\n\n\n  \n    \n      app/templates/photos.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#link-to \"photos.edit\" 1}}\n  First Photo Ever\n{{/link-to}}\n\n\n\nWhen the rendered link matches the current route, and the same\nobject instance is passed into the helper, then the link is given\nclass=\"active\". For example, if you were at the URL /photos/2,\nthe first example above would render as:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003e\u003ca href=\"/photos/1\"\u003eHappy Kittens\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/2\" class=\"active\"\u003ePuppy Running\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/3\"\u003eMountain Landscape\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\nExample for Multiple Segments\nIf the route is nested, you can supply a model or an identifier for each dynamic\nsegment.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Router.map(function() {\n  this.route('photos', function(){\n    this.route('photo', { path: '/:photo_id' }, function(){\n      this.route('comments');\n      this.route('comment', { path: '/comments/:comment_id' });\n    });\n  });\n});\n\n\n\n  \n    \n      app/templates/photo/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cdiv class=\"photo\"\u003e\n  {{body}}\n\u003c/div\u003e\n\n\u003cp\u003e{{#link-to \"photos.photo.comment\" primaryComment}}Main Comment{{/link-to}}\u003c/p\u003e\n\n\n\nIf you specify only one model, it will represent the innermost dynamic segment :comment_id.\nThe :photo_id segment will use the current photo.\n\nAlternatively, you could pass both a photo's ID and a comment to the helper:\n\n  \n    \n      app/templates/photo/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cp\u003e\n  {{#link-to 'photo.comment' 5 primaryComment}}\n    Main Comment for the Next Photo\n  {{/link-to}}\n\u003c/p\u003e\n\n\n\nIn the above example, the model hook for PhotoRoute will run with params.photo_id = 5.  The model hook for\nCommentRoute won't run since you supplied a model object for the comment segment. The comment's id will\npopulate the url according to CommentRoute's serialize hook.\nUsing link-to as an inline helper\nIn addition to being used as a block expression, the link-to helper\ncan also be used in inline form by specifying the link text as the first\nargument to the helper:\n\n  1\n2\n\n  A link in {{#link-to \"index\"}}Block Expression Form{{/link-to}},\nand a link in {{link-to \"Inline Form\" \"index\"}}.\n\n\n\nThe output of the above would be:\n\n  1\n2\n\n  A link in \u003ca href=\"/\"\u003eBlock Expression Form\u003c/a\u003e,\nand a link in \u003ca href=\"/\"\u003eInline Form\u003c/a\u003e.\n\n\nAdding additional attributes on a link\nWhen generating a link you might want to set additional attributes for it. You can do this with additional\narguments to the link-to helper:\n\n  1\n2\n3\n\n  \u003cp\u003e\n  {{link-to \"Edit this photo\" \"photo.edit\" photo class=\"btn btn-primary\"}}\n\u003c/p\u003e\n\n\n\nMany of the common HTML properties you would want to use like class, and rel will work. When\nadding class names, Ember will also apply the standard ember-view and possibly active class names.\nReplacing history entries\nThe default behavior for link-to is to add entries to the browser's history\nwhen transitioning between the routes. However, to replace the current entry in\nthe browser's history you can use the replace=true option:\n\n  1\n2\n3\n4\n5\n\n  \u003cp\u003e\n  {{#link-to \"photo.comment\" 5 primaryComment replace=true}}\n    Main Comment for the Next Photo\n  {{/link-to}}\n\u003c/p\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4d51ca61c042a6e0f4dfd8e0cdb116ed","fields":[{"name":"title","value":"Writing Helpers","type":"string"},{"name":"url","value":"/templates/writing-helpers/","type":"enum"},{"name":"body","value":"Helpers allow you to add additional functionality to your\ntemplates beyond what is included out-of-the-box in Ember. Helpers are\nmost useful for transforming raw values from models and components into\na format more appropriate for your users.\n\nFor example, imagine we have an Invoice model that contains a\ntotalDue attribute, which represents the total amount due for that\ninvoice.  Because we do not want our company to go out of business due\nto strange JavaScript rounding errors, we store this value in cents\ninstead of a floating point dollar value.\n\nHowever, if we display dollar values to our users as \"100\" instead of\n\"$1.00\", they may be very confused. We can write a helper to\nformat these values into the appropriate human-readable form.\n\nLet's create a format-currency helper that takes an integer count of\ncents and turns it into formatted dollars.\n\nTo use the format-currency helper, you call it using curly braces in\nyour template:\n\n  1\n\n  Your total is {{format-currency model.totalDue}}.\n\n\n\nLet's now implement the helper. Helpers are just functions that take\none or more inputs and return a single output that should be put into\nthe HTML.\n\nTo add a new helper, create a file with the name of the helper you want\n(e.g. format-currency.js) in your application's helpers directory.\nYou can also have Ember generate the file for you from the command line:\n\n  1\n\n  ember generate helper format-currency\n\n\n\nThat file should export a function wrapped with Ember.Helper.helper():\n\n  \n    \n      app/helpers/format-currency.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Helper.helper(function(params) {\n  let value = params[0],\n      dollars = Math.floor(value / 100),\n      cents = value % 100,\n      sign = '$';\n\n  if (cents.toString().length === 1) { cents = '0' + cents; }\n  return `${sign}${dollars}.${cents}`;\n});\n\n\n\nIn this example, the function receives a dollar amount in cents as the first\nparameter (params[0]). We then use regular JavaScript to turn the\ncount of cents into a formatted string, like \"$5.00\".\n\nWhenever you use your helper in a template, Ember will call this\nfunction and insert whatever you return from the helper into the DOM.\n\nSo, for example, if we had a template like this where we pass a value in\ncents:\n\n  1\n\n  Your total is {{format-currency 250}}.\n\n\n\nEmber would replace the content inside the {{ }} with the formatted\namount:\n\n  1\n\n  Your total is $2.50.\n\n\n\nWhenever the arguments you've passed to a helper change, whether they\ncome from a model or a component, Ember will automatically call your\nhelper again with the new values and keep the DOM up-to-date.\nHelper Names\nUnlike components, helpers do not require a dash (-) character in\ntheir name.\nHelper Arguments\nYou can pass one or more arguments to  which can be used\ninside the function. In the above example, we passed the amount in cents\nas the first and only argument.\n\nTo pass multiple arguments to a helper, add them as a space-separated\nlist after the helper name:\n\n  1\n\n  {{my-helper \"hello\" \"world\"}}\n\n\n\nAn array of these arguments is passed to the helper function:\n\n  \n    \n      app/helpers/my-helper.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Helper.helper(function(params) {\n  let arg1 = params[0];\n  let arg2 = params[1];\n\n  console.log(arg1); // =\u003e \"hello\"\n  console.log(arg2); // =\u003e \"world\"\n});\n\n\n\nYou can use JavaScript's destructuring assignment shorthand to clean up\nthe code. This example is equivalent to the above example (note the function signature):\n\n  \n    \n      app/helpers/my-helper.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Helper.helper(function([arg1, arg2]) {\n  console.log(arg1); // =\u003e \"hello\"\n  console.log(arg2); // =\u003e \"world\"\n});\n\n\nNamed Arguments\nNormal arguments are useful for passing data to be transformed into\nhelper functions. However, because the order in which you pass arguments\nmatters, it is usually best not to have helpers take more than one or\ntwo of them.\n\nThat said, sometimes you may want to make behavior of helpers\nconfigurable by the developers that call them from their templates. For\nexample, let's abandon our Americentric ways and update our\nformat-currency helper to take an optional configuration for which\ncurrency symbol to display.\n\nHelpers allow you to pass named arguments as a JavaScript\nobject that contains the name of the argument along with an associated\nvalue.  The order in which named arguments are supplied does not affect\nfunctionality.\n\nIn this example, we can pass a sign argument to our format-currency\nhelper:\n\n  1\n\n  {{format-currency 350 sign=\"\"}}\n\n\n\nWe'd like our helper to print pounds sterling rather than US dollars:\n\n  1\n\n  3.50\n\n\n\nThe object containing named arguments is passed as the second argument\nto the helper function.  Here is our example from above, updated to\nsupport the optional sign option:\n\n  \n    \n      app/helpers/format-currency.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Helper.helper(function(params, namedArgs) {\n  let value = params[0],\n      dollars = Math.floor(value / 100),\n      cents = value % 100,\n      sign = namedArgs.sign === undefined ? '$' : namedArgs.sign;\n\n  if (cents.toString().length === 1) { cents = '0' + cents; }\n  return `${sign}${dollars}.${cents}`;\n});\n\n\n\nYou can pass as many named arguments as you'd like. They get added to the\nnamedArgs argument passed to the function:\n\n  1\n\n  {{my-helper option1=\"hello\" option2=\"world\" option3=\"goodbye cruel world\"}}\n\n\n\n  \n    \n      app/helpers/my-helper.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Helper.helper(function(params, namedArgs) {\n  console.log(namedArgs.option1); // =\u003e \"hello\"\n  console.log(namedArgs.option2); // =\u003e \"world\"\n  console.log(namedArgs.option3); // =\u003e \"goodbye cruel world\"\n});\n\n\n\nYou can use JavaScript's destructuring assignment shorthand in this case\nas well to clean up the above code:\n\n  \n    \n      app/helpers/my-helper.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Helper.helper(function(params, { option1, option2, option3 }) {\n  console.log(option1); // =\u003e \"hello\"\n  console.log(option2); // =\u003e \"world\"\n  console.log(option3); // =\u003e \"goodbye cruel world\"\n});\n\n\n\nIn sum, arguments are good for passing values:\n\n  1\n\n  {{format-date currentDate}}\n\n\n\nHashes are useful for configuring the behavior of a helper:\n\n  1\n\n  {{print-current-date format=\"YYYY MM DD\"}}\n\n\n\nYou can have as many of both as you want, so long as the parameters come\nfirst:\n\n  1\n\n  {{format-date-and-time date time format=\"YYYY MM DD h:mm\" locale=\"en\"}}\n\n\n\nThe above example contains two arguments:\n\n\ndate\ntime\n\n\nAnd two named arguments:\n\n\nformat=\"YYY MM DD h:mm\"\nlocale=\"en\"\n\nClass-based Helpers\nBy default, helpers are stateless. They are passed inputs (parameters\nand a hash), they perform an operation on those inputs, and return a\nsingle output. They have no side-effects and don't save any information\nthat is used on subsequent runs of the function.\n\nIn some situations, however, you may need to write a helper that interacts with\nthe rest of your application. You can create class-based helpers that have\naccess to services in your application, and can optionally save state as well,\nalthough this is usually unnecessary and error-prone.\n\nTo create a class-based helper, rather than exporting a simple function, you\nshould export a subclass of Ember.Helper. Helper classes must contain a\ncompute method that behaves the same as the function passed to\nEmber.Helper.helper.  In order to access a service, you must first inject it\ninto the class-based helper.  Once added, you can call the service's methods or\naccess its properties from within the compute() method.\n\nTo exemplify, let's make a helper utilizing an authentication service that\nwelcomes users by their name if they're logged in:\n\n  \n    \n      app/helpers/is-authenticated.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Helper.extend({\n  authentication: Ember.inject.service(),\n  compute() {\n    let authentication = this.get('authentication');\n\n    if (authentication.get('isAuthenticated')) {\n      return 'Welcome back, ' + authentication.get('username');\n    } else {\n      return 'Not logged in';\n    }\n  }\n});\n\n\n\nIn fact, we could also refactor the above stateless helper into a class-based\nhelper just by making the function into a compute method on the class:\n\n  \n    \n      app/helpers/format-currency.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Helper.extend({\n  compute(params, hash) {\n    let value = params[0],\n        dollars = Math.floor(value / 100),\n        cents = value % 100,\n        sign = hash.sign === undefined ? '$' : hash.sign;\n\n    if (cents.toString().length === 1) { cents = '0' + cents; }\n    return `${sign}${dollars}.${cents}`;\n  }\n});\n\n\n\nThis is exactly equivalent to the example above. You can think of the\nfunction version as a shorthand for the longer class form if it does not\nrequire any state.\nEscaping HTML Content\nTo protect your application from cross-site scripting attacks (XSS),\nEmber automatically escapes any value you return from a helper so that\nthe browser will not interpret it as HTML.\n\nFor example, here's a make-bold helper that returns a string containing HTML:\n\n  \n    \n      app/helpers/make-bold.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Helper.helper(function(params) {\n  return `\u003cb\u003e${params[0]}\u003c/b\u003e`;\n});\n\n\n\nYou can invoke it like this:\n\n  1\n\n  {{make-bold \"Hello world\"}}\n\n\n\nEmber will escape the HTML tags, like this:\n\n  1\n\n  \u0026lt;b\u0026gt;Hello world\u0026lt;/b\u0026gt;\n\n\n\nThis shows the literal string \u003cb\u003eHello world\u003c/b\u003e to the user, rather\nthan the text in bold as you probably intended. We can tell Ember not to\nescape the return value (that is, that it is safe) by using the\nhtmlSafe string utility:\n\n  \n    \n      app/helpers/make-bold.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Helper.helper(function(params) {\n  return Ember.String.htmlSafe(`\u003cb\u003e${params[0]}\u003c/b\u003e`);\n});\n\n\n\nIf you return a SafeString (a string that has been wrapped in a call\nto htmlSafe), Ember knows that you have vouched on its behalf that it\ncontains no malicious HTML.\n\nHowever, note that in the above code we may have just inadvertently\nintroduced an XSS vulnerability into our application! By blindly marking\nthe string as safe, a malicious user could get their own HTML into our\napp, allowing them to do things like access sensitive customer data.\n\nFor example, imagine that we have a chat app  and use our make-bold\nhelper to welcome the new users into the channel:\n\n  1\n\n  Welcome back! {{make-bold model.firstName}} has joined the channel.\n\n\n\nNow a malicious user simply needs to set their firstName to a string\ncontaining HTML (like a \u003cscript\u003e tag that sends private customer data\nto their server, for example) and every user in that chat room has been\ncompromised.\n\nIn general, you should prefer using components if you are wrapping\ncontent in HTML. However, if you really want to include a mix of HTML\nand values from models in what you return from the helper, make sure you\nescape anything that may have come from an untrusted user with the\nescapeExpression utility:\n\n  \n    \n      app/helpers/make-bold.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Helper.helper(function(params) {\n  let value = Ember.Handlebars.Utils.escapeExpression(params[0]);\n  return Ember.String.htmlSafe(`\u003cb\u003e${value}\u003c/b\u003e`);\n});\n\n\n\nNow the value passed into the helper has its HTML escaped, but the trusted\n\u003cb\u003e tags that we want to wrap the value in are not escaped. A\nmalicious user setting their firstName to something containing HTML\nwould just see this:\n\n  1\n2\n\n  Welcome back! \u003cb\u003e\u0026lt;script\ntype=\"javascript\"\u0026gt;alert('pwned!');\u0026lt;/script\u0026gt;\u003c/b\u003e has joined the channel.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6b92476d3f19a3ac5f6ea85e474595d8","fields":[{"name":"title","value":"Acceptance Tests","type":"string"},{"name":"url","value":"/testing/acceptance/","type":"enum"},{"name":"body","value":"To create an acceptance test, run ember generate acceptance-test \u003cname\u003e.\nFor example:\n\n  1\n\n  ember g acceptance-test login\n\n\n\nThis generates this file:\n\n  \n    \n      tests/acceptance/login-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  import Ember from 'ember';\nimport { module, test } from 'qunit';\nimport startApp from 'testing-guide-examples/tests/helpers/start-app';\n\nlet application;\n\nmodule('Acceptance | login', {\n  beforeEach() {\n    application = startApp();\n  },\n\n  afterEach() {\n    Ember.run(application, 'destroy');\n  }\n});\n\ntest('visiting /login', function(assert) {\n  visit('/login');\n  andThen(() =\u003e assert.equal(currentURL(), '/login'));\n});\n\n\n\nMost of this is boilerplate test setup and teardown. The last few lines, within\nthe function test, contain an example test.\n\nAlmost every test has a pattern of visiting a route, interacting with the page\n(using the helpers), and checking for expected changes in the DOM.\n\nFor example:\n\n  \n    \n      tests/acceptance/new-post-appears-first-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  test('should add new post', function(assert) {\n  visit('/posts/new');\n  fillIn('input.title', 'My new post');\n  click('button.submit');\n  andThen(() =\u003e assert.equal(find('ul.posts li:first').text(), 'My new post'));\n});\n\n\nTest Helpers\nOne of the major issues in testing web applications is that all code is\nevent-driven, therefore has the potential to be asynchronous (i.e. output can\nhappen out of sequence from input). This has the ramification that code can be\nexecuted in any order.\n\nAn example may help here: Let's say a user clicks two buttons, one after another\nand both load data from different servers. They take different times to respond.\n\nWhen writing your tests, you need to be keenly aware of the fact that you cannot\nbe sure that the response will return immediately after you make your requests,\ntherefore your assertion code (the \"tester\") needs to wait for the thing being\ntested (the \"testee\") to be in a synchronized state. In the example above, that\nwould be when both servers have responded and the test code can go about its\nbusiness checking the data (whether it is mock data, or real data).\n\nThis is why all Ember's test helpers are wrapped in code that ensures Ember is\nback in a synchronized state when it makes its assertions. It saves you from\nhaving to wrap everything in code that does that, and it makes it easier to read\nyour tests because there's less boilerplate in them.\n\nEmber includes several helpers to facilitate acceptance testing. There are two\ntypes of helpers: asynchronous and synchronous.\nAsynchronous Helpers\nAsynchronous helpers are \"aware\" of (and wait for) asynchronous behavior within\nyour application, making it much easier to write deterministic tests.\n\nAlso, these helpers register themselves in the order that you call them and will\nbe run in a chain; each one is only called after the previous one finishes. You can rest assured, therefore, that the order you call them in will also\nbe their execution order, and that the previous helper has finished before the\nnext one starts.\n\n\nclick(selector)\n\n\nClicks an element and triggers any actions triggered by the element's click\nevent and returns a promise that fulfills when all resulting async behavior\nis complete.\n\nfillIn(selector, value)\n\n\nFills in the selected input with the given value and returns a promise that\nfulfills when all resulting async behavior is complete. Works with \u003cselect\u003e elements as well as \u003cinput\u003e elements. Keep in mind that with \u003cselect\u003e elements, value must be set to the value of the \u003coption\u003e tag, rather than its content (for example, true rather than \"Yes\").\n\nkeyEvent(selector, type, keyCode)\n\n\nSimulates a key event type, e.g. keypress, keydown, keyup with the\ndesired keyCode on element found by the selector.\n\ntriggerEvent(selector, type, options)\n\n\nTriggers the given event, e.g. blur, dblclick on the element identified\nby the provided selector.\n\nvisit(url)\n\n\nVisits the given route and returns a promise that fulfills when all resulting\nasync behavior is complete.\n\n\nSynchronous Helpers\nSynchronous helpers are performed immediately when triggered.\n\n\ncurrentPath()\n\n\nReturns the current path.\n\ncurrentRouteName()\n\n\nReturns the currently active route name.\n\ncurrentURL()\n\n\nReturns the current URL.\n\nfind(selector, context)\n\n\nFinds an element within the app's root element and within the context\n(optional). Scoping to the root element is especially useful to avoid\nconflicts with the test framework's reporter, and this is done by default\nif the context is not specified.\n\n\nWait Helpers\nThe andThen helper will wait for all preceding asynchronous helpers to\ncomplete prior to progressing forward. Let's take a look at the following\nexample.\n\n  \n    \n      tests/acceptance/new-post-appears-first-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  test('should add new post', function(assert) {\n  visit('/posts/new');\n  fillIn('input.title', 'My new post');\n  click('button.submit');\n  andThen(() =\u003e assert.equal(find('ul.posts li:first').text(), 'My new post'));\n});\n\n\n\nFirst we visit the new posts URL \"/posts/new\", enter the text \"My new post\"\ninto an input control with the CSS class \"title\", and click on a button whose\nclass is \"submit\".\n\nWe then make a call to the andThen helper which will wait for the preceding\nasynchronous test helpers to complete (specifically, andThen will only be\ncalled after the new posts URL was visited, the text filled in and the\nsubmit button was clicked, and the browser has returned from doing whatever\nthose actions required). Note andThen has a single argument of the function\nthat contains the code to execute after the other test helpers have finished.\n\nIn the andThen helper, we finally make our call to assert.equal which makes an\nassertion that the text found in the first li of the ul whose class is \"posts\"\nis equal to \"My new post\".\nCustom Test Helpers\nFor creating your own test helper, just run ember generate test-helper\n\u003chelper-name\u003e. Here is the result of running ember g test-helper\nshouldHaveElementWithCount:\n\n  \n    \n      tests/helpers/should-have-element-with-count.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Test.registerAsyncHelper(\n    'shouldHaveElementWithCount', function(app) {\n});\n\n\n\nEmber.Test.registerAsyncHelper and Ember.Test.registerHelper are used to\nregister test helpers that will be injected when startApp is\ncalled. The difference between Ember.Test.registerHelper and\nEmber.Test.registerAsyncHelper is that the latter will not run until any\nprevious async helper has completed and any subsequent async helper will wait\nfor it to finish before running.\n\nThe helper method will always be called with the current Application as the\nfirst parameter. Other parameters need to be provided when calling the helper. Helpers need to be registered prior to calling\nstartApp, but ember-cli will take care of it for you.\n\nHere is an example of a non-async helper:\n\n  \n    \n      tests/helpers/should-have-element-with-count.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Test.registerHelper('shouldHaveElementWithCount', function(app, assert, selector, n, context) {\n  const el = findWithAssert(selector, context);\n  const count = el.length;\n  assert.equal(n, count, `found ${count} times`);\n});\n// shouldHaveElementWithCount(assert, 'ul li', 3);\n\n\n\nHere is an example of an async helper:\n\n  \n    \n      tests/helpers/dblclick.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Test.registerAsyncHelper('dblclick',\n  function(app, assert, selector, context) {\n    let $el = findWithAssert(selector, context);\n    Ember.run(() =\u003e $el.dblclick());\n  }\n);\n\n// dblclick('#person-1')\n\n\n\nAsync helpers also come in handy when you want to group interaction\ninto one helper. For example:\n\n  \n    \n      tests/helpers/add-contact.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Test.registerAsyncHelper('addContact',\n  function(app, assert, name) {\n    fillIn('#name', name);\n    click('button.create');\n  }\n);\n\n// addContact('Bob');\n// addContact('Dan');\n\n\n\nFinally, don't forget to add your helpers in tests/.jshintrc and in\ntests/helpers/start-app.js. In tests/.jshintrc you need to add it in the\npredef section, otherwise you will get failing jshint tests:\n\n  \n    \n      tests/.jshintc\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  {\n  \"predef\": [\n    \"document\",\n    \"window\",\n    \"location\",\n    ...\n    \"shouldHaveElementWithCount\",\n    \"dblclick\",\n    \"addContact\"\n  ],\n  ...\n}\n\n\n\nIn tests/helpers/start-app.js you just need to import the helper file: it\nwill be registered then.\n\n  \n    \n      tests/helpers/start-app.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import Ember from 'ember';\nimport Application from '../../app';\nimport Router from '../../router';\nimport config from '../../config/environment';\nimport './should-have-element-with-count';\nimport './dblclick';\nimport './add-contact';\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d111ada688dff43a36c7d27aea287dc5","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/testing/","type":"enum"},{"name":"body","value":"Testing is a core part of the Ember framework and its development cycle.\n\nLet's assume you are writing an Ember application which will serve as a blog.\nThis application would likely include models such as user and post. It would\nalso include interactions such as login and create post. Let's finally\nassume that you would like to have automated tests in place for your application.\n\nThere are three different classifications of tests that you will need:\nAcceptance, Unit, and Integration.\nAcceptance Tests\nAcceptance tests are used to test user interaction and application flow.  The tests interact\nwith the application in the same ways that a user would, by doing things like filling out\nform fields and clicking buttons.  Acceptance tests ensure that the features within\na project are basically functional, and are valuable in ensuring the core features of a\nproject have not regressed, and that the project's goals are being met.\n\nIn the example scenario above, some acceptance tests one might write are:\n\n\nA user is able to log in via the login form.\nA user is able to create a blog post.\nAfter saving a new post successfully, a user is then shown the list of prior posts.\nA visitor does not have access to the admin panel.\n\nUnit Tests\nUnit tests are used to test isolated chunks of functionality, or \"units\".\nThey can be written against any isolated application logic.\n\nSome specific examples of units tests are:\n\n\nA fullname attribute is computed which is the aggregate of its first and last.\nThe serializer properly converts the blog request payload into a blog post model object.\nBlog dates are properly formatted.\n\nIntegration Tests\nIntegration tests serve as a middle ground between acceptance tests, which only interact\nwith the full system through user endpoints, and unit tests, which interact with specific\ncode algorithms on a micro level. Integration tests verify interactions between various\nparts of the application, such as behavior between UI controls.  They are valuable\nin ensuring data and actions are properly passed between different parts of the system, and\nprovide confidence that parts of the system will work within the application under multiple\nscenarios.\n\nIt is recommended that components be tested with integration tests because the component\ninteracts with the system in the same way that it will within the context of the application,\nincluding being rendered from a template and receiving Ember's lifecycle hooks.\n\nExamples of integration tests are:\n\n\nAn author's full name and date are properly displayed in a blog post.\nA user is prevented from typing more than 50 characters into post's title field.\nSubmitting a post without a title displays a red validation state on the field and gives\nthe user text indicating that the title is required.\nThe blog post list scrolls to position a new post at the top of the viewport.\n\nTesting Frameworks\nQUnit is the default testing framework for this guide, but others are supported through\nthird-party addons.\nHow to Run Your Tests\nRun your tests with ember test on the command-line. You can re-run your tests on every\nfile-change with ember test --server. Another way to run the tests when you are running\na local server (started by running ember server), is to navigate your browser to the address\nof your local server, which by default is http://localhost:4200/tests.\nThese commands run your tests using Testem to make testing multiple browsers very easy. You\ncan configure Testem using the testem.json file in your application root.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a0e26dbd7878af23525081f7441c1b0","fields":[{"name":"title","value":"Testing Components","type":"string"},{"name":"url","value":"/testing/testing-components/","type":"enum"},{"name":"body","value":"Components can be tested with integration tests using the moduleForComponent helper.\n\nLet's assume we have a component with a style property that is updated\nwhenever the value for its name property changes. The style attribute of the\ncomponent is bound to its style property.\n\n\nYou can follow along by generating your own component with ember generate\ncomponent pretty-color.\n\n\n  \n    \n      app/components/pretty-color.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Component.extend({\n  attributeBindings: ['style'],\n\n  style: Ember.computed('name', function() {\n    const name = this.get('name');\n    return `color: ${name}`;\n  })\n});\n\n\n\n  \n    \n      app/templates/components/pretty-color.hbs\n    \n  \n\n  1\n\n  Pretty Color: {{name}}\n\n\n\nThe moduleForComponent helper will find the component by name (pretty-color)\nand its template (if available).  Make sure to set integration: true to enable\nintegration test capability.\n\n  \n    \n      tests/integration/components/pretty-color-test.js\n    \n  \n\n  1\n2\n3\n\n  moduleForComponent('pretty-color', 'Integration | Component | pretty color', {\n  integration: true\n});\n\n\n\nEach test following the moduleForComponent call has access to the render()\nfunction, which lets us create a new instance of the component by declaring\nthe component in template syntax, as we would in our application.\n\nWe can test that changing the component's name property updates the\ncomponent's style attribute and is reflected in the  rendered HTML:\n\n  \n    \n      tests/integration/components/pretty-color-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  test('should change colors', function(assert) {\n  assert.expect(2);\n\n  // set the outer context to red\n  this.set('colorValue', 'red');\n\n  this.render(hbs`{{pretty-color name=colorValue}}`);\n\n  assert.equal(this.$('div').attr('style'), 'color: red', 'starts as red');\n\n  this.set('colorValue', 'blue');\n\n  assert.equal(this.$('div').attr('style'), 'color: blue', 'updates to blue');\n});\n\n\n\nWe might also test this component to ensure that the content of its template is\nbeing rendered properly:\n\n  \n    \n      tests/integration/components/pretty-color-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  test('should be rendered with its color name', function(assert) {\n  assert.expect(2);\n\n  this.set('colorValue', 'orange');\n\n  this.render(hbs`{{pretty-color name=colorValue}}`);\n\n  assert.equal(this.$().text().trim(), 'Pretty Color: orange', 'text starts as orange');\n\n  this.set('colorValue', 'green');\n\n  assert.equal(this.$().text().trim(), 'Pretty Color: green', 'text switches to green');\n\n});\n\n\nTesting User Interaction\nComponents are a great way to create powerful, interactive, and self-contained\ncustom HTML elements. It is important to test the component's methods and the\nuser's interaction with the component.\n\nImagine you have the following component that changes its title when a button is\nclicked on:\n\n\nYou can follow along by generating your own component with ember generate\ncomponent magic-title.\n\n\n  \n    \n      app/components/magic-title.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Component.extend({\n  title: 'Hello World',\n\n  actions: {\n    updateTitle() {\n      this.set('title', 'This is Magic');\n    }\n  }\n});\n\n\n\n  \n    \n      app/templates/components/magic-title.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003ch2\u003e{{title}}\u003c/h2\u003e\n\n\u003cbutton {{action \"updateTitle\"}}\u003e\n  Update Title\n\u003c/button\u003e\n\n\n\njQuery triggers can be used to simulate user interaction and test that the title\nis updated when the button is clicked on:\n\n  \n    \n      tests/integration/components/magic-title-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  test('should update title on button click', function(assert) {\n  assert.expect(2);\n\n  this.render(hbs`{{magic-title}}`);\n\n  assert.equal(this.$('h2').text(), 'Hello World', 'initial text is hello world');\n\n  //Click on the button\n  this.$('button').click();\n\n  assert.equal(this.$('h2').text(), 'This is Magic', 'title changes after click');\n});\n\n\nTesting Actions\nComponents starting in Ember 2 utilize closure actions. Closure actions allow components\nto directly invoke functions provided outer components.\n\nFor example, imagine you have a comment form component that invokes a\nsubmitComment action when the form is submitted, passing along the form's data:\n\n\nYou can follow along by generating your own component with ember generate\ncomponent comment-form.\n\n\n  \n    \n      app/components/comment-form.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Component.extend({\n  comment: '',\n\n  actions: {\n    submitComment() {\n      this.attrs.submitComment({ comment: this.get('comment') });\n    }\n  }\n});\n\n\n\n  \n    \n      app/templates/components/comment-form.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  \u003cform {{action \"submitComment\" on=\"submit\"}}\u003e\n  \u003clabel\u003eComment:\u003c/label\u003e\n  {{textarea value=comment}}\n\n  \u003cinput type=\"submit\" value=\"Submit\"/\u003e\n\u003c/form\u003e\n\n\n\nHere's an example test that asserts that the specified externalAction function\nis invoked when the component's internal submitComment action is triggered by making use\nof a test double (dummy function):\n\n  \n    \n      tests/integration/components/comment-form-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  test('should trigger external action on form submit', function(assert) {\n\n  // test double for the external action\n  this.set('externalAction', (attributes) =\u003e assert.deepEqual(attributes, { comment: 'You are not a wizard!' }, 'submitted input value gets passed to external action'));\n\n  this.render(hbs`{{comment-form submitComment=(action externalAction)}}`);\n\n  // fill out the form and force an onchange\n  this.$('textarea').val('You are not a wizard!');\n  this.$('textarea').change();\n\n  // click the button to submit the form\n  this.$('input').click();\n});\n\n\nStubbing Services\nIn cases where components have dependencies on Ember services, it is possible to stub these\ndependencies for integration tests. Stub Ember services by using the built-in register\nfunction to register your stub service in place of the default.\n\nImagine you have the following component that uses a location service to display the city\nand country of your current location:\n\n\nYou can follow along by generating your own component with ember generate\ncomponent location-indicator.\n\n\n  \n    \n      app/components/location-indicator.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Component.extend({\n  locationService: Ember.inject.service('location-service'),\n\n  //when the coordinates change, call the location service to evaluate what the city and country would be\n  city: Ember.computed('locationService.currentLocation', function () {\n    return this.get('locationService').getCurrentCity();\n  }),\n\n  country: Ember.computed('locationService.currentLocation', function () {\n    return this.get('locationService').getCurrentCountry();\n  })\n});\n\n\n\n  \n    \n      app/templates/components/location-indicator.hbs\n    \n  \n\n  1\n\n  You currently are located in {{city}}, {{country}}\n\n\n\nTo stub the location service in your test, create a local stub object that extends\nEmber.Service, and register the stub as the service your tests need in the\nbeforeEach function.  In this case we initially force location to New York.\n\n  \n    \n      tests/integration/components/location-indicator-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n  import { moduleForComponent, test } from 'ember-qunit';\nimport hbs from 'htmlbars-inline-precompile';\nimport Ember from 'ember';\n\n//Stub location service\nconst locationStub = Ember.Service.extend({\n  city: 'New York',\n  country: 'USA',\n  currentLocation: {\n    x: 1234,\n    y: 5678\n  },\n\n  getCurrentCity() {\n    return this.get('city');\n  },\n  getCurrentCountry() {\n    return this.get('country');\n  }\n});\n\nmoduleForComponent('location-indicator', 'Integration | Component | location indicator', {\n  integration: true,\n\n  beforeEach: function () {\n    this.register('service:location-service', locationStub);\n    this.inject.service('location-service', { as: 'location' });\n  }\n});\n\n\n\nOnce the stub service is registered the test simply needs to check that the stub data that\nis being returned from the service is reflected in the component output.\n\n  \n    \n      tests/integration/components/location-indicator-test.js\n    \n  \n\n  1\n2\n3\n4\n\n  test('should reveal current location', function(assert) {\n  this.render(hbs`{{location-indicator}}`);\n  assert.equal(this.$().text().trim(), 'You currently are located in New York, USA');\n});\n\n\n\nIn the next example, we'll add another test that validates that the display changes\nwhen we modify the values on the service.\n\n  \n    \n      tests/integration/components/location-indicator-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  test('should change displayed location when current location changes', function (assert) {\n  this.render(hbs`{{location-indicator}}`);\n  assert.equal(this.$().text().trim(), 'You currently are located in New York, USA', 'origin location should display');\n  this.set('location.city', 'Beijing');\n  this.set('location.country', 'China');\n  this.set('location.currentLocation', { x: 11111, y: 222222 });\n  assert.equal(this.$().text().trim(), 'You currently are located in Beijing, China', 'location display should change');\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b52674636f495b78ec905a98c63e1233","fields":[{"name":"title","value":"Testing Controllers","type":"string"},{"name":"url","value":"/testing/testing-controllers/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown\nin Unit Testing Basics because Ember.Controller extends Ember.Object.\n\nUnit testing controllers is very simple using the unit test helper which is part\nof the ember-qunit framework.\nTesting Controller Actions\nHere we have a controller PostsController with some computed properties and an\naction setProps.\n\n\nYou can follow along by generating your own controller with ember generate\ncontroller posts.\n\n\n  \n    \n      app/controllers/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Controller.extend({\n  propA: 'You need to write tests',\n  propB: 'And write one for me too',\n\n  setPropB(str) {\n    this.set('propB', str);\n  },\n\n  actions: {\n    setProps(str) {\n      this.set('propA', 'Testing is cool');\n      this.setPropB(str);\n    }\n  }\n});\n\n\n\nsetProps sets a property on the controller and also calls a method. In our \ngenerated test, ember-cli already uses the moduleFor helper to setup a test \ncontainer:\n\n  \n    \n      tests/unit/controllers/posts-test.js\n    \n  \n\n  1\n2\n\n  moduleFor('controller:posts', {\n});\n\n\n\nNext we use this.subject() to get an instance of the PostsController and\nwrite a test to check the action. this.subject() is a helper method from the\nember-qunit library that returns a singleton instance of the module set up\nusing moduleFor.\n\n  \n    \n      tests/unit/controllers/posts-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  test('should update A and B on setProps action', function(assert) {\n  assert.expect(4);\n\n  // get the controller instance\n  const ctrl = this.subject();\n\n  // check the properties before the action is triggered\n  assert.equal(ctrl.get('propA'), 'You need to write tests', 'propA initialized');\n  assert.equal(ctrl.get('propB'), 'And write one for me too', 'propB initialized');\n\n  // trigger the action on the controller by using the `send` method,\n  // passing in any params that our action may be expecting\n  ctrl.send('setProps', 'Testing Rocks!');\n\n  // finally we assert that our values have been updated\n  // by triggering our action.\n  assert.equal(ctrl.get('propA'), 'Testing is cool', 'propA updated');\n  assert.equal(ctrl.get('propB'), 'Testing Rocks!', 'propB updated');\n});\n\n\nTesting Controller Needs\nSometimes controllers have dependencies on other controllers. This is\naccomplished by injecting one controller into another. For example, here are two simple controllers. The\nCommentsController uses the PostController via inject:\n\n\nYou can follow along by generating your own controller with ember generate\ncontroller post, and ember generate controller comments.\n\n\n  \n    \n      app/controllers/post.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Controller.extend({\n  title: Ember.computed.alias('model.title')\n});\n\n\n\n  \n    \n      app/controllers/comments.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  post: Ember.inject.controller(),\n  title: Ember.computed.alias('post.title')\n});\n\n\n\nThis time when we setup our moduleFor we need to pass an options object as\nour third argument that has the controller's needs.\n\n  \n    \n      tests/unit/controllers/comments-test.js\n    \n  \n\n  1\n2\n3\n\n  moduleFor('controller:comments', 'Comments Controller', {\n  needs: ['controller:post']\n});\n\n\n\nNow let's write a test that sets a property on our post model in the\nPostController that would be available on the CommentsController.\n\n  \n    \n      tests/unit/controllers/comments-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  test('should modify the post model', function(assert) {\n  assert.expect(2);\n\n  // grab an instance of `CommentsController` and `PostController`\n  const ctrl = this.subject();\n  const postCtrl = ctrl.get('post');\n\n  // wrap the test in the run loop because we are dealing with async functions\n  Ember.run(function() {\n\n    // set a generic model on the post controller\n    postCtrl.set('model', Ember.Object.create({ title: 'foo' }));\n\n    // check the values before we modify the post\n    assert.equal(ctrl.get('title'), 'foo', 'title is set');\n\n    // modify the title of the post\n    postCtrl.get('model').set('title', 'bar');\n\n    // assert that the controllers title has changed\n    assert.equal(ctrl.get('title'), 'bar', 'title is updated');\n  });\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9e4b1c3650cd96bd8485e0b98d722871","fields":[{"name":"title","value":"Testing Models","type":"string"},{"name":"url","value":"/testing/testing-models/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown\nin Unit Testing Basics because DS.Model extends Ember.Object.\n\nEmber Data Models can be tested using the moduleForModel helper.\n\nLet's assume we have a Player model that has level and levelName\nattributes. We want to call levelUp() to increment the level and assign a\nnew levelName when the player reaches level 5.\n\n\nYou can follow along by generating your own model with ember generate\nmodel player.\n\n\n  \n    \n      app/models/player.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default DS.Model.extend({\n  level:     DS.attr('number', { defaultValue: 0 }),\n  levelName: DS.attr('string', { defaultValue: 'Noob' }),\n\n  levelUp() {\n    var newLevel = this.incrementProperty('level');\n    if (newLevel === 5) {\n      this.set('levelName', 'Professional');\n    }\n  }\n});\n\n\n\nNow let's create a test which will call levelUp on the player when they are\nlevel 4 to assert that the levelName changes. We will use moduleForModel:\n\n  \n    \n      tests/unit/models/player-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  import { moduleForModel, test } from 'ember-qunit';\nimport Ember from 'ember';\n\nmoduleForModel('player', 'Unit | Model | player', {\n  // Specify the other units that are required for this test.\n  needs: []\n});\n\ntest('should increment level when told to', function(assert) {\n  // this.subject aliases the createRecord method on the model\n  const player = this.subject({ level: 4 });\n\n  // wrap asynchronous call in run loop\n  Ember.run(() =\u003e player.levelUp());\n\n  assert.equal(player.get('level'), 5, 'level gets incremented');\n  assert.equal(player.get('levelName'), 'Professional', 'new level is called professional');\n});\n\n\nTesting Relationships\nFor relationships you probably only want to test that the relationship\ndeclarations are setup properly.\n\nAssume that a User can own a Profile.\n\n\nYou can follow along by generating your own user and profile models with ember\ngenerate model user and ember generate model profile.\n\n\n  \n    \n      app/models/profile.js\n    \n  \n\n  1\n2\n\n  export default DS.Model.extend({\n});\n\n\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  profile: DS.belongsTo('profile')\n});\n\n\n\nThen you could test that the relationship is wired up correctly\nwith this test.\n\n  \n    \n      tests/unit/models/user-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  import { moduleForModel, test } from 'ember-qunit';\nimport Ember from 'ember';\n\nmoduleForModel('user', 'Unit | Model | user', {\n  // Specify the other units that are required for this test.\n  needs: ['model:profile']\n});\n\ntest('should own a profile', function(assert) {\n  const User = this.store().modelFor('user');\n  const relationship = Ember.get(User, 'relationshipsByName').get('profile');\n\n  assert.equal(relationship.key, 'profile', 'has relationship with profile');\n  assert.equal(relationship.kind, 'belongsTo', 'kind of relationship is belongsTo');\n});\n\n\n\nEmber Data contains extensive tests around the functionality of\nrelationships, so you probably don't need to duplicate those tests.  You could\nlook at the Ember Data tests for examples of deeper relationship testing if you\nfeel the need to do it.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"50d7d9948190dd788cabc6f1e832ec60","fields":[{"name":"title","value":"Testing Routes","type":"string"},{"name":"url","value":"/testing/testing-routes/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown \nin Unit Testing Basics because Ember.Route extends Ember.Object.\n\nTesting routes can be done both via acceptance or unit tests. Acceptance tests \nwill likely provide better coverage for routes because routes are typically used \nto perform transitions and load data, both of which are tested more easily in \nfull context rather than isolation.\n\nThat being said, sometimes it is important to unit test your routes. For example, \nlet's say we'd like to have an alert that can be triggered from anywhere within \nour application. The alert function displayAlert should be put into the \nApplicationRoute because all actions and events bubble up to it from \nsub-routes and controllers.\n\n\nBy default Ember CLI does not generate a file for its application route.  To\nextend the behavior of the ember application route we will run the command\nember generate route application.  Ember CLI does however generate an application\ntemplate, so when asked whether we want to overwrite app/templates/application.hbs\nwe will answer 'n'.\n\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Route.extend({\n  actions: {\n    displayAlert(text) {\n      this._displayAlert(text);\n    }\n  },\n\n  _displayAlert(text) {\n    alert(text);\n  }\n});\n\n\n\nIn this route we've separated our concerns:\nThe action displayAlert contains the code that is called when the action is \nreceived, and the private function _displayAlert performs the work. While not \nnecessarily obvious here because of the small size of the functions, separating \ncode into smaller chunks (or \"concerns\"), allows it to be more readily isolated \nfor testing, which in turn allows you to catch bugs more easily.\n\nHere is an example of how to unit test this route:\n\n  \n    \n      tests/unit/routes/application-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n  import { moduleFor, test } from 'ember-qunit';\n\nlet originalAlert;\n\nmoduleFor('route:application', 'Unit | Route | application', {\n  beforeEach() {\n    originalAlert = window.alert; // store a reference to window.alert\n  },\n\n  afterEach() {\n    window.alert = originalAlert; // restore window.alert\n  }\n});\n\ntest('should display an alert', function(assert) {\n  assert.expect(2);\n\n  // with moduleFor, the subject returns an instance of the route\n  let route = this.subject();\n\n  // stub window.alert to perform a qunit test\n  const expectedTextFoo = 'foo';\n  window.alert = (text) =\u003e {\n    assert.equal(text, expectedTextFoo, `expect alert to display ${expectedTextFoo}`);\n  };\n\n  // call the _displayAlert function which triggers the qunit test above\n  route._displayAlert(expectedTextFoo);\n\n  // set up a second stub to perform a test with the actual action\n  const expectedTextBar = 'bar';\n  window.alert = (text) =\u003e {\n    assert.equal(text, expectedTextBar, `expected alert to display ${expectedTextBar}`);\n  };\n\n  // Now use the routes send method to test the actual action\n  route.send('displayAlert', expectedTextBar);\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8da16330e9a3a38299664dcc2f2233af","fields":[{"name":"title","value":"Unit Testing Basics","type":"string"},{"name":"url","value":"/testing/unit-testing-basics/","type":"enum"},{"name":"body","value":"Unit tests are generally used to test a small piece of code and ensure that it\nis doing what was intended. Unlike acceptance tests, they are narrow in scope\nand do not require the Ember application to be running.\n\nAs it is the basic object type in Ember, being able to test a simple\nEmber.Object sets the foundation for testing more specific parts of your\nEmber application such as controllers, components, etc. Testing an Ember.Object\nis as simple as creating an instance of the object, setting its state, and\nrunning assertions against the object. By way of example lets look at a few\ncommon cases.\nTesting Computed Properties\nLet's start by creating an object that has a computedFoo computed property\nbased on a foo property.\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Object.extend({\n  foo: 'bar',\n\n  computedFoo: Ember.computed('foo', function() {\n    const foo = this.get('foo');\n    return `computed ${foo}`;\n  })\n});\n\n\n\nWithin the test for this object we'll create an instance, update the foo property (which\nshould trigger the computed property), and assert that the logic in our\ncomputed property is working correctly.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import { moduleFor, test } from 'ember-qunit';\n\nmoduleFor('model:some-thing', 'Unit | some thing', {\n  unit: true\n});\n\ntest('should correctly concat foo', function(assert) {\n  const someThing = this.subject();\n  someThing.set('foo', 'baz');\n  assert.equal(someThing.get('computedFoo'), 'computed baz');\n});\n\n\n\nSee that we have used moduleFor, one of the several unit-test helpers provided by Ember-Qunit.\nTest helpers provide us with some conveniences, such the subject function that handles lookup and instantiation for our object under test.\nNote that in a unit test you can customize the initialization of your object under test by passing to the\nsubject function an object containing the instance variables you would like to initialize.  For example, to initialize\nthe property 'foo' in our object under test, we would call this.subject({ foo: 'bar' });\nTesting Object Methods\nNext let's look at testing logic found within an object's method. In this case\nthe testMethod method alters some internal state of the object (by updating\nthe foo property).\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Object.extend({\n  foo: 'bar',\n  testMethod() {\n    this.set('foo', 'baz');\n  }\n});\n\n\n\nTo test it, we create an instance of our class SomeThing as defined above,\ncall the testMethod method and assert that the internal state is correct as a\nresult of the method call.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  test('should update foo on testMethod', function(assert) {\n  const someThing = this.subject();\n  someThing.testMethod();\n  assert.equal(someThing.get('foo'), 'baz');\n});\n\n\n\nIn the event the object's method returns a value you can simply assert that the\nreturn value is calculated correctly. Suppose our object has a calc method\nthat returns a value based on some internal state.\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Object.extend({\n  count: 0,\n  calc() {\n    this.incrementProperty('count');\n    let count = this.get('count');\n    return `count: ${count}`;\n  }\n});\n\n\n\nThe test would call the calc method and assert it gets back the correct value.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  test('should return incremented count on calc', function(assert) {\n  const someThing = this.subject();\n  assert.equal(someThing.calc(), 'count: 1');\n  assert.equal(someThing.calc(), 'count: 2');\n});\n\n\nTesting Observers\nSuppose we have an object that has a property and a method observing that property.\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Object.extend({\n  foo: 'bar',\n  other: 'no',\n  doSomething: Ember.observer('foo', function() {\n    this.set('other', 'yes');\n  })\n});\n\n\n\nIn order to test the doSomething method we create an instance of SomeThing,\nupdate the observed property (foo), and assert that the expected effects are present.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  test('should set other prop to yes when foo changes', function(assert) {\n  const someThing = this.subject();\n  someThing.set('foo', 'baz');\n  assert.equal(someThing.get('other'), 'yes');\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]}]}